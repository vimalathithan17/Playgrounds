{
  "title": "Constraints Comparison",
  "description": "A narrative guide comparing core SQL constraints (NOT NULL, PRIMARY KEY, UNIQUE, CHECK, FOREIGN KEY) plus composite vs multiple uniqueness patterns, cascade behaviors, and practical migration strategies in DuckDB. Each example starts with a question and ends with a runnable, idempotent snippet.",
  "sections": [
    {
      "title": "0. Introduction: Constraints Overview",
      "description": "What constraints do: data quality and invariants at the storage layer — NOT NULL, PRIMARY KEY, UNIQUE, CHECK, and FOREIGN KEY.",
      "examples": [],
      "narrative": "Constraints encode core rules close to the data so mistakes are caught early. Use NOT NULL when missing values have no meaning, PRIMARY KEY for canonical identity (unique + not null), UNIQUE for alternate keys, CHECK for domain rules, and FOREIGN KEY to keep relationships consistent.",
      "nerd_notes": "DuckDB treats constraints primarily as metadata for now; use patterns like create-copy-rename and LEFT JOIN orphan checks to simulate enforcement and validation in pipelines."
    },
    {
      "title": "1. Setup: small reference tables",
      "description": "Foundational tables used in several comparisons.",
      "examples": [
        {
          "name": "create_reference",
          "sql": "DROP TABLE IF EXISTS ref_a;\nDROP TABLE IF EXISTS ref_b;\nCREATE TABLE ref_a (id INTEGER PRIMARY KEY, val TEXT NOT NULL);\nCREATE TABLE ref_b (id INTEGER, val TEXT);\nINSERT INTO ref_a VALUES (1,'A1'),(2,'A2');\nINSERT INTO ref_b VALUES (1,'B1'),(NULL,'B2');\nSELECT 'ref_a' AS tbl, * FROM ref_a;\nSELECT 'ref_b' AS tbl, * FROM ref_b;",
          "description": "Question: how do we create two tiny reference tables (one with NOT NULL + PRIMARY KEY, one relaxed) for later comparisons?",
          "nerd_notes": "ref_a enforces both uniqueness and non-null on id plus non-null on val; ref_b is intentionally permissive so later examples can demonstrate NULL handling and copy-filter patterns.",
          "compat_examples": {
            "postgres": "-- PostgreSQL: same DDL works; optionally add GENERATED ALWAYS AS IDENTITY for id in ref_a",
            "mysql": "-- MySQL: PRIMARY KEY + NOT NULL same; add AUTO_INCREMENT to id if you want automatic numbering",
            "oracle": "-- Oracle: use NUMBER for integers; add GENERATED BY DEFAULT AS IDENTITY for id if desired"
          }
        }
      ],
      "narrative": "We start with two tiny tables so every later example can focus only on the constraint being discussed. Keeping setup explicit and idempotent means you can re-run the whole lesson without manual cleanup.",
      "nerd_notes": "Idempotent pattern: always DROP before CREATE in teaching demos. Real migrations would use ALTER or create-copy-rename patterns instead of destructive drops."
    },
    {
      "title": "1.5 Cheat Sheet: Common Constraint Patterns",
      "description": "Copy-ready, idempotent snippets showing typical constraint usage and validation patterns.",
      "examples": [
        {
          "name": "cs_not_null_with_default",
          "description": "Declare NOT NULL with DEFAULT so inserts can omit the column safely.",
          "sql": "DROP TABLE IF EXISTS cs_users;\nCREATE TABLE cs_users (id INTEGER PRIMARY KEY, email TEXT NOT NULL DEFAULT 'unknown@example.com');\nINSERT INTO cs_users(id) VALUES (1);\nSELECT * FROM cs_users ORDER BY id;\nDROP TABLE IF EXISTS cs_users;",
          "nerd_notes": "DEFAULT values pair well with NOT NULL to avoid NULL floods."
        },
        {
          "name": "cs_unique_composite",
          "description": "Composite UNIQUE across (dept, code).",
          "sql": "DROP TABLE IF EXISTS cs_dept_codes;\nCREATE TABLE cs_dept_codes (dept TEXT, code TEXT, UNIQUE(dept, code));\nINSERT INTO cs_dept_codes VALUES ('Sales','A'),('Sales','B'),('Eng','A');\nSELECT * FROM cs_dept_codes ORDER BY dept, code;\nDROP TABLE IF EXISTS cs_dept_codes;",
          "nerd_notes": "Composite uniqueness models 'pair must be unique' rules compactly."
        },
        {
          "name": "cs_check_via_ctas_filter",
          "description": "Simulate CHECK by filtered copy (CTAS).",
          "sql": "DROP TABLE IF EXISTS cs_raw;\nDROP TABLE IF EXISTS cs_clean;\nCREATE TABLE cs_raw(id INTEGER, qty INTEGER);\nINSERT INTO cs_raw VALUES (1,10),(2,-5);\nCREATE TABLE cs_clean AS SELECT * FROM cs_raw WHERE qty >= 0;\nSELECT * FROM cs_clean ORDER BY id;\nDROP TABLE IF EXISTS cs_clean;\nDROP TABLE IF EXISTS cs_raw;",
          "nerd_notes": "Use CTAS filtering when ALTER ADD CHECK isn't available or you want staged validation."
        },
        {
          "name": "cs_fk_orphan_detection",
          "description": "Detect orphan children via LEFT JOIN anti-match.",
          "sql": "DROP TABLE IF EXISTS cs_parent;\nDROP TABLE IF EXISTS cs_child;\nCREATE TABLE cs_parent(pid INTEGER PRIMARY KEY);\nCREATE TABLE cs_child(cid INTEGER, pid INTEGER);\nINSERT INTO cs_parent VALUES (1),(2);\nINSERT INTO cs_child VALUES (10,1),(11,99);\nSELECT c.cid, c.pid, CASE WHEN p.pid IS NULL THEN 'ORPHAN' ELSE 'OK' END AS status\nFROM cs_child c LEFT JOIN cs_parent p ON c.pid = p.pid ORDER BY c.cid;\nDROP TABLE IF EXISTS cs_child; DROP TABLE IF EXISTS cs_parent;",
          "nerd_notes": "Periodic orphan scans approximate FK enforcement in pipelines lacking hard FKs."
        }
      ],
      "narrative": "These micro-snippets cover high-utility patterns you'll reuse across schemas.",
      "nerd_notes": "Keep snippets idempotent (DROP before CREATE) so they can run repeatedly in the playground and CI."
    },
    {
      "title": "1.6 Pitfalls, Tips, and Q&A",
      "description": "Common constraint mistakes and conceptual clarifications.",
      "examples": [
        {
          "name": "pitfall_unique_allows_nulls",
          "description": "Q: Why does my UNIQUE column allow multiple NULLs?",
          "sql": "",
          "nerd_notes": "Most engines permit multiple NULLs under UNIQUE (NULL ≠ NULL). Combine UNIQUE with NOT NULL to prevent this."
        },
        {
          "name": "tip_stage_constraints",
          "description": "Tip: Stage constraints gradually on large tables.",
          "sql": "",
          "nerd_notes": "Use copy-validate-swap or add-not-valid-then-validate patterns (where supported) to avoid long locks."
        },
        {
          "name": "question_pk_vs_surrogate",
          "description": "Q: Natural composite key or surrogate PRIMARY KEY?",
          "sql": "",
          "nerd_notes": "Prefer stable natural keys where clear; otherwise use surrogate PK + UNIQUE on the natural key to preserve business invariants."
        },
        {
          "name": "tricky_oracle_empty_string",
          "description": "Q: Why do empty strings become NULL in some databases?",
          "sql": "",
          "nerd_notes": "Oracle treats '' as NULL in VARCHAR2; porting schemas may need COALESCE/DEFAULT adjustments."
        },
        {
          "name": "fundamental_fk_immediate_vs_deferred",
          "description": "Q: Immediate vs deferred FK checks?",
          "sql": "",
          "nerd_notes": "Some engines support deferred constraint checks at transaction commit time; useful for cyclical loads."
        }
      ],
      "narrative": "Use these notes to avoid common modeling pitfalls and choose the right constraint for the job.",
      "nerd_notes": "Document intent in the schema: future readers (and you) will thank you."
    },
    {
      "title": "2. NULL vs NOT NULL",
      "description": "Contrast how columns accepting NULL differ from those declared NOT NULL.",
      "examples": [
        {
          "name": "null_vs_notnull",
          "sql": "-- Show side-by-side NULL allowance differences\nSELECT 'ref_a' AS tbl, * FROM ref_a;\nSELECT 'ref_b' AS tbl, * FROM ref_b;\n-- ref_a.val rejects NULL; ref_b.val allows it (id may also be NULL in ref_b)",
          "description": "Question: how can we quickly compare a NOT NULL enforced column vs a nullable column?",
          "nerd_notes": "NOT NULL is the cheapest data quality constraint; add it wherever NULL has no semantic meaning. DuckDB stores NULL bitmaps; excessive nullable columns can add slight memory overhead but improve flexibility.",
          "compat_examples": {
            "postgres": "-- Standard behavior: NOT NULL enforced, nullable columns accept NULL.",
            "mysql": "-- MySQL: same semantics; watch for STRICT mode when inserting implicit NULLs.",
            "oracle": "-- Oracle: NOT NULL behaves the same; empty string in VARCHAR2 becomes NULL (Oracle quirk)."
          }
        }
      ],
      "narrative": "NULL means 'unknown / missing'. Declaring NOT NULL documents intent and allows earlier failure. This section shows the visual difference and reinforces why explicit constraints catch mistakes upfront.",
  "nerd_notes": "If you need explicit default values, prefer DEFAULT + NOT NULL rather than allowing NULL then COALESCE everywhere."
    },
    {
      "title": "3. PRIMARY KEY vs UNIQUE",
      "description": "Show functional overlap and subtle differences.",
      "examples": [
        {
          "name": "pk_vs_unique",
          "sql": "DROP TABLE IF EXISTS uniq_test;\nCREATE TABLE uniq_test (id INTEGER UNIQUE, name TEXT);\nINSERT INTO uniq_test VALUES (1,'x'), (2,'y');\nSELECT * FROM uniq_test;",
          "description": "Question: how does a UNIQUE column differ from declaring it as a PRIMARY KEY?",
          "nerd_notes": "PRIMARY KEY implies (conceptually) uniqueness + NOT NULL (DuckDB treats it as constraint metadata). A plain UNIQUE allows NULL unless paired with NOT NULL. Many engines permit one PRIMARY KEY per table but multiple UNIQUE constraints.",
          "compat_examples": {
            "postgres": "-- PostgreSQL: PRIMARY KEY creates a unique btree index + NOT NULL implicitly.",
            "mysql": "-- MySQL: PRIMARY KEY uses clustered index (InnoDB); UNIQUE allows multiple NULLs.",
            "oracle": "-- Oracle: PRIMARY KEY creates a unique index; UNIQUE permits multiple NULLs."
          }
        }
      ],
      "narrative": "Both PRIMARY KEY and UNIQUE enforce distinctness, but PRIMARY KEY additionally conveys table identity and disallows NULL. Choose PRIMARY KEY for the canonical identifier; use UNIQUE for alternate keys.",
      "nerd_notes": "In analytic lakehouse contexts you might rely on surrogate keys (UUIDs) + constraints for deduplication logic downstream."
    },
    {
      "title": "4. Composite PRIMARY KEY vs multiple single-column UNIQUE",
      "description": "Compare enforcing uniqueness across a column pair vs independently per column.",
      "examples": [
        {
          "name": "composite_pk_vs_multi_unique",
          "sql": "DROP TABLE IF EXISTS comp_pk;\nDROP TABLE IF EXISTS multi_unique;\nCREATE TABLE comp_pk (a INTEGER, b INTEGER, value TEXT, PRIMARY KEY (a,b));\nCREATE TABLE multi_unique (a INTEGER, b INTEGER, value TEXT, UNIQUE(a), UNIQUE(b));\nINSERT INTO comp_pk (a,b,value) VALUES (1,10,'ok1'),(1,11,'ok2');\nINSERT INTO multi_unique (a,b,value) VALUES (1,10,'m1');\nSELECT 'comp_pk' AS tbl, * FROM comp_pk;\nSELECT 'multi_unique' AS tbl, * FROM multi_unique;",
          "description": "Question: when should we use a composite PRIMARY KEY versus separate UNIQUE constraints on each column?",
          "nerd_notes": "Composite PK enforces uniqueness on the tuple (a,b) only. Separate UNIQUE(a) and UNIQUE(b) force each column to be globally unique — a very different rule. Choose composite when the pairing forms the natural key.",
          "compat_examples": {
            "postgres": "-- PostgreSQL: same syntax; composite PK creates multicolumn index.",
            "mysql": "-- MySQL: InnoDB clusters by PRIMARY KEY; composite key affects physical ordering.",
            "oracle": "-- Oracle: composite PK creates composite unique index automatically."
          }
        }
      ],
      "narrative": "Misunderstanding composite vs multiple single-column uniqueness is a classic data modeling bug. This section isolates the difference so you can spot incorrect schemas early.",
      "nerd_notes": "Multiple single-column UNIQUEs can inflate index maintenance cost and block valid duplicate pairs."
    },
    {
      "title": "5. CHECK pattern via copy filter",
      "description": "DuckDB-style simulation of a CHECK constraint using a filtered copy (practical when altering existing data).",
      "examples": [
        {
          "name": "check_examples",
          "sql": "DROP TABLE IF EXISTS checked;\nCREATE TABLE checked AS SELECT * FROM ref_b WHERE id IS NOT NULL;\nSELECT * FROM checked;",
          "description": "Question: how can we enforce a rule (id must be NOT NULL) post-hoc without native ALTER ADD CHECK?",
          "nerd_notes": "Use create-table-as-select with a WHERE predicate to materialize only rows passing the rule, then swap tables if needed. This is the same pattern used for backfilling or tightening constraints incrementally.",
          "compat_examples": {
            "postgres": "-- PostgreSQL: could instead ALTER TABLE ref_b ADD CONSTRAINT chk_id_not_null CHECK (id IS NOT NULL) NOT VALID; then VALIDATE CONSTRAINT.",
            "mysql": "-- MySQL: ALTER TABLE ADD CONSTRAINT CHECK is enforced in modern versions; historically ignored in MySQL <8.0.16.",
            "oracle": "-- Oracle: ALTER TABLE ADD CONSTRAINT CHECK (id IS NOT NULL) ENABLE NOVALIDATE for phased rollout."
          }
        }
      ],
      "narrative": "Not all engines or versions allow adding CHECK constraints easily. A universal approach is to build a filtered copy containing only valid rows, verify counts, then adopt it.",
      "nerd_notes": "Always compare row counts between source and filtered copy; log rejects to an exceptions table for auditing."
    },
    {
      "title": "6. FOREIGN KEY ON DELETE behaviors (simulated pattern)",
      "description": "Illustrate cascade vs set null vs restrict intent using separate child tables.",
      "examples": [
        {
          "name": "fk_on_delete_behaviors",
          "sql": "-- Simulated FK behaviors without declaring actual constraints to avoid drop errors in DuckDB validation\nDROP TABLE IF EXISTS fk_child_cascade;\nDROP TABLE IF EXISTS fk_child_setnull;\nDROP TABLE IF EXISTS fk_child_restrict;\nDROP TABLE IF EXISTS fk_parent;\nCREATE TABLE fk_parent (pid INTEGER PRIMARY KEY, name TEXT);\nCREATE TABLE fk_child_cascade (cid INTEGER, pid INTEGER, info TEXT); -- would be ON DELETE CASCADE\nCREATE TABLE fk_child_setnull (cid INTEGER, pid INTEGER, info TEXT);  -- would be ON DELETE SET NULL\nCREATE TABLE fk_child_restrict (cid INTEGER, pid INTEGER, info TEXT); -- would be ON DELETE RESTRICT\nINSERT INTO fk_parent VALUES (10,'P_CASCADE'),(20,'P_SETNULL'),(30,'P_RESTRICT');\nINSERT INTO fk_child_cascade VALUES (100,10,'casc_a'),(101,10,'casc_b');\nINSERT INTO fk_child_setnull VALUES (200,20,'set_a'),(201,20,'set_b');\nINSERT INTO fk_child_restrict VALUES (300,30,'res_a'),(301,30,'res_b');\n-- Emulate ON DELETE CASCADE by deleting parent then manually deleting children with matching pid\nDELETE FROM fk_parent WHERE pid = 10;\nDELETE FROM fk_child_cascade WHERE pid = 10;\n-- Emulate ON DELETE SET NULL by nulling child pid before deleting parent\nUPDATE fk_child_setnull SET pid = NULL WHERE pid = 20;\nDELETE FROM fk_parent WHERE pid = 20;\n-- RESTRICT: we intentionally do NOT delete parent 30 to show children remain\nSELECT 'cascade_after' AS phase, * FROM fk_child_cascade;\nSELECT 'setnull_after' AS phase, * FROM fk_child_setnull;\nSELECT 'restrict_children' AS phase, * FROM fk_child_restrict;\nSELECT 'remaining_parents' AS phase, * FROM fk_parent;",
          "description": "Question: how do different ON DELETE actions (CASCADE, SET NULL, RESTRICT) conceptually change child table state?",
          "nerd_notes": "Some analytical engines treat FK constraints as documentation only. The example emulates outcomes explicitly so learners internalize semantics even without engine enforcement.",
          "compat_examples": {
            "postgres": "-- PostgreSQL: define explicit constraints with ON DELETE CASCADE / SET NULL / RESTRICT and let engine enforce.",
            "mysql": "-- MySQL (InnoDB): same semantics; ensure foreign_key_checks=1.",
            "oracle": "-- Oracle: ON DELETE CASCADE and SET NULL supported; RESTRICT is default behavior when omitted."
          }
        }
      ],
      "narrative": "Foreign key actions govern what happens to dependent rows when a parent disappears. Even if not enforced, modeling expected outcomes helps reason about downstream data consistency.",
      "nerd_notes": "If true FK enforcement is unavailable, schedule periodic validation queries that LEFT JOIN child rows to missing parents and alert on orphans."
    },
    {
      "title": "7. Composite vs single composite UNIQUE (performance reasoning)",
      "description": "Discuss modeling trade-offs more than raw benchmarking (not measured here).",
      "examples": [
        {
          "name": "constraint_design_tradeoffs",
          "sql": "DROP TABLE IF EXISTS composite_pk_perf;\nDROP TABLE IF EXISTS single_composite_unique_perf;\nCREATE TABLE composite_pk_perf (category1 TEXT, category2 TEXT, data TEXT, PRIMARY KEY (category1, category2));\nCREATE TABLE single_composite_unique_perf (category1 TEXT, category2 TEXT, data TEXT, UNIQUE (category1, category2));\nINSERT INTO composite_pk_perf VALUES ('A','X','Data 1'),('A','Y','Data 2');\nINSERT INTO single_composite_unique_perf VALUES ('A','X','Data 1'),('A','Y','Data 2');\nSELECT 'pk_lookup' AS scenario, * FROM composite_pk_perf WHERE category1='A' AND category2='X';\nSELECT 'uniq_lookup' AS scenario, * FROM single_composite_unique_perf WHERE category1='A' AND category2='X';",
          "description": "Question: when is a composite PRIMARY KEY materially different from a single composite UNIQUE constraint?",
          "nerd_notes": "In many engines they create similar underlying index structures; difference is semantic (table identity vs alternate key) and NOT NULL enforcement. Choose PRIMARY KEY for canonical row identity.",
          "compat_examples": {
            "postgres": "-- PostgreSQL: composite PK vs UNIQUE both create btree indexes; PK implies NOT NULL.",
            "mysql": "-- MySQL: PRIMARY KEY influences clustering; composite UNIQUE does not.",
            "oracle": "-- Oracle: both create indexes; PK flagged in data dictionary with additional metadata."
          }
        }
      ],
      "narrative": "Benchmarks aside, the main distinction is semantic clarity and default NOT NULL enforcement. This example shows both forms executing identical lookups to highlight that design intent matters as much as mechanics.",
      "nerd_notes": "If you later introduce a surrogate key, convert the former composite PRIMARY KEY into a UNIQUE and promote the surrogate to PRIMARY KEY."
    },
    {
      "title": "8. Constraint interactions & precedence (conceptual)",
      "description": "Show multiple constraint types on one table and discuss evaluation order conceptually.",
      "examples": [
        {
          "name": "constraint_interactions_precedence",
          "sql": "DROP TABLE IF EXISTS constraint_interaction_test;\nCREATE TABLE constraint_interaction_test (id INTEGER, parent_id INTEGER, name TEXT NOT NULL, email TEXT NOT NULL, category TEXT, PRIMARY KEY(id), -- conceptual PK\n-- Conceptual foreign key (self reference)\n-- FOREIGN KEY(parent_id) REFERENCES constraint_interaction_test(id) ON DELETE SET NULL,\n-- Uniqueness rules\nUNIQUE(email),\nUNIQUE(name, category),\n-- Simulated check rules (would be CHECK in fully enforced engines)\n-- CHECK (id > 0),\n-- CHECK (email LIKE '%@%'),\n-- CHECK (category IN ('A','B','C'))\n);\nINSERT INTO constraint_interaction_test VALUES (1,NULL,'Root Item','root@example.com','A');\nINSERT INTO constraint_interaction_test VALUES (2,1,'Child Item 1','child1@example.com','B');\nSELECT * FROM constraint_interaction_test;",
          "description": "Question: how do multiple constraints (PK, UNIQUE, checks, FKs) conceptually interact on a single table?",
          "nerd_notes": "Engines typically validate NOT NULL and type first, then CHECK, then FK/UNIQUE/PK depending on optimizer. In teaching contexts you can comment constraints to discuss them without execution failures.",
          "compat_examples": {
            "postgres": "-- PostgreSQL: actual evaluation order is internal; rely on documented semantics rather than ordering assumptions.",
            "mysql": "-- MySQL: constraint enforcement order can vary; focus on which guarantees you need, not order.",
            "oracle": "-- Oracle: all declared constraints enforced; evaluation order rarely user-visible unless multiple failures occur."
          }
        }
      ],
      "narrative": "Stacking constraints clarifies which invariants belong at the storage layer vs application layer. Even if some are informational only, documenting them aids discoverability.",
      "nerd_notes": "When retrofitting constraints, add them gradually (validate offline) to avoid blocking writes with large table scans."
    },
    {
      "title": "9. Cleanup",
      "description": "Drop demo objects to keep workspace clean.",
      "examples": [
        {
          "name": "cleanup",
          "sql": "DROP TABLE IF EXISTS fk_child_cascade; DROP TABLE IF EXISTS fk_child_setnull; DROP TABLE IF EXISTS fk_child_restrict; DROP TABLE IF EXISTS fk_parent; DROP TABLE IF EXISTS ref_a; DROP TABLE IF EXISTS ref_b; DROP TABLE IF EXISTS uniq_test; DROP TABLE IF EXISTS comp_pk; DROP TABLE IF EXISTS multi_unique; DROP TABLE IF EXISTS checked; DROP TABLE IF EXISTS composite_pk_perf; DROP TABLE IF EXISTS single_composite_unique_perf; DROP TABLE IF EXISTS constraint_interaction_test;",
          "description": "Question: how do we reset all objects created by this comparison lesson?",
          "nerd_notes": "Centralized cleanup makes repeated validator runs fast and avoids name collisions.",
          "compat_examples": {
            "postgres": "-- DROP TABLE IF EXISTS works; add CASCADE if dependent views exist.",
            "mysql": "-- DROP TABLE IF EXISTS works; ensure no pending transactions hold locks.",
            "oracle": "-- Use DROP TABLE name PURGE to bypass recycle bin in some environments."
          }
        }
      ],
      "narrative": "Tidying up ensures subsequent lessons can reuse the same object names without ambiguity.",
      "nerd_notes": "In production migrations you would not drop; you'd evolve schemas. This is strictly for educational isolation."
    }
  ],
  "exercises": [
    {
      "id": "basic-select",
      "prompt": "Show the first 5 rows from `ref_a` (after running setup).",
      "answer_sql": "SELECT * FROM ref_a LIMIT 5;"
    },
    {
      "id": "unique-vs-pk",
      "prompt": "Return all rows from `uniq_test` showing the enforced uniqueness fields.",
      "answer_sql": "SELECT id, name FROM uniq_test ORDER BY id;"
    },
    {
      "id": "composite-key-check",
      "prompt": "List rows from `comp_pk` ordered by (a,b).",
      "answer_sql": "SELECT a,b,value FROM comp_pk ORDER BY a,b;"
    }
  ]
}
