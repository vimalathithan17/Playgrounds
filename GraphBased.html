<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Graph Database Emulator (Neo4j/Cypher) - Definitive Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- CodeMirror for the main editor -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/material-darker.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/sql/sql.min.js"></script>

    <!-- highlight.js for static example highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- D3.js for visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }
    :root { --mobile-nav-height: 56px; }
        .CodeMirror {
            font-family: 'Fira Code', monospace;
            font-size: 14px;
            line-height: 21px;
            height: 100%;
            background-color: #1e1e1e;
        }
        .CodeMirror-gutters {
            background-color: #252526 !important;
            border-right: 1px solid #3a3a3a;
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #2d2d2d;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #555;
            border-radius: 3px;
        }
        .resizer {
            background-color: #3a3a3a;
            cursor: row-resize;
            width: 100%;
            height: 5px;
            z-index: 10;
        }
    /* Keep the Run button visible even with long editors */
    #editor-container { min-height: 0; }
    #editor-wrapper { overflow: auto; }
    #action-bar { position: sticky; bottom: 0; z-index: 5; }
        .console-output {
            font-family: 'Fira Code', monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .console-output .ok { color: #6ee7b7; }
        .console-output .error { color: #f472b6; }
        .console-output .info { color: #a5b4fc; }
        .console-output .prompt { color: #6b7280; }
        .mobile-nav-btn.active {
            color: #6ee7b7;
            border-color: #6ee7b7;
        }
        .results-tab-btn.active {
            border-color: #6ee7b7;
            background-color: #2d2d2d;
        }
        




        /* D3 Visualization Styles */
        .node circle {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: grab;
        }
        .node.fixed circle {
             stroke: #6ee7b7; /* Highlight pinned nodes */
             stroke-width: 2.5px;
        }
        .node:active {
            cursor: grabbing;
        }
        .link {
            stroke-opacity: 0.6;
        }
        .link-label {
            font-size: 10px;
            fill: #a0a0a0;
            text-anchor: middle;
            pointer-events: none;
            paint-order: stroke;
            stroke: #1e1e1e;
            stroke-width: 2px;
        }
        .node text {
            fill: #e0e0e0;
            font-size: 11px;
            text-anchor: middle;
            pointer-events: none;
            paint-order: stroke;
            stroke: #1e1e1e;
            stroke-width: 2px;
        }
        /* Modal Styles */
        #details-modal-overlay {
            z-index: 50;
        }

                /* Mobile bottom nav: fixed + safe-area and content padding */
                @media (max-width: 768px) {
                    nav.md\\:hidden { position: fixed; bottom: 0; left: 0; right: 0; z-index: 45; padding-bottom: env(safe-area-inset-bottom); }
                    main { padding-bottom: calc(var(--mobile-nav-height) + env(safe-area-inset-bottom)); }
                }
    </style>
</head>
<body class="flex flex-col h-screen">

    <main class="flex flex-grow overflow-hidden md:flex-row flex-col">
        <!-- Left Panel: Information and Examples -->
        <div id="info-panel" class="main-panel w-full md:w-2/5 h-full bg-[#1e1e1e] p-6 custom-scrollbar overflow-y-auto overflow-x-hidden border-r border-gray-700 min-w-0">
            <div class="prose prose-invert max-w-none">
                <h2 class="text-2xl font-bold text-gray-100">Graph Database Emulator</h2>
                <p class="text-sm text-gray-400">A feature-complete, in-memory emulator for a Property Graph database, inspired by Neo4j and its Cypher query language.</p>

                <div id="info-panel-content">
                    <!-- Content injected by JS -->
                </div>

                <div id="example-categories" class="space-y-6 mt-6">
                    <!-- Examples will be injected here by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Right Panel: Editor and Console/Visualizer -->
        <div id="right-panel" class="main-panel flex-1 flex-col w-full md:w-3/5 h-full bg-[#252526] hidden md:flex min-w-0">
            <!-- Title Bar for Editor -->
            <div class="flex-shrink-0 bg-[#282828] p-3 border-b border-gray-700">
                <h3 class="text-lg font-semibold text-gray-200">Cypher Query Console</h3>
                <p class="text-sm text-gray-400">Write Cypher queries to explore and manipulate the graph database.</p>
            </div>
            <div id="editor-container" class="flex-grow flex flex-col overflow-hidden" style="height: 70%;">
                <div id="editor-wrapper" class="flex-grow relative">
                    <textarea id="command-editor"></textarea>
                </div>
                <div id="action-bar" class="flex-shrink-0 bg-[#282828] p-2 flex justify-end items-center gap-3 border-t border-gray-700">
                    <button id="run-command-btn" class="bg-green-600 hover:bg-green-700 text-white font-semibold px-4 py-1.5 rounded-md text-sm transition-colors">Run (Ctrl+Enter)</button>
                </div>
            </div>
            <div id="resizer" class="resizer"></div>
            <div id="results-container" class="flex-grow flex flex-col overflow-hidden" style="height: 30%;">
                <div class="flex-shrink-0 bg-[#282828] border-b border-gray-700">
                    <div class="flex items-center justify-between p-2">
                        <div class="flex">
                            <button class="results-tab-btn active px-3 py-1 text-sm font-medium border-b-2" data-tab="console">Console</button>
                            <button class="results-tab-btn px-3 py-1 text-sm font-medium border-b-2 border-transparent" data-tab="visual">Graph View</button>
                            <button class="results-tab-btn px-3 py-1 text-sm font-medium border-b-2 border-transparent" data-tab="params">Parameters</button>
                        </div>
                        <button id="clear-console-btn" class="text-xs text-gray-400 hover:text-white">Clear</button>
                    </div>
                </div>
                <div id="console-output-content" class="results-tab-content flex-grow bg-[#1e1e1e] overflow-auto custom-scrollbar p-3 console-output">
                    <span class="prompt" id="console-prompt">></span> Welcome! This is the feature-complete Graph DB Emulator.
                </div>
                <div id="visual-output-content" class="results-tab-content flex-grow bg-[#1e1e1e] overflow-hidden hidden relative">
                     <div class="absolute top-2 left-2 z-10">
                        <button id="recenter-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold px-3 py-1.5 rounded-md text-xs">Recenter</button>
                    </div>
                    <svg id="visual-output" class="w-full h-full"></svg>
                    <div class="absolute bottom-2 right-2 text-xs text-gray-500">Click to inspect, Drag to pin, Double-click to unpin</div>
                </div>
                <div id="params-output-content" class="results-tab-content flex-grow bg-[#1e1e1e] hidden">
                     <textarea id="param-editor" class="w-full h-full bg-[#1e1e1e] text-gray-300 font-mono text-sm p-2 focus:outline-none custom-scrollbar"></textarea>
                </div>
            </div>
        </div>
    </main>

    <nav id="mobile-nav" class="md:hidden bg-[#282828] border-t border-gray-700 w-full flex-shrink-0">
        <button class="mobile-nav-btn active flex-1 p-3 text-sm text-center font-medium border-t-2" data-view="info">
            <svg class="w-5 h-5 mx-auto mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
            </svg>
            Info
        </button>
        <button class="mobile-nav-btn flex-1 p-3 text-sm text-center font-medium border-t-2 border-transparent" data-view="right">
            <svg class="w-5 h-5 mx-auto mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
            </svg>
            Editor
        </button>
        <button class="mobile-nav-btn flex-1 p-3 text-sm text-center font-medium border-t-2 border-transparent" data-view="graph">
            <svg class="w-5 h-5 mx-auto mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
            </svg>
            Graph
        </button>
    </nav>
    
    <!-- Mobile Full-Screen Graph View -->
    <div id="mobile-graph-view" class="md:hidden fixed inset-0 bg-[#1e1e1e] z-50 hidden">
        <div class="flex flex-col h-full">
            <div class="flex items-center justify-between p-4 bg-[#282828] border-b border-gray-700">
                <h3 class="text-lg font-semibold text-gray-200">Graph Visualization</h3>
                <button id="close-mobile-graph" class="text-gray-400 hover:text-white">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 relative">
                <div class="absolute top-2 left-2 z-10">
                    <button id="mobile-recenter-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold px-3 py-1.5 rounded-md text-xs">Recenter</button>
                </div>
                <svg id="mobile-visual-output" class="w-full h-full"></svg>
                <div class="absolute bottom-2 right-2 text-xs text-gray-500">Click to inspect, Drag to pin, Double-click to unpin</div>
            </div>
        </div>
    </div>
    
    <!-- Node Details Modal -->
    <div id="details-modal-overlay" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden">
        <div id="details-modal" class="bg-[#2d2d2d] rounded-lg shadow-xl p-6 w-full max-w-md border border-gray-700">
            <h3 class="text-lg font-bold text-gray-100 mb-2">Node Details</h3>
            <div class="text-sm mb-4">
                <p><strong class="text-gray-400">ID:</strong> <span id="modal-node-id" class="text-sky-400"></span></p>
                <p><strong class="text-gray-400">Labels:</strong> <span id="modal-node-labels" class="text-teal-400"></span></p>
            </div>
            <h4 class="font-semibold text-gray-200 mb-2">Properties:</h4>
            <pre id="modal-node-properties" class="bg-[#1e1e1e] p-3 rounded-md text-sm custom-scrollbar max-h-64 overflow-auto"></pre>
            <div class="mt-6 text-right">
                <button id="modal-close-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold px-4 py-1.5 rounded-md text-sm">Close</button>
            </div>
        </div>
    </div>


    <script>
        // --- DATABASE MANAGEMENT ---
        class DatabaseManager {
            constructor() {
                this.databases = new Map();
                this.currentDbName = 'default';
                this.databases.set(this.currentDbName, { db: new GraphDB(), lastQueryResult: null });
            }
            createDatabase(name) {
                if (this.databases.has(name)) throw new Error(`Database '${name}' already exists.`);
                this.databases.set(name, { db: new GraphDB(), lastQueryResult: null });
            }
            dropDatabase(name) {
                if (name === 'default') throw new Error("Cannot drop the default database.");
                if (!this.databases.delete(name)) throw new Error(`Database '${name}' not found.`);
                if (this.currentDbName === name) {
                    this.useDatabase('default');
                }
            }
            useDatabase(name) {
                if (!this.databases.has(name)) throw new Error(`Database '${name}' not found.`);
                this.currentDbName = name;
            }
            getCurrentDb() {
                return this.databases.get(this.currentDbName).db;
            }
            getLastQueryResult() {
                return this.databases.get(this.currentDbName).lastQueryResult;
            }
            setLastQueryResult(result) {
                this.databases.get(this.currentDbName).lastQueryResult = result;
            }
        }

        // --- CORE GRAPH DATABASE ENGINE ---
        class GraphDB {
            constructor() {
                this.nodes = new Map();
                this.relationships = new Map();
                this.labelsToNodes = new Map();
                this.nodeRelationships = new Map();
                this._nodeIdCounter = 0;
                this._relIdCounter = 0;
                this.constraints = new Map();
                this.indexes = new Map();
                this.constraintNames = new Map(); // name -> label.property
            }
            _getNextNodeId() { return this._nodeIdCounter++; }
            _getNextRelId() { return this._relIdCounter++; }
            createNode(labels = [], properties = {}) {
                for (const label of labels) {
                    for (const prop in properties) {
                        const key = `${label}.${prop}`;
                        if (this.constraints.has(key)) {
                            const value = properties[prop];
                            if (this.constraints.get(key).has(value)) {
                                throw new Error(`Constraint violation: Node with label '${label}' and property '${prop}' already exists with value '${value}'.`);
                            }
                        }
                    }
                }

                const id = this._getNextNodeId();
                const node = { id, labels: new Set(labels), properties };
                this.nodes.set(id, node);
                this.nodeRelationships.set(id, { incoming: new Set(), outgoing: new Set() });
                labels.forEach(label => {
                    if (!this.labelsToNodes.has(label)) this.labelsToNodes.set(label, new Set());
                    this.labelsToNodes.get(label).add(id);
                    for (const prop in properties) {
                        const key = `${label}.${prop}`;
                        if (this.constraints.has(key)) {
                            this.constraints.get(key).add(properties[prop]);
                        }
                    }
                });
                return node;
            }
            createRelationship(startNodeId, endNodeId, type, properties = {}) {
                if (!this.nodes.has(startNodeId) || !this.nodes.has(endNodeId)) throw new Error("Cannot create relationship between non-existent nodes.");
                const id = this._getNextRelId();
                const rel = { id, type, startNode: startNodeId, endNode: endNodeId, properties };
                this.relationships.set(id, rel);
                this.nodeRelationships.get(startNodeId).outgoing.add(id);
                this.nodeRelationships.get(endNodeId).incoming.add(id);
                return rel;
            }
            findNodes(label, properties) {
                let candidateIds = label ? (this.labelsToNodes.get(label) || new Set()) : new Set(this.nodes.keys());
                if (Object.keys(properties).length === 0) return Array.from(candidateIds).map(id => this.nodes.get(id));
                const results = [];
                for (const id of candidateIds) {
                    const node = this.nodes.get(id);
                    let match = true;
                    for (const key in properties) {
                        if (node.properties[key] !== properties[key]) {
                            match = false;
                            break;
                        }
                    }
                    if (match) results.push(node);
                }
                return results;
            }
            findRelationships(type, properties) {
                const results = [];
                for (const rel of this.relationships.values()) {
                    const typeMatch = !type || rel.type === type;
                    if (!typeMatch) continue;
                    let propsMatch = true;
                    for (const key in properties) {
                        if (rel.properties[key] !== properties[key]) {
                            propsMatch = false;
                            break;
                        }
                    }
                    if (propsMatch) results.push(rel);
                }
                return results;
            }
            deleteNode(nodeId) {
                const node = this.nodes.get(nodeId);
                if (!node) return false;
                const rels = this.nodeRelationships.get(nodeId);
                if (rels.incoming.size > 0 || rels.outgoing.size > 0) throw new Error("Cannot delete node with relationships. Use DETACH DELETE.");
                node.labels.forEach(label => {
                    this.labelsToNodes.get(label)?.delete(nodeId);
                     for (const prop in node.properties) {
                        const key = `${label}.${prop}`;
                        if (this.constraints.has(key)) {
                            this.constraints.get(key).delete(node.properties[prop]);
                        }
                    }
                });
                this.nodes.delete(nodeId);
                this.nodeRelationships.delete(nodeId);
                return true;
            }
            detachDeleteNode(nodeId) {
                if (!this.nodes.has(nodeId)) return false;
                const relsToDelete = new Set([...this.nodeRelationships.get(nodeId).incoming, ...this.nodeRelationships.get(nodeId).outgoing]);
                relsToDelete.forEach(relId => this.deleteRelationship(relId));
                this.deleteNode(nodeId);
                return true;
            }
            deleteRelationship(relId) {
                const rel = this.relationships.get(relId);
                if (!rel) return false;
                this.nodeRelationships.get(rel.startNode)?.outgoing.delete(relId);
                this.nodeRelationships.get(rel.endNode)?.incoming.delete(relId);
                this.relationships.delete(relId);
                return true;
            }
        }

        // --- CYPHER-LIKE PARSER & EXECUTOR ---
        class CypherExecutor {
            constructor(dbManager) {
                this.dbManager = dbManager;
                this.db = dbManager.getCurrentDb();
                this.inTransaction = false;
                this.txOperations = [];
            }
            _rowsMatchOuterBindings(row, outer) {
                if (!outer) return true;
                for (const k of Object.keys(outer)) {
                    const ov = outer[k];
                    const iv = row[k];
                    if (ov && typeof ov === 'object' && ov._type && iv && typeof iv === 'object' && iv._type) {
                        if (ov._type !== iv._type) return false;
                        if (ov._id !== iv._id) return false;
                    }
                }
                return true;
            }

            // Enhanced Cypher query preprocessing with robust comment removal
            _cleanCypherQuery(query) {
                const lines = query.split('\n');
                return lines
                    .map(line => {
                        // Remove single-line comments (// or --)
                        line = line.replace(/\/\/.*$/, '');
                        line = line.replace(/--.*$/, '');
                        
                        // Remove multi-line comments (/* */) carefully
                        let result = '';
                        let inComment = false;
                        for (let i = 0; i < line.length; i++) {
                            if (!inComment && i < line.length - 1 && line.substr(i, 2) === '/*') {
                                inComment = true;
                                i++; // skip the next character
                            } else if (inComment && i < line.length - 1 && line.substr(i, 2) === '*/') {
                                inComment = false;
                                i++; // skip the next character
                            } else if (!inComment) {
                                result += line[i];
                            }
                        }
                        return result.trim();
                    })
                    .filter(line => line)
                    .join(' ')
                    .replace(/\s+/g, ' ')
                    .trim();
            }

            _substituteParameters(query, params) {
                let result = query;
                for (const key in params) {
                    const value = params[key];
                    const paramRegex = new RegExp('\\$' + key + '\\b', 'g');
                    let replacement;
                    
                    if (typeof value === 'string') {
                        replacement = `'${value.replace(/'/g, "\\'")}'`;
                    } else if (typeof value === 'object') {
                        replacement = JSON.stringify(value);
                    } else {
                        replacement = String(value);
                    }
                    
                    result = result.replace(paramRegex, replacement);
                }
                return result;
            }

            _parseCypherPattern(pattern) {
                // Enhanced pattern parsing for complex graph structures
                const nodePattern = /\((\w+)?(?::(\w+))?\s*(?:\{([^}]*)\})?\)/g;
                const relPattern = /-\[(\w+)?(?::(\w+))?\s*(?:\{([^}]*)\})?\]->/g;
                
                const nodes = [];
                const relationships = [];
                
                let match;
                while ((match = nodePattern.exec(pattern)) !== null) {
                    nodes.push({
                        variable: match[1] || null,
                        label: match[2] || null,
                        properties: match[3] ? this._parseProperties(match[3]) : {}
                    });
                }
                
                while ((match = relPattern.exec(pattern)) !== null) {
                    relationships.push({
                        variable: match[1] || null,
                        type: match[2] || null,
                        properties: match[3] ? this._parseProperties(match[3]) : {}
                    });
                }
                
                return { nodes, relationships };
            }

            executeQuery(query, params = {}) {
                // Enhanced query preprocessing with comment support
                const cleanQuery = this._cleanCypherQuery(query);
                if (!cleanQuery) throw new Error("No valid Cypher statements found.");
                
                // Parameter substitution with enhanced support
                let processedQuery = this._substituteParameters(cleanQuery, params);
                // Support simple CALL { ... } RETURN ... subqueries
                if (/^CALL\s*\{/i.test(processedQuery)) {
                    const start = processedQuery.indexOf('{');
                    let depth = 0; let endIdx = -1;
                    for (let i = start; i < processedQuery.length; i++) {
                        const ch = processedQuery[i];
                        if (ch === '{') depth++;
                        else if (ch === '}') { depth--; if (depth === 0) { endIdx = i; break; } }
                    }
                    if (endIdx < 0) throw new Error('Malformed CALL { ... } block.');
                    const inner = processedQuery.slice(start + 1, endIdx).trim();
                    const tail = processedQuery.slice(endIdx + 1).trim();
                    const retM = tail.match(/^RETURN\s+(.+?)(?=\s+ORDER BY|\s+SKIP|\s+LIMIT|$)/i);
                    if (!retM) throw new Error('CALL { ... } must be followed by RETURN ...');
                    const retClause = retM[1];
                    const sub = this.executeQuery(inner, params);
                    const baseRows = (sub.data || sub.result || []);
                    let rows = this._applyWithOrReturn(baseRows, retClause);
                    const orderByM = tail.match(/ORDER BY\s+(.+?)(?=\s+SKIP|\s+LIMIT|$)/i);
                    const skipM = tail.match(/SKIP\s+(\d+)/i);
                    const limitM = tail.match(/LIMIT\s+(\d+)/i);
                    if (orderByM) rows = this._applyOrderBy(rows, orderByM[1]);
                    if (skipM) rows = rows.slice(parseInt(skipM[1]));
                    if (limitM) rows = rows.slice(0, parseInt(limitM[1]));
                    return { type: 'tabular', message: `Found ${rows.length} rows.`, data: rows, result: rows };
                }
                
                const upperQuery = processedQuery.toUpperCase().trim();

                // Top-level UNION / UNION ALL handling (combine tabular results)
                if (!this._inUnion && /\bUNION(\s+ALL)?\b/i.test(processedQuery)) {
                    return this._handleUnion(processedQuery, params);
                }

                if (upperQuery === 'BEGIN') {
                    this.inTransaction = true;
                    this.txOperations = [];
                    return { type: 'tx_manage', message: 'Transaction started.' };
                }
                if (upperQuery === 'COMMIT') {
                    if (!this.inTransaction) throw new Error("No active transaction to commit.");
                    this.inTransaction = false;
                    return { type: 'tx_manage', message: `Transaction committed.` };
                }
                if (upperQuery === 'ROLLBACK') {
                    if (!this.inTransaction) throw new Error("No active transaction to rollback.");
                    this.inTransaction = false;
                    return { type: 'tx_manage', message: 'Transaction rolled back. (Note: In-memory changes are not undone in this emulator).' };
                }

                if (upperQuery.startsWith('CREATE DATABASE')) {
                    const name = cleanQuery.split(' ')[2];
                    this.dbManager.createDatabase(name);
                    return { type: 'db_manage', message: `Database '${name}' created.` };
                }
                if (upperQuery.startsWith('DROP DATABASE')) {
                    const name = cleanQuery.split(' ')[2];
                    this.dbManager.dropDatabase(name);
                    return { type: 'db_manage', message: `Database '${name}' dropped.` };
                }
                if (upperQuery.startsWith('USE')) {
                    const name = cleanQuery.split(' ')[1];
                    this.dbManager.useDatabase(name);
                    return { type: 'db_manage', message: `Now using database '${name}'.` };
                }
                
                if (upperQuery.startsWith('HELP')) return this._handleHelp(cleanQuery);
                
                this.db = this.dbManager.getCurrentDb();
                if (upperQuery.startsWith('CREATE CONSTRAINT')) return this._handleCreateConstraint(cleanQuery);
                if (upperQuery.startsWith('CREATE INDEX')) return this._handleCreateIndex(cleanQuery);
                if (upperQuery.startsWith('DROP INDEX')) return this._handleDropIndex(cleanQuery);
                if (upperQuery.startsWith('DROP CONSTRAINT')) return this._handleDropConstraint(cleanQuery);
                if (upperQuery.startsWith('SHOW')) return this._handleShow(cleanQuery);
                if (upperQuery.startsWith('CALL')) return this._handleCall(cleanQuery);
                if (upperQuery.startsWith('FOREACH')) return this._handleForeach(cleanQuery);
                if (upperQuery.includes('SHORTESTPATH') || upperQuery.includes('ALLSHORTESTPATHS')) return this._handlePathFunctions(cleanQuery);
                if (upperQuery.startsWith('UNWIND')) return this._handleUnwind(cleanQuery);
                // FOREACH support: FOREACH (x IN list | <write-clauses>)
                if (/^FOREACH\s*\(/i.test(processedQuery)) {
                    const m = processedQuery.match(/^FOREACH\s*\(\s*(\w+)\s+IN\s+(.+?)\s*\|\s*(.+)\)$/i);
                    if (!m) throw new Error('Invalid FOREACH syntax.');
                    const [, varName, listExpr, body] = m;
                    let listVal;
                    try { listVal = this._evaluateExpression({}, listExpr.trim()); } catch { listVal = null; }
                    if (!Array.isArray(listVal)) throw new Error('FOREACH expects list.');
                    // Execute body per item by simple substitution of $var occurrences in values
                    for (const item of listVal) {
                        const substituted = body.replace(new RegExp(`\b${varName}\b`, 'g'), JSON.stringify(item));
                        // Allow multiple statements separated by ';'
                        const parts = substituted.split(/\s*;\s*/).filter(Boolean);
                        for (const part of parts) {
                            this.executeQuery(part);
                        }
                    }
                    return { type: 'tx_manage', message: 'FOREACH completed.' };
                }
                if (upperQuery.startsWith('MERGE')) return this._handleMerge(cleanQuery);
                // Handle write-only SET/REMOVE (no RETURN); otherwise let read handler process MATCH ... SET/REMOVE ... RETURN
                const hasReturn = /\bRETURN\b/i.test(cleanQuery);
                if (!hasReturn && /\bSET\b/i.test(upperQuery)) return this._handleSet(cleanQuery);
                if (!hasReturn && /\bREMOVE\b/i.test(upperQuery)) return this._handleRemove(cleanQuery);
                if (upperQuery.startsWith('MATCH') && upperQuery.includes('CREATE')) return this._handleCreate(cleanQuery);
                if (upperQuery.startsWith('CREATE')) return this._handleCreate(cleanQuery);
                if (/^RETURN\s+/i.test(processedQuery)) return this._handleReturnOnly(processedQuery);
                if (upperQuery.startsWith('MATCH') || upperQuery.startsWith('OPTIONAL MATCH') || upperQuery.startsWith('WITH')) return this._handleReadQuery(cleanQuery);
                
                throw new Error("Unsupported query.");
            }
            
            _parseValue(valueStr) {
                const s = String(valueStr).trim();
                // Support Cypher NULL literal
                if (/^NULL$/i.test(s)) return null;
                if (s.toLowerCase().startsWith("date('")) return new Date(s.slice(6, -2)).toISOString().split('T')[0];
                if (s.toLowerCase().startsWith("datetime('")) return new Date(s.slice(10, -2)).toISOString();
                if (s.toLowerCase().startsWith("duration(")) return s;

                try {
                    return JSON.parse(s.replace(/'/g, '"'));
                } catch(e) {
                    return s;
                }
            }
            
            _parseProperties(propString) {
                if (!propString) return {};
                const properties = {};
                const propRegex = /(\w+)\s*:\s*(date\(.*?\)|datetime\(.*?\)|duration\(.*?\)|'.*?'|\[.*?\]|[0-9.-]+|true|false)/gi;
                let match;
                while((match = propRegex.exec(propString)) !== null) {
                    properties[match[1]] = this._parseValue(match[2]);
                }
                return properties;
            }

            _parseNodePattern(pattern) {
                // Support multi-labels like (n:Label1:Label2)
                const m = pattern.match(/\((\w*)\s*(:[\w:]+)?\s*({.*?})?\)/);
                if (!m) return null;
                const [, variable, labelsPart, propString] = m;
                const labels = labelsPart ? labelsPart.split(':').filter(Boolean) : [];
                // For backward compatibility with earlier code expecting a single 'label' field
                const primaryLabel = labels.length > 0 ? labels[0] : null;
                return { variable, labels, label: primaryLabel, properties: this._parseProperties(propString) };
            }

            _parseRelPattern(pattern) {
                // Support -[]-, -[]->, <-[]-, variable length like *1..3, and type alternation :A|:B
                // Ensure typePart does not capture the '*' length spec
                const re = /(<?)-\[(\w*)?:?([^\]\s\*]*)?\s*({.*?})?(\*\d*(?:\.\.\d*)?)?\]-(>?)*/;
                const m = pattern.match(re);
                if (!m) return null;
                const [, leftArrow, variable, typePart, propString, length, rightArrow] = m;
                let minHops = 1, maxHops = 1;
                if (length) {
                    const cleaned = length.replace('*', '');
                    const hasRange = cleaned.includes('..');
                    if (hasRange) {
                        const [minStr, maxStr] = cleaned.split('..');
                        minHops = minStr ? parseInt(minStr) : 1;
                        maxHops = maxStr ? parseInt(maxStr) : Infinity;
                    } else {
                        minHops = cleaned ? parseInt(cleaned) : 1;
                        maxHops = minHops;
                    }
                    if (!isFinite(maxHops)) maxHops = Infinity;
                }
                const directed = rightArrow === '>' && leftArrow !== '<';
                const undirected = leftArrow === '<' && rightArrow === '>' ? false : (!leftArrow && !rightArrow);
                // Parse alternation of types: A|B|C
                const types = (typePart || '')
                    .split('|')
                    .map(s => s.trim())
                    .filter(Boolean);
                return { variable, types, type: types.length === 1 ? types[0] : null, properties: this._parseProperties(propString), minHops, maxHops, directed, undirected };
            }

        _handleCreate(query) {
                const createNodeMatch = query.match(/^CREATE\s+(\(.*\))$/i);
                if (createNodeMatch) {
                    const nodePattern = this._parseNodePattern(createNodeMatch[1]);
                    if (!nodePattern) throw new Error("Invalid node creation syntax.");
            const { labels = [], properties } = nodePattern;
            const node = this.db.createNode(labels, properties);
                    return { type: 'create', message: "Created 1 node.", result: [this._formatNodeForOutput(node)] };
                }
                const createRelMatch = query.match(/^MATCH\s+(.*?)\s+CREATE\s+(.*)$/i);
                if (createRelMatch) {
                    const [, matchClause, createClause] = createRelMatch;
                    const nodePatterns = matchClause.split(',').map(s => this._parseNodePattern(s.trim()));
                    const relPatternMatch = createClause.match(/\((\w+)\)-\[.*:(\w+)\s*({.*})?\]->\((\w+)\)/);
                    if (!relPatternMatch) throw new Error(`Invalid relationship CREATE pattern: ${createClause}`);
                    
                    const foundNodes = nodePatterns.map(p => {
                        // For multi-label search, intersect node sets across labels
                        let candidates;
                        if (p.labels && p.labels.length > 0) {
                            const sets = p.labels.map(lbl => new Set(this.db.labelsToNodes.get(lbl) || []));
                            const intersect = sets.reduce((a, s) => new Set([...a].filter(x => s.has(x))));
                            candidates = [...intersect].map(id => this.db.nodes.get(id));
                        } else {
                            candidates = this.db.findNodes(undefined, {});
                        }
                        const nodes = candidates.filter(n => Object.entries(p.properties||{}).every(([k,v]) => n.properties[k] === v));
                        if (nodes.length !== 1) throw new Error(`Expected 1 node for pattern ${JSON.stringify(p)}, but found ${nodes.length}.`);
                        return nodes[0];
                    });
                    
                    const [, startVar, relType, relPropsStr, endVar] = relPatternMatch;
                    const startNodePattern = nodePatterns.find(p => p.variable === startVar);
                    const endNodePattern = nodePatterns.find(p => p.variable === endVar);
                    const findOne = (p) => {
                        let candidates;
                        if (p.labels && p.labels.length > 0) {
                            const sets = p.labels.map(lbl => new Set(this.db.labelsToNodes.get(lbl) || []));
                            const intersect = sets.reduce((a, s) => new Set([...a].filter(x => s.has(x))));
                            candidates = [...intersect].map(id => this.db.nodes.get(id));
                        } else {
                            candidates = this.db.findNodes(undefined, {});
                        }
                        return candidates.find(n => Object.entries(p.properties||{}).every(([k,v]) => n.properties[k] === v));
                    };
                    const startNode = findOne(startNodePattern);
                    const endNode = findOne(endNodePattern);
                    if (!startNode || !endNode) throw new Error("Could not find start or end node for relationship.");

                    const rel = this.db.createRelationship(startNode.id, endNode.id, relType, this._parseProperties(relPropsStr));
                    return { type: 'create', message: "Created 1 relationship.", result: [this._formatRelForOutput(rel)] };
                }
                throw new Error("Unsupported CREATE syntax.");
            }

            _handleReadQuery(query) {
                const deleteMatch = query.match(/MATCH\s+(.*?)\s+(DETACH\s+DELETE|DELETE)\s+(.*)$/i);
                if (deleteMatch) return this._handleDelete(deleteMatch);
                
                // Mask predicate phrases containing 'WITH' to avoid splitting WHERE at 'STARTS WITH'/'ENDS WITH'
                const masked = query.replace(/STARTS WITH/gi, 'STARTS__WITH').replace(/ENDS WITH/gi, 'ENDS__WITH');
                // Find the top-level RETURN (outside of braces/parentheses/strings) to split header from projection
                const findTopLevelKeyword = (s, reWord) => {
                    let depthPar = 0, depthBrace = 0; let inStr = null; let prev = '';
                    for (let i = 0; i < s.length; i++) {
                        const ch = s[i];
                        if (inStr) {
                            if (ch === inStr && prev !== '\\') inStr = null;
                        } else {
                            if (ch === '"' || ch === "'") inStr = ch;
                            else if (ch === '(') depthPar++;
                            else if (ch === ')') depthPar = Math.max(0, depthPar-1);
                            else if (ch === '{') depthBrace++;
                            else if (ch === '}') depthBrace = Math.max(0, depthBrace-1);
                            // When not nested, test for keyword match at this position
                            if (depthPar === 0 && depthBrace === 0) {
                                // Require preceding boundary to be start or whitespace to avoid matching in STARTS__WITH
                                const beforeOk = (i === 0) || /\s/.test(s[i-1]);
                                if (!beforeOk) { prev = ch; continue; }
                                const tail = s.slice(i);
                                const m = tail.match(reWord);
                                if (m && m.index === 0) {
                                    // Also ensure following boundary is end or whitespace
                                    const endIdx = i + m[0].length;
                                    const afterOk = (endIdx >= s.length) || /\s/.test(s[endIdx]);
                                    if (afterOk) return i; // found at this position
                                }
                            }
                        }
                        prev = ch;
                    }
                    return -1;
                };
                const retIdx = findTopLevelKeyword(masked, /^(?:RETURN)\b/i);
                const header = retIdx >= 0 ? masked.slice(0, retIdx) : masked;
                const matchClauseMatch = header.match(/(?:MATCH|OPTIONAL MATCH)\s+(.*?(?=\s+WHERE|\s+WITH|\s+SET|\s+REMOVE|\s+RETURN|$))/i);
                // Top-level aware WHERE extraction (so RETURN inside EXISTS { } doesn't break)
                const findNextTopLevelIndex = (s, startAt, reWords) => {
                    let depthPar = 0, depthBrace = 0; let inStr = null; let prev = '';
                    for (let i = startAt; i < s.length; i++) {
                        const ch = s[i];
                        if (inStr) {
                            if (ch === inStr && prev !== '\\') inStr = null;
                        } else {
                            if (ch === '"' || ch === "'") inStr = ch;
                            else if (ch === '(') depthPar++;
                            else if (ch === ')') depthPar = Math.max(0, depthPar-1);
                            else if (ch === '{') depthBrace++;
                            else if (ch === '}') depthBrace = Math.max(0, depthBrace-1);
                            if (depthPar === 0 && depthBrace === 0) {
                                // Require proper token boundary before/after the keyword
                                const beforeOk = (i === 0) || /\s/.test(s[i-1]);
                                if (!beforeOk) { prev = ch; continue; }
                                const tail = s.slice(i);
                                for (const re of reWords) {
                                    const m = tail.match(re);
                                    if (m && m.index === 0) {
                                        const endIdx = i + m[0].length;
                                        const afterOk = (endIdx >= s.length) || /\s/.test(s[endIdx]);
                                        if (afterOk) return i;
                                    }
                                }
                            }
                        }
                        prev = ch;
                    }
                    return -1;
                };
                let whereClauseText = null;
                const whereIdx = findTopLevelKeyword(header, /^(?:WHERE)\b/i);
                if (whereIdx >= 0) {
                    const endIdx = findNextTopLevelIndex(header, whereIdx + 'WHERE'.length, [/^(?:WITH)\b/i]);
                    whereClauseText = (endIdx >= 0 ? header.slice(whereIdx + 'WHERE'.length, endIdx) : header.slice(whereIdx + 'WHERE'.length)).trim();
                }
                const withClauseMatch = header.match(/\bWITH\b\s+(.*?(?=\s+RETURN|$))/i);
                // Extract optional SET/REMOVE clauses before RETURN
                const setClauseMatch = header.match(/\bSET\b\s+(.+?)(?=\s+REMOVE\b|\s+WITH\b|\s+RETURN\b|$)/i);
                const removeClauseMatch = header.match(/\bREMOVE\b\s+(.+?)(?=\s+SET\b|\s+WITH\b|\s+RETURN\b|$)/i);
                const returnClauseMatch = query.match(/RETURN\s+(.*?(?=\s+ORDER BY|\s+SKIP|\s+LIMIT|$))/i);
                const orderByClauseMatch = query.match(/ORDER BY\s+(.*?(?=\s+SKIP|\s+LIMIT|$))/i);
                const skipClauseMatch = query.match(/SKIP\s+(\d+)/i);
                const limitClauseMatch = query.match(/LIMIT\s+(\d+)/i);
                const isOptional = /^\s*OPTIONAL\s+MATCH/i.test(query);

                if (!returnClauseMatch) throw new Error("Read query must contain RETURN clause.");

                // Unmask extracted clauses
                const matchClauseText = matchClauseMatch ? matchClauseMatch[1].replace(/STARTS__WITH/gi, 'STARTS WITH').replace(/ENDS__WITH/gi, 'ENDS WITH') : null;
                whereClauseText = whereClauseText ? whereClauseText.replace(/STARTS__WITH/gi, 'STARTS WITH').replace(/ENDS__WITH/gi, 'ENDS WITH') : null;
                const withClauseText = withClauseMatch ? withClauseMatch[1].replace(/STARTS__WITH/gi, 'STARTS WITH').replace(/ENDS__WITH/gi, 'ENDS WITH') : null;

                let results = matchClauseText ? this._performMatch(matchClauseText) : [{}];
                
                if (whereClauseText) results = this._applyWhere(results, whereClauseText);
                // Apply SET/REMOVE mutations on matched rows prior to projection
                if (setClauseMatch && setClauseMatch[1]) this._applySetToRows(results, setClauseMatch[1].trim());
                if (removeClauseMatch && removeClauseMatch[1]) this._applyRemoveToRows(results, removeClauseMatch[1].trim());
                // OPTIONAL MATCH semantics: if no rows after matching/WHERE, produce a single null row to allow RETURN to project NULLs
                if (isOptional && (!results || results.length === 0)) results = [{}];
                if (withClauseText) results = this._applyWithOrReturn(results, withClauseText);
                results = this._applyWithOrReturn(results, returnClauseMatch[1]);
                if (orderByClauseMatch) results = this._applyOrderBy(results, orderByClauseMatch[1]);
                if (skipClauseMatch) results = results.slice(parseInt(skipClauseMatch[1]));
                if (limitClauseMatch) results = results.slice(0, parseInt(limitClauseMatch[1]));

                // Determine result flavor: if rows are objects whose values are primitives or arrays (no _type node/relationship wrappers) treat as tabular
                const isGraphRow = (row) => Object.values(row).some(v => v && typeof v === 'object' && (
                    v._type === 'node' || v._type === 'relationship' ||
                    (Array.isArray(v) && v.some(iv => iv && typeof iv === 'object' && iv._type))
                ));
                const hasAggregationOrDistinct = /RETURN\s+DISTINCT/i.test(query) || /\b(COUNT|SUM|AVG|MIN|MAX|COLLECT|STDEV|STDEVP|PERCENTILECONT|PERCENTILEDISC|SIZE)\s*\(/i.test(query);
                const isReturnStar = !!(returnClauseMatch && returnClauseMatch[1].trim() === '*');
                const containsListComp = /RETURN\s+.*\[\w+\s+IN\s+.+\|.+\]/i.test(query);
                const treatAsTabular = isReturnStar || hasAggregationOrDistinct || containsListComp || (results.length>0 && !results.some(r => isGraphRow(r)));
                if (treatAsTabular) {
                    // Return both data and result arrays for compatibility with tests accessing either
                    return { type: 'tabular', message: `Found ${results.length} rows.`, data: results, result: results };
                } else {
                    return { type: 'graph', message: `Found ${results.length} results.`, result: results, data: results };
                }
            }

            _performMatch(matchClause) {
                let pattern = matchClause.replace(/^(OPTIONAL )?MATCH\s*/i, '').trim();
                let pathVar = null;
                if (pattern.match(/^\w+\s*=/)) {
                    [pathVar, pattern] = pattern.split('=').map(s => s.trim());
                }

                if (!pattern.includes('-')) {
                    // Support multi-pattern node joins separated by commas: (a:Label),(b:Label)
                    const splitTopLevelCommas = (str) => {
                        const parts = []; let buf=''; let depth=0; let inStr=null; let prev='';
                        for (let i=0;i<str.length;i++) {
                            const ch=str[i];
                            if (inStr) { buf+=ch; if (ch===inStr && prev !== '\\') inStr=null; }
                            else if (ch==='"' || ch==="'") { inStr=ch; buf+=ch; }
                            else if (ch==='('||ch==='['||ch==='{') { depth++; buf+=ch; }
                            else if (ch===')'||ch===']'||ch==='}') { depth=Math.max(0,depth-1); buf+=ch; }
                            else if (ch===',' && depth===0) { parts.push(buf.trim()); buf=''; }
                            else buf+=ch;
                            prev=ch;
                        }
                        if (buf.trim().length) parts.push(buf.trim());
                        return parts.filter(Boolean);
                    };
                    const nodeParts = splitTopLevelCommas(pattern);
                    if (nodeParts.length > 1) {
                        const nodePatterns = nodeParts.map(p => this._parseNodePattern(p));
                        const candidatesPer = nodePatterns.map(p => {
                            let nodes;
                            if (p.labels && p.labels.length > 0) {
                                const sets = p.labels.map(lbl => new Set(this.db.labelsToNodes.get(lbl) || []));
                                const intersect = sets.reduce((a, s) => new Set([...a].filter(x => s.has(x))), new Set(this.db.nodes.keys()));
                                nodes = [...intersect].map(id => this.db.nodes.get(id));
                            } else {
                                nodes = this.db.findNodes(undefined, {});
                            }
                            return nodes.filter(n => Object.entries(p.properties||{}).every(([k,v]) => n.properties[k] === v));
                        });
                        // Cartesian product join
                        const results = [];
                        const backtrack = (idx, acc) => {
                            if (idx === nodePatterns.length) { results.push({ ...acc }); return; }
                            const p = nodePatterns[idx];
                            const list = candidatesPer[idx];
                            for (const n of list) {
                                const varName = p.variable;
                                const rowAdd = varName ? { [varName]: this._formatNodeForOutput(n) } : {};
                                backtrack(idx+1, { ...acc, ...rowAdd });
                            }
                        };
                        backtrack(0, {});
                        return results;
                    }

                    const nodePattern = this._parseNodePattern(pattern);
                    // Multi-label filtering
                    let nodes;
                    if (nodePattern.labels && nodePattern.labels.length > 0) {
                        const sets = nodePattern.labels.map(lbl => new Set(this.db.labelsToNodes.get(lbl) || []));
                        const intersect = sets.reduce((a, s) => new Set([...a].filter(x => s.has(x))), new Set(this.db.nodes.keys()));
                        nodes = [...intersect].map(id => this.db.nodes.get(id));
                    } else {
                        nodes = this.db.findNodes(undefined, {});
                    }
                    nodes = nodes.filter(n => Object.entries(nodePattern.properties||{}).every(([k,v]) => n.properties[k] === v));
                    return nodes.map(n => ({ [nodePattern.variable]: this._formatNodeForOutput(n) }));
                }

                // Multi-hop chain detection
                const relSegmentCount = (pattern.match(/-\[/g) || []).length;
                if (relSegmentCount > 1) {
                    // Naive chain parser: split nodes and rels sequentially
                    const nodeTokens = pattern.split(/-\[[^\]]*\]->/); // directed only for simplicity
                    const relTokens = pattern.match(/-\[[^\]]*\]->/g) || [];
                    if (nodeTokens.length === relTokens.length + 1) {
                        const nodePatterns = nodeTokens.map(nt => this._parseNodePattern(nt.trim()));
                        // Build all possible chains by expanding candidates progressively
                        let partial = nodePatterns[0] ? (this.db.findNodes(undefined, {})
                            .filter(n => (!nodePatterns[0].labels.length || nodePatterns[0].labels.some(l=>n.labels.has(l))) && Object.entries(nodePatterns[0].properties||{}).every(([k,v])=>n.properties[k]===v))
                            .map(n => [{ node: n }])) : [];
                        for (let i=0;i<relTokens.length;i++) {
                            const relPat = this._parseRelPattern(relTokens[i]);
                            const nextNodePat = nodePatterns[i+1];
                            const newPartial = [];
                            partial.forEach(chain => {
                                const lastNode = chain[chain.length-1].node;
                                for (const rel of this.db.relationships.values()) {
                                    if (rel.startNode !== lastNode.id) continue; // only forward for now
                                    if (relPat.type && rel.type !== relPat.type) continue;
                                    const target = this.db.nodes.get(rel.endNode);
                                    if (!target) continue;
                                    const labelOk = !nextNodePat.labels.length || nextNodePat.labels.some(l=>target.labels.has(l));
                                    const propOk = Object.entries(nextNodePat.properties||{}).every(([k,v])=>target.properties[k]===v);
                                    if (labelOk && propOk) {
                                        newPartial.push([...chain, { rel, node: target }]);
                                    }
                                }
                            });
                            partial = newPartial;
                        }
                        return partial.map(chain => {
                            const row = {};
                            // Expose only start/end variable nodes if variables provided
                            // Use pathVar to include path object
                            if (pathVar) {
                                row[pathVar] = {
                                    start: this._formatNodeForOutput(chain[0].node),
                                    end: this._formatNodeForOutput(chain[chain.length-1].node),
                                    segments: chain.slice(1).map((e,idx) => ({
                                        start: this._formatNodeForOutput(chain[idx].node),
                                        relationship: this._formatRelForOutput(e.rel),
                                        end: this._formatNodeForOutput(e.node)
                                    }))
                                };
                            }
                            // Provide each node variable if specified (a,b,c) accordingly
                            // Extract variables from original pattern by position
                            const varMatches = pattern.match(/\((\w*)/g) || [];
                            varMatches.forEach((vm,i) => {
                                const vName = vm.slice(1).trim();
                                if (vName) row[vName] = this._formatNodeForOutput(chain[i].node);
                            });
                            return row;
                        });
                    }
                }

                const [startNodePatternStr, relPatternStr, endNodePatternStrRaw] = pattern.split(/(-.+?-)/);
                const startNodePattern = this._parseNodePattern(startNodePatternStr);
                const relPattern = this._parseRelPattern(relPatternStr);
                const isDirected = /-\[.*?\]->/.test(pattern);
                const endNodePatternStr = endNodePatternStrRaw.replace('>', '').trim();
                const endNodePattern = this._parseNodePattern(endNodePatternStr);

                // Build start node set with multi-label support
                let startNodes;
                if (startNodePattern.labels && startNodePattern.labels.length > 0) {
                    const sets = startNodePattern.labels.map(lbl => new Set(this.db.labelsToNodes.get(lbl) || []));
                    const intersect = sets.reduce((a, s) => new Set([...a].filter(x => s.has(x))), new Set(this.db.nodes.keys()));
                    startNodes = [...intersect].map(id => this.db.nodes.get(id));
                } else {
                    startNodes = this.db.findNodes(undefined, {});
                }
                startNodes = startNodes.filter(n => Object.entries(startNodePattern.properties||{}).every(([k,v]) => n.properties[k] === v));
                const finalResults = [];

                startNodes.forEach(startNode => {
                    const queue = [[startNode, []]]; 
                    const visitedPaths = new Set();

                    while (queue.length > 0) {
                        const [currentNode, currentPath] = queue.shift();
                        const currentDepth = currentPath.length;

                        if (currentDepth >= relPattern.maxHops) continue;

                        // Zero-hop or general acceptance at current node when depth >= minHops
                        if (currentDepth >= (relPattern?.minHops ?? 1)) {
                            const requiredLabels = endNodePattern.labels || [];
                            const endLabelMatch = requiredLabels.length === 0 || requiredLabels.some(l => currentNode.labels.has(l));
                            const endPropsMatch = Object.entries(endNodePattern.properties || {}).every(([k,v]) => currentNode.properties[k] === v);
                            if (endLabelMatch && endPropsMatch) {
                                const resultRow = {
                                    [startNodePattern.variable]: this._formatNodeForOutput(startNode),
                                    [endNodePattern.variable]: this._formatNodeForOutput(currentNode)
                                };
                                if (pathVar) {
                                    resultRow[pathVar] = {
                                        start: this._formatNodeForOutput(startNode),
                                        end: this._formatNodeForOutput(currentNode),
                                        segments: currentPath.map((r, i) => ({
                                            start: this._formatNodeForOutput(i === 0 ? startNode : this.db.nodes.get(currentPath[i-1].endNode)),
                                            relationship: this._formatRelForOutput(r),
                                            end: this._formatNodeForOutput(this.db.nodes.get(r.endNode))
                                        }))
                                    };
                                }
                                finalResults.push(resultRow);
                            }
                        }

                        // Consider direction, relationship type, and relationship properties
                        const considerRel = (rel, fromNodeId) => {
                            if (relPattern && relPattern.types && relPattern.types.length > 0) {
                                if (!relPattern.types.includes(rel.type)) return false;
                            }
                            if (relPattern && relPattern.properties) {
                                for (const [k,v] of Object.entries(relPattern.properties)) {
                                    if (rel.properties[k] !== v) return false;
                                }
                            }
                            if (!isDirected) return rel.startNode === fromNodeId || rel.endNode === fromNodeId;
                            return rel.startNode === fromNodeId; // only outgoing if directed
                        };

                        for (const rel of this.db.relationships.values()) {
                            if (!considerRel(rel, currentNode.id)) continue;
                            const neighborId = rel.startNode === currentNode.id ? rel.endNode : rel.startNode;
                            const neighborNode = this.db.nodes.get(neighborId);
                            
                            const pathString = [...currentPath, rel].map(r => r.id).join('-');
                            if (visitedPaths.has(pathString)) continue;
                            visitedPaths.add(pathString);

                            const newPath = [...currentPath, rel];
                            const newDepth = newPath.length;

                            if (newDepth >= (relPattern?.minHops ?? 1)) {
                                const requiredLabels = endNodePattern.labels || [];
                                const endLabelMatch = requiredLabels.length === 0 || requiredLabels.some(l => neighborNode.labels.has(l));
                                const endPropsMatch = Object.entries(endNodePattern.properties || {}).every(([k,v]) => neighborNode.properties[k] === v);
                                if (endLabelMatch && endPropsMatch) {
                                    const resultRow = {
                                        [startNodePattern.variable]: this._formatNodeForOutput(startNode),
                                        [endNodePattern.variable]: this._formatNodeForOutput(neighborNode)
                                    };
                                    // Include relationship variable if provided for single-hop patterns
                                    if (relPattern && relPattern.variable && newPath.length > 0 && (relPattern.maxHops||1) === 1) {
                                        const lastRel = newPath[newPath.length - 1];
                                        resultRow[relPattern.variable] = this._formatRelForOutput(lastRel);
                                    }
                                    if (pathVar) {
                                        resultRow[pathVar] = {
                                            start: this._formatNodeForOutput(startNode),
                                            end: this._formatNodeForOutput(neighborNode),
                                            segments: newPath.map((r, i) => ({
                                                start: this._formatNodeForOutput(i === 0 ? startNode : this.db.nodes.get(newPath[i-1].endNode)),
                                                relationship: this._formatRelForOutput(r),
                                                end: this._formatNodeForOutput(this.db.nodes.get(r.endNode))
                                            }))
                                        };
                                    }
                                    finalResults.push(resultRow);
                                }
                            }
                            queue.push([neighborNode, newPath]);
                        }
                    }
                });
                return finalResults;
            }

            _applyWhere(results, whereClause) {
                const getPropVal = (row, v, prop) => {
                    const ent = row[v];
                    if (!ent) return undefined;
                    if (ent && typeof ent === 'object') {
                        if (ent.properties && Object.prototype.hasOwnProperty.call(ent.properties, prop)) return ent.properties[prop];
                        if (Object.prototype.hasOwnProperty.call(ent, prop)) return ent[prop];
                    }
                    return undefined;
                };

                const evaluatePredicate = (row, predicate) => {
                    let negate = false;
                    let p = predicate.trim();
                    if (/^NOT\s+/i.test(p)) { negate = true; p = p.replace(/^NOT\s+/i,'').trim(); }

                    // Strip wrapping parentheses if they enclose the whole expression
                    const isWrappedByParens = (s) => {
                        if (!(s.startsWith('(') && s.endsWith(')'))) return false;
                        let depth = 0; let inStr = null; let prev = '';
                        for (let i=0;i<s.length;i++) {
                            const ch = s[i];
                            if (inStr) { if (ch===inStr && prev !== '\\') inStr = null; }
                            else {
                                if (ch==='\"' || ch==='\'') inStr = ch;
                                else if (ch==='(') depth++;
                                else if (ch===')') {
                                    depth--; if (depth===0 && i < s.length-1) return false;
                                }
                            }
                            prev = ch;
                        }
                        return depth===0;
                    };
                    while (p.length>0 && isWrappedByParens(p)) { p = p.slice(1,-1).trim(); }

                    // Nested boolean splitting with precedence: OR groups, then AND within each group
                    const splitTopLevelBy = (s, word) => {
                        const parts = []; let buf=''; let depth=0; let inStr=null; let prev='';
                        const upperWord = word.toUpperCase();
                        for (let i=0;i<s.length;i++) {
                            const ch=s[i];
                            if (inStr) { buf+=ch; if (ch===inStr && prev!=='\\') inStr=null; }
                            else {
                                if (ch==='\"' || ch==='\'') { inStr=ch; buf+=ch; }
                                else if (ch==='(') { depth++; buf+=ch; }
                                else if (ch===')') { depth=Math.max(0,depth-1); buf+=ch; }
                                else {
                                    if (depth===0) {
                                        // Check token boundary match for word
                                        if (/\s/.test(ch)) { buf+=ch; }
                                        else {
                                            // Try to match at this index
                                            const tail = s.slice(i).toUpperCase();
                                            if (tail.startsWith(' '+upperWord+' ') || tail.startsWith(' '+upperWord+'\t') || tail===upperWord || tail.startsWith(upperWord+' ')) {
                                                // push part before the word
                                                if (buf.trim().length) parts.push(buf.trim());
                                                // advance i to end of word
                                                const adv = upperWord.length - 1; i += adv; buf='';
                                            } else { buf+=ch; }
                                        }
                                    } else { buf+=ch; }
                                }
                            }
                            prev=ch;
                        }
                        if (buf.trim().length) parts.push(buf.trim());
                        return parts;
                    };
                    // Try OR-split at top-level
                    const orParts = (() => {
                        // Use regex-based split that respects parens by scanning string
                        const parts = []; let buf=''; let depth=0; let inStr=null; let prev='';
                        for (let i=0;i<p.length;i++) {
                            const ch=p[i];
                            if (inStr) { buf+=ch; if (ch===inStr && prev!=='\\') inStr=null; }
                            else {
                                if (ch==='\"' || ch==='\'') { inStr=ch; buf+=ch; }
                                else if (ch==='(') { depth++; buf+=ch; }
                                else if (ch===')') { depth=Math.max(0,depth-1); buf+=ch; }
                                else {
                                    if (depth===0 && /\s/i.test(ch)) {
                                        // lookahead for OR
                                        const rest = p.slice(i).toUpperCase();
                                        if (rest.startsWith(' OR ')) {
                                            if (buf.trim().length) parts.push(buf.trim());
                                            i += 3; // skip OR and following space (the loop will add 1)
                                            buf='';
                                            continue;
                                        }
                                    }
                                    buf+=ch;
                                }
                            }
                            prev=ch;
                        }
                        if (buf.trim().length) parts.push(buf.trim());
                        return parts;
                    })();
                    if (orParts.length > 1) {
                        const res = orParts.some(part => evaluatePredicate(row, part));
                        return negate ? !res : res;
                    }
                    // AND-split at top-level
                    const andParts = (() => {
                        const parts = []; let buf=''; let depth=0; let inStr=null; let prev='';
                        for (let i=0;i<p.length;i++) {
                            const ch=p[i];
                            if (inStr) { buf+=ch; if (ch===inStr && prev!=='\\') inStr=null; }
                            else {
                                if (ch==='\"' || ch==='\'') { inStr=ch; buf+=ch; }
                                else if (ch==='(') { depth++; buf+=ch; }
                                else if (ch===')') { depth=Math.max(0,depth-1); buf+=ch; }
                                else {
                                    if (depth===0 && /\s/i.test(ch)) {
                                        const rest = p.slice(i).toUpperCase();
                                        if (rest.startsWith(' AND ')) {
                                            if (buf.trim().length) parts.push(buf.trim());
                                            i += 4;
                                            buf='';
                                            continue;
                                        }
                                    }
                                    buf+=ch;
                                }
                            }
                            prev=ch;
                        }
                        if (buf.trim().length) parts.push(buf.trim());
                        return parts;
                    })();
                    if (andParts.length > 1) {
                        const res = andParts.every(part => evaluatePredicate(row, part));
                        return negate ? !res : res;
                    }

                    // List predicates: ANY/ALL/NONE/SINGLE (x IN list WHERE cond)
                    let lm = p.match(/^(ANY|ALL|NONE|SINGLE)\s*\(\s*(\w+)\s+IN\s+(.+?)\s+WHERE\s+(.+?)\s*\)$/i);
                    if (lm) {
                        const [, kind, v, listExpr, cond] = lm;
                        const listVal = this._evaluateExpression(row, listExpr.trim());
                        const arr = Array.isArray(listVal) ? listVal : [];
                        let count = 0;
                        for (const item of arr) {
                            const scoped = { ...row, [v]: item };
                            if (this._evaluateCondition(scoped, cond.trim())) count++;
                        }
                        let res = false;
                        switch (kind.toUpperCase()) {
                            case 'ANY': res = count > 0; break;
                            case 'ALL': res = arr.length === 0 ? true : count === arr.length; break;
                            case 'NONE': res = count === 0; break;
                            case 'SINGLE': res = count === 1; break;
                        }
                        return negate ? !res : res;
                    }

                    // Simple fast-path for string predicates to avoid regex mis-captures
                    const simpleStr = p.match(/^(\w+)\.(\w+)\s+(STARTS WITH|ENDS WITH|CONTAINS)\s+'([^']+)'$/i);
                    if (simpleStr) {
                        const [, v, prop, op, lit] = simpleStr;
                        const rawVal = getPropVal(row, v, prop);
                        const rowVal = String(rawVal ?? '');
                        let res = false;
                        if (/STARTS WITH/i.test(op)) res = rowVal.startsWith(lit);
                        else if (/ENDS WITH/i.test(op)) res = rowVal.endsWith(lit);
                        else res = rowVal.includes(lit);
                        return negate ? !res : res;
                    }

                    // EXISTS { subquery } - correlated subquery predicate
                    let sm = p.match(/^EXISTS\s*\{\s*(.+)\s*\}$/i);
                    if (sm) {
                        const inner = sm[1];
                        // Broad fallback: detect (sv)-[:TYPE]->(:EndLabel) and check existence using outer bound sv
                        try {
                            const sVarM = inner.match(/\(\s*(\w+)\s*\)/);
                            const rTypeM = inner.match(/\[\s*(?:\w+)?\s*:?\s*([A-Za-z_][A-Za-z0-9_]*)/);
                            const endLblM = inner.match(/->\s*\(\s*\w*\s*:(\w+)/);
                            if (sVarM && rTypeM) {
                                const sv = sVarM[1];
                                const rType = rTypeM[1];
                                const endLabel = endLblM ? endLblM[1] : null;
                                const startEnt = row[sv];
                                if (startEnt && startEnt._type === 'node') {
                                    const startId = startEnt._id;
                                    let found = false;
                                    const out = this.db.nodeRelationships.get(startId)?.outgoing || new Set();
                                    for (const relId of out) {
                                        const rel = this.db.relationships.get(relId);
                                        if (!rel) continue;
                                        if (rel.type !== rType) continue;
                                        if (endLabel) {
                                            const tgt = this.db.nodes.get(rel.endNode);
                                            if (!tgt || !tgt.labels.has(endLabel)) continue;
                                        }
                                        found = true; break;
                                    }
                                    return negate ? !found : found;
                                }
                            }
                            const pm = inner.match(/\(\s*(\w+)\s*\).*?-\s*\[[^\]]*?:?\s*([A-Za-z_][A-Za-z0-9_]*)?\s*[^\]]*?\]\s*->\s*\(\s*\w*\s*:?\s*([A-Za-z_][A-Za-z0-9_]*)?\s*[^)]*\)/i);
                            if (pm) {
                                const [, sv, rTypeOpt, endLabelOpt] = pm;
                                const startEnt = row[sv];
                                if (startEnt && startEnt._type === 'node') {
                                    const startId = startEnt._id;
                                    let found = false;
                                    const out = this.db.nodeRelationships.get(startId)?.outgoing || new Set();
                                    for (const relId of out) {
                                        const rel = this.db.relationships.get(relId);
                                        if (!rel) continue;
                                        if (rTypeOpt && rel.type !== rTypeOpt) continue;
                                        if (endLabelOpt) {
                                            const tgt = this.db.nodes.get(rel.endNode);
                                            if (!tgt || !tgt.labels.has(endLabelOpt)) continue;
                                        }
                                        found = true; break;
                                    }
                                    return negate ? !found : found;
                                }
                            }
                        } catch(_) {}
                        // Support forms: MATCH ... WHERE ... RETURN ...  OR  MATCH ... RETURN ...
                        // We'll extract RETURN clause to know projection variables, but we only need to know if any rows exist.
                        try {
                            // Build a tiny query runner using current row-bound variables via simple substitution for var.props in patterns
                            // Approach: Only support a single MATCH ... RETURN ... inside EXISTS for now.
                            const m1 = inner.match(/MATCH\s+(.+?)(?:\s+WHERE\s+(.+?))?\s+RETURN\s+(.+)$/i);
                            if (m1) {
                                const [, mClause, wClause] = m1;
                                // Fast-path for common pattern: (a)-[:TYPE]->(b:Label)
                                const simple = mClause.match(/^\(\s*(\w+)\s*\)\s*-\s*\[(?:\w+)?\s*:?([A-Za-z_][A-Za-z0-9_]*)\s*\]\s*->\s*\(\s*(\w+)\s*:?([A-Za-z_][A-Za-z0-9_]*)?\s*\)$/i);
                                if (simple && !wClause) {
                                    const [, sv, relType, ev, endLabel] = simple;
                                    const startEnt = row[sv];
                                    if (startEnt && startEnt._type === 'node') {
                                        const startId = startEnt._id;
                                        let found = false;
                                        const out = this.db.nodeRelationships.get(startId)?.outgoing || new Set();
                                        for (const relId of out) {
                                            const rel = this.db.relationships.get(relId);
                                            if (!rel) continue;
                                            if (rel.type !== relType) continue;
                                            const tgt = this.db.nodes.get(rel.endNode);
                                            if (endLabel && !(tgt && tgt.labels.has(endLabel))) continue;
                                            found = true; break;
                                        }
                                        return negate ? !found : found;
                                    }
                                }
                                let subRows = this._performMatch(mClause.trim());
                                // Correlate with outer row variables (node/rel identity)
                                subRows = subRows.filter(sr => this._rowsMatchOuterBindings(sr, row));
                                if (wClause) {
                                    const withScope = subRows.map(r=>({ ...row, ...r }));
                                    const filtered = this._applyWhere(withScope, wClause.trim());
                                    subRows = filtered;
                                }
                                const res = Array.isArray(subRows) && subRows.length > 0;
                                return negate ? !res : res;
                            } else {
                                // Fallback: execute as-is using executor; if any rows -> true
                                const r = this.executeQuery(inner, {});
                                const rows = r.data || r.result || [];
                                const res = (rows.length > 0);
                                return negate ? !res : res;
                            }
                        } catch(_) {
                            return negate ? !false : false;
                        }
                    }

                    // EXISTS(var.prop)
                    let m = p.match(/^EXISTS\((\w+)\.(\w+)\)$/i);
                    if (m) {
                        const [, v, prop] = m;
                        const exists = row[v] && row[v].properties && Object.prototype.hasOwnProperty.call(row[v].properties, prop);
                        return negate ? !exists : exists;
                    }

                    // var.prop IS NULL / IS NOT NULL
                    m = p.match(/^(\w+)\.(\w+)\s+IS\s+(NOT\s+)?NULL$/i);
                    if (m) {
                        const [, v, prop, notPart] = m;
                        const isNull = row[v]?.properties?.[prop] === undefined || row[v]?.properties?.[prop] === null;
                        const result = notPart ? !isNull : isNull;
                        return negate ? !result : result;
                    }

                    // STARTS WITH / ENDS WITH / CONTAINS
                    m = p.match(/^(\w+)\.(\w+)\s+(STARTS WITH|ENDS WITH|CONTAINS)\s+([^\s].*?)$/i);
                    if (m) {
                        const [, v, prop, op, valRaw] = m;
                        // Trim possible trailing logical connectors remnants
                        let cleaned = valRaw.replace(/\s+(AND|OR)\s+.*$/i,'').trim();
                        // Remove surrounding quotes if present
                        if ((cleaned.startsWith("'") && cleaned.endsWith("'")) || (cleaned.startsWith('"') && cleaned.endsWith('"'))) {
                            cleaned = cleaned.slice(1,-1);
                        }
                        const val = cleaned;
                        const rawVal = getPropVal(row, v, prop);
                        const rowVal = String(rawVal ?? '');
                        let res = false;
                        if (/STARTS WITH/i.test(op)) res = rowVal.startsWith(val);
                        else if (/ENDS WITH/i.test(op)) res = rowVal.endsWith(val);
                        else res = rowVal.includes(val);
                        return negate ? !res : res;
                    }

                    // Fallback for string predicates with uncommon spacing/quoting
                    if (/\b(STARTS WITH|ENDS WITH|CONTAINS)\b/i.test(p)) {
                        const op = (p.match(/\b(STARTS WITH|ENDS WITH|CONTAINS)\b/i) || [])[1];
                        const [lhs, rhsRaw] = p.split(new RegExp(op, 'i'));
                        const lhsMatch = lhs.trim().match(/^(\w+)\.(\w+)$/);
                        if (lhsMatch) {
                            const [, v, prop] = lhsMatch;
                            let rhs = rhsRaw.trim();
                            // Remove trailing logical noise
                            rhs = rhs.replace(/\s+(AND|OR)\s+.*$/i,'').trim();
                            if ((rhs.startsWith("'") && rhs.endsWith("'")) || (rhs.startsWith('"') && rhs.endsWith('"'))) rhs = rhs.slice(1,-1);
                            const rawVal = getPropVal(row, v, prop);
                            const rowVal = String(rawVal ?? '');
                            let res = false;
                            if (/STARTS WITH/i.test(op)) res = rowVal.startsWith(rhs);
                            else if (/ENDS WITH/i.test(op)) res = rowVal.endsWith(rhs);
                            else res = rowVal.includes(rhs);
                            return negate ? !res : res;
                        }
                    }

                    // IN operator
                    m = p.match(/^(\w+\.\w+|'.*?'|".*?"|\d+|\w+)\s+IN\s+(\[.*?\]|\w+\.\w+)/i);
                    if (m) {
                        const [, left, rightRaw] = m;
                        let rightValues;
                        if (/^\[.*\]$/.test(rightRaw.trim())) {
                            try { rightValues = this._parseValue(rightRaw.trim()); } catch { rightValues = []; }
                        } else if (/^\w+\.\w+$/.test(rightRaw.trim())) {
                            const [rv, rp] = rightRaw.trim().split('.');
                            rightValues = row[rv]?.properties?.[rp];
                        }
                        if (!Array.isArray(rightValues)) rightValues = [];
                        const leftVal = /^\w+\.\w+$/.test(left) ? (() => { const [lv, lp] = left.split('.'); return row[lv]?.properties?.[lp]; })() : this._parseValue(left);
                        const res = rightValues.some(x => x === leftVal);
                        return negate ? !res : res;
                    }

                    // Regex operator =~ with optional (?i) flag should be checked before generic '=' comparisons
                    m = p.match(/^(\w+)\.(\w+)\s*=~\s*('.*?'|".*?")$/i);
                    if (m) {
                        const [, v, prop, patQ] = m;
                        let pattern = patQ.slice(1,-1);
                        let flags = '';
                        if (pattern.startsWith('(?i)')) { flags = 'i'; pattern = pattern.slice(4); }
                        const re = new RegExp(pattern, flags);
                        const s = String(row[v]?.properties?.[prop] ?? '');
                        const res = re.test(s);
                        return negate ? !res : res;
                    }
                    // Comparison operators including <>
                    m = p.match(/^(\w+)\.(\w+)\s*(=|!=|<>|>=|<=|>|<)\s*(.+)$/i);
                    if (m) {
                        // Guard for '=~' already handled
                        if (/=~/.test(p)) { /* skip, handled above */ }
                        else {
                            const [, v, prop, op, valRaw] = m;
                            const rowVal = row[v]?.properties?.[prop];
                            const cmpVal = this._parseValue(valRaw);
                            let res = false;
                            switch (op) {
                                case '=': res = rowVal == cmpVal; break;
                                case '!=': case '<>': res = rowVal != cmpVal; break;
                                case '>': res = rowVal > cmpVal; break;
                                case '<': res = rowVal < cmpVal; break;
                                case '>=': res = rowVal >= cmpVal; break;
                                case '<=': res = rowVal <= cmpVal; break;
                            }
                            return negate ? !res : res;
                        }
                    }
                    // Regex operator =~ with optional (?i) case-insensitive flag
                    m = p.match(/^(\w+)\.(\w+)\s*=~\s*('.*?'|".*?")$/i);
                    if (m) {
                        const [, v, prop, patQ] = m;
                        let pattern = patQ.slice(1,-1);
                        let flags = '';
                        if (pattern.startsWith('(?i)')) { flags = 'i'; pattern = pattern.slice(4); }
                        const re = new RegExp(pattern, flags);
                        const s = String(row[v]?.properties?.[prop] ?? '');
                        const res = re.test(s);
                        return negate ? !res : res;
                    }
                    return false;
                };

                // Evaluate whole WHERE clause with parentheses and precedence handled inside evaluatePredicate
                return results.filter(row => evaluatePredicate(row, whereClause));
            }
            _applyWithOrReturn(results, clause) {
                let distinct = false;
                let working = clause.trim();
                if (/^DISTINCT\s+/i.test(working)) { distinct = true; working = working.replace(/^DISTINCT\s+/i,''); }
                if (working === '*') {
                    let out = results;
                    if (distinct) {
                        const seen = new Set();
                        out = results.filter(r => { const k = JSON.stringify(r); if (seen.has(k)) return false; seen.add(k); return true; });
                    }
                    return out;
                }
                const splitCommaTopLevel = (str) => {
                    const parts = []; let buf = '';
                    let depth = 0; let inStr = null; let prev = '';
                    for (let i=0;i<str.length;i++) {
                        const ch = str[i];
                        if (inStr) {
                            buf += ch;
                            if (ch === inStr && prev !== '\\') inStr = null;
                        } else {
                            if (ch === '"' || ch === "'") { inStr = ch; buf += ch; }
                            else if (ch === '(' || ch === '[' || ch === '{') { depth++; buf += ch; }
                            else if (ch === ')' || ch === ']' || ch === '}') { depth = Math.max(0, depth-1); buf += ch; }
                            else if (ch === ',' && depth === 0) { parts.push(buf.trim()); buf = ''; }
                            else { buf += ch; }
                        }
                        prev = ch;
                    }
                    if (buf.trim().length) parts.push(buf.trim());
                    return parts;
                };
                const parts = splitCommaTopLevel(working);
                const aggFuncs = ['COUNT','SUM','AVG','MIN','MAX','COLLECT','STDEV','STDEVP','PERCENTILECONT','PERCENTILEDISC'];
                const aggRe = new RegExp(`\\b(${aggFuncs.join('|')})\\s*\\(`, 'i');
                const isAggregation = parts.some(p => aggRe.test(p));
                const parseAlias = (part) => {
                    const m = part.match(/^(.*?)(?:\s+AS\s+(\w+))?$/i);
                    return { expr: (m ? m[1] : part).trim(), alias: (m ? m[2] : null) };
                };

                if (isAggregation) {
                    // Grouping: group by non-aggregate expressions; compute aggregates per group
                    const isAggExpr = (expr) => /\b(COUNT|SUM|AVG|MIN|MAX|COLLECT|STDEV|STDEVP|PERCENTILECONT|PERCENTILEDISC)\s*\(/i.test(expr);
                    const parsed = parts.map(parseAlias);
                    const groupKeys = parsed.filter(p => !isAggExpr(p.expr));
                    const aggKeys = parsed.filter(p => isAggExpr(p.expr));

                    // Build group map
                    const keyForRow = (row) => {
                        const obj = {};
                        for (const g of groupKeys) {
                            const keyAlias = g.alias || g.expr;
                            obj[keyAlias] = this._evaluateExpression(row, g.expr);
                        }
                        return JSON.stringify(obj);
                    };
                    const groups = new Map();
                    for (const r of results) {
                        const k = keyForRow(r);
                        if (!groups.has(k)) groups.set(k, []);
                        groups.get(k).push(r);
                    }
                    const out = [];
                    // Special case: aggregation-only projection with zero input rows should yield one row
                    if (groupKeys.length === 0 && groups.size === 0) {
                        const rec = {};
                        for (const a of aggKeys) {
                            const m = a.expr.match(/(\w+)\((.*?)\)/i);
                            if (!m) continue;
                            const [, func, inner0] = m;
                            let inner = inner0;
                            let collectDistinct = false;
                            if (/^DISTINCT\s+/i.test(inner)) { collectDistinct = true; inner = inner.replace(/^DISTINCT\s+/i,''); }
                            const val = this._evaluateCypherFunction(func, inner, [], { distinct: collectDistinct });
                            const keyAlias = a.alias || a.expr;
                            rec[keyAlias] = val;
                        }
                        out.push(rec);
                    } else {
                        for (const [k, rows] of groups.entries()) {
                            const base = JSON.parse(k);
                            const rec = { ...base };
                            for (const a of aggKeys) {
                                const m = a.expr.match(/(\w+)\((.*?)\)/i);
                                if (!m) continue;
                                const [, func, inner0] = m;
                                let inner = inner0;
                                let collectDistinct = false;
                                if (/^DISTINCT\s+/i.test(inner)) { collectDistinct = true; inner = inner.replace(/^DISTINCT\s+/i,''); }
                                const val = this._evaluateCypherFunction(func, inner, rows, { distinct: collectDistinct });
                                const keyAlias = a.alias || a.expr;
                                rec[keyAlias] = val;
                            }
                            out.push(rec);
                        }
                    }
                    if (distinct) {
                        const seen = new Set();
                        return out.filter(r => { const kk = JSON.stringify(r); if (seen.has(kk)) return false; seen.add(kk); return true; });
                    }
                    return out;
                } else {
                    const mapped = results.map(row => {
                        const newRow = {};
                        parts.forEach(part => {
                            const { expr, alias } = parseAlias(part);
                            // Map projections: var{.*} or var{.prop, .prop2}
                            const proj = expr.match(/^(\w+)\{(.*)\}$/);
                            if (proj) {
                                const v = proj[1];
                                const inner = proj[2].trim();
                                const ent = row[v];
                                const out = {};
                                if (inner === '.*') {
                                    Object.assign(out, (ent?.properties||{}));
                                } else {
                                    inner.split(',').map(s => s.trim()).forEach(tok => {
                                        const m = tok.match(/^\.(\w+)$/);
                                        if (m) { const p = m[1]; out[p] = ent?.properties?.[p]; }
                                    });
                                }
                                newRow[alias || v] = out;
                                return;
                            }
                            // Relationship or node property direct access r.prop or n.prop
                            const relProp = expr.match(/^(\w+)\.(\w+)$/);
                            if (relProp) {
                                const [, v, p] = relProp;
                                const base = row[v];
                                let val = null;
                                if (base && typeof base === 'object') {
                                    if (base.properties && Object.prototype.hasOwnProperty.call(base.properties, p)) val = base.properties[p];
                                    else if (Object.prototype.hasOwnProperty.call(base, p)) val = base[p];
                                }
                                newRow[alias || expr] = val;
                                return;
                            }

                            // Check for function calls in non-aggregated context
                            const funcMatch = expr.match(/(\w+)\((.*)\)$/i);
                            if (funcMatch) {
                                const [, func, inner] = funcMatch;
                                const key = alias || inner || part;
                                
                                // Path helper functions
                                if (func.toLowerCase() === 'nodes') {
                                    const pathObj = row[inner.trim()];
                                    const list = (pathObj?.segments || [])
                                        .filter(seg => seg.start || seg.node)
                                        .map(seg => seg.start || seg.node);
                                    newRow[key] = list;
                                    return;
                                } else if (func.toLowerCase() === 'relationships') {
                                    const pathObj = row[inner.trim()];
                                    const list = (pathObj?.segments || [])
                                        .filter(seg => seg.relationship)
                                        .map(seg => seg.relationship);
                                    newRow[key] = list;
                                    return;
                                } else if (func.toLowerCase() === 'length') {
                                    const pathObj = row[inner.trim()];
                                    const rels = (pathObj?.segments || []).filter(seg => seg.relationship).length;
                                    newRow[key] = rels;
                                    return;
                                }

                                const functionResult = this._evaluateCypherFunction(func, inner, [row]);
                                if (functionResult !== undefined) {
                                    newRow[key] = functionResult;
                                } else {
                                    // Fallback
                                    const [v, p] = inner.split('.');
                                    const value = p ? row[v]?.properties?.[p] : row[v];
                                    newRow[key] = value;
                                }
                            } else {
                                const outAlias = alias || part;
                                const outExpr = expr;
                                // var direct passthrough (node or relationship)
                                if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(outExpr)) {
                                    newRow[outAlias] = row[outExpr] !== undefined ? row[outExpr] : null;
                                    return;
                                }
                                // Otherwise evaluate as expression (numbers, strings, + - * /, CASE WHEN)
                                newRow[outAlias] = this._evaluateExpression(row, outExpr);
                            }
                        });
                        return newRow;
                    });
                    let finalRows = mapped;
                    if (distinct) {
                        const seen = new Set();
                        finalRows = finalRows.filter(r => { const k = JSON.stringify(r); if (seen.has(k)) return false; seen.add(k); return true; });
                    }
                    return finalRows;
                }
            }

            _evaluateExpression(row, expr) {
                const s = expr.trim();
                // CASE WHEN ... THEN ... [ELSE ...] END
                const caseM = s.match(/^CASE\s+WHEN\s+(.+?)\s+THEN\s+(.+?)(?:\s+ELSE\s+(.+?))?\s+END$/i);
                if (caseM) {
                    const [, cond, thenExpr, elseExpr] = caseM;
                    const ok = this._evaluateCondition(row, cond.trim());
                    return ok ? this._evaluateExpression(row, thenExpr.trim()) : (elseExpr ? this._evaluateExpression(row, elseExpr.trim()) : null);
                }
                // List comprehension: [x IN list WHERE cond | expr]
                const lc = s.match(/^\[(\w+)\s+IN\s+(.+?)\s*(?:WHERE\s+(.+?))?\s*\|\s*(.+)\]$/i);
                if (lc) {
                    const [, varName, listExpr, whereCond, mapExpr] = lc;
                    const listVal = this._evaluateExpression(row, listExpr.trim());
                    if (!Array.isArray(listVal)) return [];
                    const out = [];
                    for (const item of listVal) {
                        // Bind variable to the raw item; support both scalar and object cases
                        const scoped = { ...row, [varName]: item };
                        if (!whereCond || this._evaluateCondition(scoped, whereCond.trim())) {
                            out.push(this._evaluateExpression(scoped, mapExpr.trim()));
                        }
                    }
                    return out;
                }
                // Pattern comprehension (simplified): [ (a)-[r:TYPE]->(b) (WHERE cond)? | expr ]
                const pc = s.match(/^\[\s*(\(.+\)\s*-\s*\[.*\]\s*-?>\s*\(.+\))\s*(?:WHERE\s+(.+?))?\s*\|\s*(.+)\]$/i);
                if (pc) {
                    const [, pattern, whereCond, mapExpr] = pc;
                    // Build a temporary MATCH ... RETURN projection
                    const retVars = [];
                    const vm = pattern.match(/\((\w*)/g) || [];
                    vm.forEach(v => { const n=v.slice(1).trim(); if (n) retVars.push(n); });
                    const rm = pattern.match(/\[(\w*)/g) || [];
                    rm.forEach(r => { const n=r.slice(1).trim(); if (n) retVars.push(n); });
                    let matchRows = this._performMatch(pattern);
                    // Correlate with outer row if the pattern includes variables already bound
                    matchRows = matchRows.filter(r => this._rowsMatchOuterBindings(r, row));
                    let rows = matchRows.map(r => ({ ...row, ...r }));
                    if (whereCond) rows = rows.filter(r => this._evaluateCondition(r, whereCond.trim()));
                    const out = rows.map(r => this._evaluateExpression(r, mapExpr.trim()));
                    return out;
                }
                // List literal e.g., ['A', 'B', 1] - placed after pattern comprehension to avoid conflicts
                if (s.startsWith('[') && s.endsWith(']') && !/^\[\s*\w+\s+IN\b/i.test(s) && !/^\[\s*\(/.test(s)) {
                    const inner = s.slice(1, -1).trim();
                    const items = [];
                    let buf = '';
                    let depthPar = 0, depthBr = 0, depthCurly = 0; let inStr = null; let prev = '';
                    for (let i = 0; i < inner.length; i++) {
                        const ch = inner[i];
                        if (inStr) {
                            buf += ch;
                            if (ch === inStr && prev !== '\\') inStr = null;
                        } else {
                            if (ch === '"' || ch === "'") { inStr = ch; buf += ch; }
                            else if (ch === '(') { depthPar++; buf += ch; }
                            else if (ch === ')') { depthPar = Math.max(0, depthPar-1); buf += ch; }
                            else if (ch === '[') { depthBr++; buf += ch; }
                            else if (ch === ']') { depthBr = Math.max(0, depthBr-1); buf += ch; }
                            else if (ch === '{') { depthCurly++; buf += ch; }
                            else if (ch === '}') { depthCurly = Math.max(0, depthCurly-1); buf += ch; }
                            else if (ch === ',' && depthPar === 0 && depthBr === 0 && depthCurly === 0) {
                                if (buf.trim().length) items.push(buf.trim());
                                buf = '';
                            } else {
                                buf += ch;
                            }
                        }
                        prev = ch;
                    }
                    if (buf.trim().length) items.push(buf.trim());
                    return items.map(it => this._evaluateExpression(row, it));
                }
                // NULL literal
                if (/^NULL$/i.test(s)) return null;
                // String literal
                if ((s.startsWith("'") && s.endsWith("'")) || (s.startsWith('"') && s.endsWith('"'))) return s.slice(1,-1);
                // Boolean
                if (/^true$/i.test(s)) return true; if (/^false$/i.test(s)) return false;
                // Number
                if (/^-?\d+(?:\.\d+)?$/.test(s)) return Number(s);
                // Replace var.prop with literal token values and evaluate arithmetic with shunting-yard
                const tokenize = (input) => {
                    const tokens = [];
                    const re = /\s+|\d+\.\d+|\d+|\w+\.\w+|\w+|'.*?'|".*?"|[()+\-*/]/g;
                    let m; while ((m = re.exec(input)) !== null) { if (!/^\s+$/.test(m[0])) tokens.push(m[0]); }
                    return tokens;
                };
                const toValue = (tok) => {
                    if (/^'.*'$/.test(tok) || /^".*"$/.test(tok)) return tok.slice(1,-1);
                    if (/^-?\d+(?:\.\d+)?$/.test(tok)) return Number(tok);
                    if (/^\w+\.\w+$/.test(tok)) { const [v,p]=tok.split('.'); return (row[v]?.properties?.[p] ?? (row[v] && typeof row[v]==='object' ? row[v][p] : undefined)); }
                    if (/^\w+$/.test(tok)) return (row[tok]?.properties ? row[tok].properties : row[tok]);
                    return tok;
                };
                const prec = {'+':1,'-':1,'*':2,'/':2};
                const isOp = t => ['+','-','*','/'].includes(t);
                const output=[]; const stack=[];
                const toks = tokenize(s);
                for (const t of toks) {
                    if (isOp(t)) { while (stack.length && isOp(stack[stack.length-1]) && prec[stack[stack.length-1]]>=prec[t]) output.push(stack.pop()); stack.push(t); }
                    else if (t==='(') stack.push(t);
                    else if (t===')') { while (stack.length && stack[stack.length-1] !== '(') output.push(stack.pop()); stack.pop(); }
                    else output.push(toValue(t));
                }
                while (stack.length) output.push(stack.pop());
                const evalRpn = (rpn) => {
                    const st=[]; for (const x of rpn) {
                        if (isOp(x)) {
                            const b=st.pop(); const a=st.pop();
                            const anyNull = (a === null || a === undefined || b === null || b === undefined);
                            if (x==='+') {
                                if (typeof a==='string' || typeof b==='string') st.push(String(a??'')+String(b??''));
                                else st.push(anyNull ? null : (Number(a)+Number(b)));
                            }
                            if (x==='-') st.push(anyNull ? null : (Number(a)-Number(b)));
                            if (x==='*') st.push(anyNull ? null : (Number(a)*Number(b)));
                            if (x==='/') st.push(anyNull ? null : (Number(b)===0? null : (Number(a)/Number(b))));
                        } else st.push(x);
                    }
                    return st.pop();
                };
                return evalRpn(output);
            }

            _evaluateCondition(row, cond) {
                const getPropVal = (v,p) => {
                    const base = row[v];
                    if (base && typeof base === 'object') {
                        return base.properties ? base.properties[p] : base[p];
                    }
                    return undefined;
                };
                let c = cond.trim();
                // List predicates: ANY/ALL/NONE/SINGLE (x IN list WHERE cond)
                let pm = c.match(/^(ANY|ALL|NONE|SINGLE)\s*\(\s*(\w+)\s+IN\s+(.+?)\s+WHERE\s+(.+?)\s*\)$/i);
                if (pm) {
                    const [, kind, v, listExpr, innerCond] = pm;
                    const listVal = this._evaluateExpression(row, listExpr.trim());
                    const arr = Array.isArray(listVal) ? listVal : [];
                    let count = 0;
                    for (const item of arr) {
                        const scoped = { ...row, [v]: item };
                        if (this._evaluateCondition(scoped, innerCond.trim())) count++;
                    }
                    switch (kind.toUpperCase()) {
                        case 'ANY': return count > 0;
                        case 'ALL': return arr.length === 0 ? true : count === arr.length;
                        case 'NONE': return count === 0;
                        case 'SINGLE': return count === 1;
                    }
                }
                // EXISTS(var.prop)
                let m = c.match(/^EXISTS\((\w+)\.(\w+)\)$/i); if (m) { const [,v,p]=m; return getPropVal(v,p) !== undefined; }
                // IS NULL / IS NOT NULL
                m = c.match(/^(\w+)\.(\w+)\s+IS\s+(NOT\s+)?NULL$/i); if (m) { const [,v,p,notP]=m; const isNull = getPropVal(v,p)==null||getPropVal(v,p)===undefined; return notP? !isNull : isNull; }
                // Regex operator =~
                m = c.match(/^(\w+)\.(\w+)\s*=~\s*('.*?'|".*?")$/i); if (m) {
                    const [,v,p,patQ]=m; let pattern = patQ.slice(1,-1); let flags='';
                    if (pattern.startsWith('(?i)')) { flags='i'; pattern=pattern.slice(4); }
                    const re = new RegExp(pattern, flags);
                    const s = String(getPropVal(v,p) ?? '');
                    return re.test(s);
                }
                // String predicates
                m = c.match(/^(\w+)\.(\w+)\s+(STARTS WITH|ENDS WITH|CONTAINS)\s+('.*?'|".*?")$/i); if (m) {
                    const [,v,p,op,valQ]=m; const lit=valQ.slice(1,-1); const s=String(getPropVal(v,p)??'');
                    if (/STARTS WITH/i.test(op)) return s.startsWith(lit); if (/ENDS WITH/i.test(op)) return s.endsWith(lit); return s.includes(lit);
                }
                // Comparisons var.prop OP value
                m = c.match(/^(\w+)\.(\w+)\s*(=|!=|<>|>=|<=|>|<)\s*(.+)$/i); if (m) {
                    const [,v,p,op,valRaw]=m; const left=getPropVal(v,p); const right=this._parseValue(valRaw);
                    switch (op) { case '=': return left==right; case '!=': case '<>': return left!=right; case '>': return left>right; case '<': return left<right; case '>=': return left>=right; case '<=': return left<=right; }
                }
                // Comparisons bareVar OP value (for list comprehension WHERE n > 2)
                m = c.match(/^(\w+)\s*(=|!=|<>|>=|<=|>|<)\s*(.+)$/i); if (m) {
                    const [,v,op,valRaw]=m; const left = (row[v]?.properties ? row[v].properties : row[v]); const right=this._parseValue(valRaw);
                    switch (op) { case '=': return left==right; case '!=': case '<>': return left!=right; case '>': return left>right; case '<': return left<right; case '>=': return left>=right; case '<=': return left<=right; }
                }
                return false;
            }
            
            // Comprehensive Cypher function evaluation
            _evaluateCypherFunction(funcName, args, context, options = {}) {
                const func = funcName.toUpperCase();
                const splitArgs = (str) => {
                    if (!str) return [];
                    const parts = []; let buf=''; let depth=0; let inStr=null; let prev='';
                    for (let i=0;i<str.length;i++) {
                        const ch=str[i];
                        if (inStr) { buf+=ch; if (ch===inStr && prev !== '\\') inStr=null; }
                        else if (ch==='"' || ch==="'") { inStr=ch; buf+=ch; }
                        else if (ch==='(') { depth++; buf+=ch; }
                        else if (ch===')') { depth=Math.max(0,depth-1); buf+=ch; }
                        else if (ch===',' && depth===0) { parts.push(buf.trim()); buf=''; }
                        else { buf+=ch; }
                        prev=ch;
                    }
                    if (buf.trim().length) parts.push(buf.trim());
                    return parts;
                };
                const argParts = splitArgs(args);
                // Ensure we never reference undefined helper variables from earlier drafts
                const safeNumber = (v) => (v === undefined || v === null || v === '' ? 0 : Number(v));
                
                // Helper to get value from context
                const getValue = (expr) => {
                    if (expr === undefined || expr === null) return undefined;
                    const raw = String(expr).trim();
                    // string literal
                    if ((raw.startsWith("'") && raw.endsWith("'")) || (raw.startsWith('"') && raw.endsWith('"'))) {
                        return raw.slice(1, -1);
                    }
                    // number literal
                    if (/^-?\d+(?:\.\d+)?$/.test(raw)) return Number(raw);
                    if (!context || context.length === 0) return undefined;
                    const row = context[0];
                    if (raw.includes('.')) {
                        const [v, p] = raw.split('.');
                        return row[v]?.properties?.[p] ?? row[v]?.[p];
                    }
                    return row[raw];
                };
                
                const getValues = (expr) => context.map(r => {
                    // delegate to getValue with this row as context
                    const prev = context[0];
                    const tmpCtx = [r];
                    return (function(ctx){
                        const row0 = ctx[0];
                        const gv = (e) => {
                            if (e === undefined || e === null) return undefined;
                            const s = String(e).trim();
                            if ((s.startsWith("'") && s.endsWith("'")) || (s.startsWith('"') && s.endsWith('"'))) return s.slice(1,-1);
                            if (/^-?\d+(?:\.\d+)?$/.test(s)) return Number(s);
                            if (s.includes('.')) { const [v,p]=s.split('.'); return row0[v]?.properties?.[p] ?? row0?.[v]?.[p]; }
                            return row0[s];
                        };
                        return gv(expr);
                    })(tmpCtx);
                }).filter(v => v !== undefined && v !== null);

                switch (func) {
                    // Aggregation functions
                    case 'COUNT':
                        if (args === '*') return context.length;
                        return getValues(args).length;
                    case 'SUM':
                        return getValues(args).reduce((a, b) => a + b, 0);
                    case 'AVG':
                        const avgValues = getValues(args);
                        return avgValues.length > 0 ? avgValues.reduce((a, b) => a + b, 0) / avgValues.length : null;
                    case 'MIN':
                        const minValues = getValues(args);
                        return minValues.length > 0 ? Math.min(...minValues) : null;
                    case 'MAX':
                        const maxValues = getValues(args);
                        return maxValues.length > 0 ? Math.max(...maxValues) : null;
                    case 'COLLECT': {
                        // For COLLECT, retain nulls; undefined values are not produced by expression parsing here
                        const vals = context.map(r => {
                            const row0 = r;
                            const s = String(args).trim();
                            // string literal
                            if ((s.startsWith("'") && s.endsWith("'")) || (s.startsWith('"') && s.endsWith('"'))) return s.slice(1,-1);
                            // number literal
                            if (/^-?\d+(?:\.\d+)?$/.test(s)) return Number(s);
                            if (s.includes('.')) { const [v,p]=s.split('.'); return row0[v]?.properties?.[p] ?? row0?.[v]?.[p] ?? null; }
                            return row0[s] ?? null;
                        });
                        if (options.distinct) {
                            const seen = new Set();
                            return vals.filter(v => { const k = v === null ? '__NULL__' : JSON.stringify(v); if (seen.has(k)) return false; seen.add(k); return true; });
                        }
                        return vals;
                    }
                    case 'SIZE': {
                        let expr = args.trim();
                        if (/^nodes\(/i.test(expr)) {
                            const inner = expr.replace(/^nodes\(/i,'').replace(/\)$/,'').trim();
                            const row0 = context[0];
                            const pathObj = row0[inner];
                            if (!pathObj) return 0;
                            const seq = [];
                            (pathObj.segments||[]).forEach((seg,i) => {
                                if (i===0) seq.push(seg.start);
                                seq.push(seg.end);
                            });
                            // Fallback if segments empty and direct start/end provided
                            if (seq.length===0 && pathObj.start) seq.push(pathObj.start);
                            if (seq.length===1 && pathObj.end && seq[0]._id !== pathObj.end._id) seq.push(pathObj.end);
                            return seq.filter(Boolean).length;
                        }
                        const val = getValue(expr);
                        if (Array.isArray(val)) return val.length;
                        if (typeof val === 'string') return val.length;
                        return 0;
                    }
                    case 'STDEV':
                        const stdevValues = getValues(args);
                        if (stdevValues.length === 0) return null;
                        const mean = stdevValues.reduce((a, b) => a + b, 0) / stdevValues.length;
                        const variance = stdevValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / stdevValues.length;
                        return Math.sqrt(variance);
                    case 'STDEVP':
                        const stdevpValues = getValues(args);
                        if (stdevpValues.length === 0) return null;
                        const meanP = stdevpValues.reduce((a, b) => a + b, 0) / stdevpValues.length;
                        const varianceP = stdevpValues.reduce((sum, val) => sum + Math.pow(val - meanP, 2), 0) / (stdevpValues.length - 1);
                        return Math.sqrt(varianceP);
                    case 'PERCENTILECONT':
                    case 'PERCENTILEDISC':
                        const percentile = parseFloat(argParts[0]);
                        const percValues = getValues(argParts[1]).sort((a, b) => a - b);
                        if (percValues.length === 0) return null;
                        const index = (percentile / 100) * (percValues.length - 1);
                        return func === 'PERCENTILECONT' 
                            ? percValues[Math.floor(index)] + (percValues[Math.ceil(index)] - percValues[Math.floor(index)]) * (index - Math.floor(index))
                            : percValues[Math.round(index)];
                            
                    // String functions
                    case 'TOLOWER':
                        return String(getValue(args)).toLowerCase();
                    case 'TOUPPER':
                        return String(getValue(args)).toUpperCase();
                    case 'TRIM':
                        return String(getValue(args)).trim();
                    case 'LTRIM':
                        return String(getValue(args)).replace(/^\s+/, '');
                    case 'RTRIM':
                        return String(getValue(args)).replace(/\s+$/, '');
                    case 'REVERSE':
                        return String(getValue(args)).split('').reverse().join('');
                    case 'SIZE':
                        const sizeValue = getValue(args);
                        if (Array.isArray(sizeValue)) return sizeValue.length;
                        if (typeof sizeValue === 'string') return sizeValue.length;
                        return null;
                    case 'LENGTH':
                        return String(getValue(args)).length;
                    case 'SUBSTRING':
                        const str = String(getValue(argParts[0]));
                        const startPos = parseInt(argParts[1]) || 0;
                        const length = argParts[2] ? parseInt(argParts[2]) : undefined;
                        return length !== undefined ? str.substring(startPos, startPos + length) : str.substring(startPos);
                    case 'LEFT':
                        return String(getValue(argParts[0])).slice(0, parseInt(argParts[1]) || 0);
                    case 'RIGHT':
                        const rightStr = String(getValue(argParts[0]));
                        const rightLen = parseInt(argParts[1]) || 0;
                        return rightStr.slice(-rightLen);
                    case 'SPLIT': {
                        const src = String(getValue(argParts[0]) ?? '');
                        let delim = argParts[1];
                        delim = delim ? String(getValue(delim)) : undefined;
                        if (delim === undefined) return [src];
                        return src.split(delim);
                    }
                    case 'REPLACE':
                        return String(getValue(argParts[0])).replace(
                            new RegExp(argParts[1].replace(/['"]/g, ''), 'g'),
                            argParts[2].replace(/['"]/g, '')
                        );
                    case 'CONTAINS':
                        return String(getValue(argParts[0])).includes(argParts[1].replace(/['"]/g, ''));
                    case 'STARTSWITH':
                        return String(getValue(argParts[0])).startsWith(argParts[1].replace(/['"]/g, ''));
                    case 'ENDSWITH':
                        return String(getValue(argParts[0])).endsWith(argParts[1].replace(/['"]/g, ''));
                        
                    // Mathematical functions
                    case 'ABS':
                        return Math.abs(getValue(args));
                    case 'CEIL':
                        return Math.ceil(getValue(args));
                    case 'FLOOR':
                        return Math.floor(getValue(args));
                    case 'ROUND':
                        const roundValue = getValue(argParts[0]);
                        const precision = argParts[1] ? parseInt(argParts[1]) : 0;
                        return Math.round(roundValue * Math.pow(10, precision)) / Math.pow(10, precision);
                    case 'SIGN':
                        const signValue = getValue(args);
                        return signValue > 0 ? 1 : signValue < 0 ? -1 : 0;
                    case 'SQRT':
                        return Math.sqrt(getValue(args));
                    case 'SIN':
                        return Math.sin(getValue(args));
                    case 'COS':
                        return Math.cos(getValue(args));
                    case 'TAN':
                        return Math.tan(getValue(args));
                    case 'ASIN':
                        return Math.asin(getValue(args));
                    case 'ACOS':
                        return Math.acos(getValue(args));
                    case 'ATAN':
                        return Math.atan(getValue(args));
                    case 'ATAN2':
                        return Math.atan2(getValue(argParts[0]), getValue(argParts[1]));
                    case 'COT':
                        return 1 / Math.tan(getValue(args));
                    case 'DEGREES':
                        return getValue(args) * (180 / Math.PI);
                    case 'RADIANS':
                        return getValue(args) * (Math.PI / 180);
                    case 'LOG':
                        return Math.log(getValue(args));
                    case 'LOG10':
                        return Math.log10(getValue(args));
                    case 'EXP':
                        return Math.exp(getValue(args));
                    case 'E':
                        return Math.E;
                    case 'PI':
                        return Math.PI;
                    case 'RAND':
                        return Math.random();
                    case 'RANGE':
                        const rangeStart = parseInt(argParts[0]) || 0;
                        const rangeEnd = parseInt(argParts[1]) || 0;
                        const rangeStep = parseInt(argParts[2]) || 1;
                        const range = [];
                        for (let i = rangeStart; i <= rangeEnd; i += rangeStep) {
                            range.push(i);
                        }
                        return range;
                        
                    // List functions
                    case 'HEAD':
                        const headList = getValue(args);
                        return Array.isArray(headList) ? headList[0] : null;
                    case 'TAIL':
                        const tailList = getValue(args);
                        return Array.isArray(tailList) ? tailList.slice(1) : null;
                    case 'LAST':
                        const lastList = getValue(args);
                        return Array.isArray(lastList) ? lastList[lastList.length - 1] : null;
                    case 'EXTRACT':
                        // Simplified EXTRACT implementation
                        const extractList = getValue(argParts[1]);
                        const extractExpr = argParts[0];
                        return Array.isArray(extractList) ? extractList.map(item => item) : null;
                    case 'FILTER':
                        // Simplified FILTER implementation
                        const filterList = getValue(argParts[1]);
                        return Array.isArray(filterList) ? filterList.filter(item => item !== null) : null;
                    case 'REDUCE':
                        // Simplified REDUCE implementation
                        const reduceList = getValue(argParts[2]);
                        const initialValue = getValue(argParts[1]);
                        return Array.isArray(reduceList) ? reduceList.reduce((acc, val) => acc + val, initialValue) : initialValue;
                        
                    // Node/Relationship functions
                    case 'ID':
                        // Neo4j: ID(node or relationship) -> integer id
                        // Our wrappers use _id; fall back to raw id if present
                        const idValue = getValue(args);
                        if (idValue && typeof idValue === 'object') {
                            if (Object.prototype.hasOwnProperty.call(idValue, '_id')) return idValue._id;
                            if (Object.prototype.hasOwnProperty.call(idValue, 'id')) return idValue.id;
                        }
                        return idValue ?? null;
                    case 'TYPE':
                        // Neo4j: TYPE(relationship) -> type string; undefined for nodes/scalars
                        const typeValue = getValue(args);
                        if (typeValue && typeof typeValue === 'object' && typeValue._type === 'relationship') {
                            return typeValue.type;
                        }
                        return null;
                    case 'LABELS':
                        // Neo4j: LABELS(node) -> list of labels
                        const labelsValue = getValue(args);
                        if (labelsValue && typeof labelsValue === 'object') {
                            if (Array.isArray(labelsValue.labels)) return labelsValue.labels;
                            // Fallback for raw node: Set or single label
                            if (labelsValue.labels instanceof Set) return Array.from(labelsValue.labels);
                            if (labelsValue.label) return [labelsValue.label];
                        }
                        return [];
                    case 'KEYS':
                        const keysValue = getValue(args);
                        return keysValue?.properties ? Object.keys(keysValue.properties) : [];
                    case 'PROPERTIES':
                        const propsValue = getValue(args);
                        return propsValue?.properties || {};
                    case 'STARTNODE':
                        // Neo4j: STARTNODE(relationship) -> node
                        const startRel = getValue(args);
                        if (startRel && typeof startRel === 'object' && startRel._type === 'relationship') {
                            const n = this.db.nodes.get(startRel.startNode);
                            return n ? this._formatNodeForOutput(n) : null;
                        }
                        return null;
                    case 'ENDNODE':
                        // Neo4j: ENDNODE(relationship) -> node
                        const endRel = getValue(args);
                        if (endRel && typeof endRel === 'object' && endRel._type === 'relationship') {
                            const n = this.db.nodes.get(endRel.endNode);
                            return n ? this._formatNodeForOutput(n) : null;
                        }
                        return null;
                        
                    // Date/Time functions
                    case 'DATE':
                        if (!args || args === '()') return new Date().toISOString().split('T')[0];
                        return new Date(getValue(args)).toISOString().split('T')[0];
                    case 'DATETIME':
                        if (!args || args === '()') return new Date().toISOString();
                        return new Date(getValue(args)).toISOString();
                    case 'TIME':
                        if (!args || args === '()') return new Date().toTimeString().split(' ')[0];
                        return new Date(getValue(args)).toTimeString().split(' ')[0];
                    case 'TIMESTAMP':
                        return Date.now();
                    case 'DURATION':
                        // Simplified duration - return as string
                        return `P${argParts[0] || 0}DT${argParts[1] || 0}H${argParts[2] || 0}M${argParts[3] || 0}S`;
                        
                    // Type checking functions
                    case 'EXISTS':
                        return getValue(args) !== undefined && getValue(args) !== null;
                    case 'ISNULL':
                        return getValue(args) === null || getValue(args) === undefined;
                    case 'ISNAN':
                        return isNaN(getValue(args));
                    case 'ISINF':
                        return !isFinite(getValue(args));
                        
                    // Comparison functions
                    case 'COALESCE': {
                        const row = (context && context[0]) || {};
                        for (const arg of argParts) {
                            let val;
                            try { val = this._evaluateExpression(row, arg); } catch { val = undefined; }
                            if (val !== null && val !== undefined) return val;
                        }
                        return null;
                    }
                    case 'CASE':
                        // Simplified CASE implementation
                        return getValue(argParts[0]);
                    
                    // Additional string functions
                    case 'LPAD':
                        const lpadStr = String(getValue(argParts[0]));
                        const lpadLen = getValue(argParts[1]);
                        const lpadChar = argParts[2] ? String(getValue(argParts[2])) : ' ';
                        return lpadStr.padStart(lpadLen, lpadChar);
                    case 'RPAD':
                        const rpadStr = String(getValue(argParts[0]));
                        const rpadLen = getValue(argParts[1]);
                        const rpadChar = argParts[2] ? String(getValue(argParts[2])) : ' ';
                        return rpadStr.padEnd(rpadLen, rpadChar);
                    case 'UPPER':
                        return String(getValue(argParts[0])).toUpperCase();
                    case 'LOWER':
                        return String(getValue(argParts[0])).toLowerCase();
                    
                    // Additional math functions
                    case 'POWER':
                        return Math.pow(getValue(argParts[0]), getValue(argParts[1]));
                    case 'MOD':
                        return getValue(argParts[0]) % getValue(argParts[1]);
                    case 'FACTORIAL':
                        const factNum = getValue(argParts[0]);
                        let result = 1;
                        for (let i = 2; i <= factNum; i++) result *= i;
                        return result;
                    case 'GCD':
                        let a = getValue(argParts[0]), b = getValue(argParts[1]);
                        while (b !== 0) { const temp = b; b = a % b; a = temp; }
                        return a;
                    case 'LCM':
                        // Inline GCD to avoid referencing missing helper
                        const aVal = safeNumber(getValue(argParts[0]));
                        const bVal = safeNumber(getValue(argParts[1]));
                        const gcd = (x, y) => { x = Math.abs(x); y = Math.abs(y); while (y) { [x, y] = [y, x % y]; } return x || 1; };
                        return aVal && bVal ? (aVal * bVal) / gcd(aVal, bVal) : 0;
                    
                    // Additional date/time functions
                    case 'NOW':
                        return new Date();
                    case 'LOCALDATETIME':
                        return new Date().toISOString().slice(0, 19);
                    case 'LOCALTIME':
                        return new Date().toTimeString().slice(0, 8);
                    case 'YEAR':
                        return new Date(getValue(argParts[0])).getFullYear();
                    case 'MONTH':
                        return new Date(getValue(argParts[0])).getMonth() + 1;
                    case 'DAY':
                        return new Date(getValue(argParts[0])).getDate();
                    case 'HOUR':
                        return new Date(getValue(argParts[0])).getHours();
                    case 'MINUTE':
                        return new Date(getValue(argParts[0])).getMinutes();
                    case 'SECOND':
                        return new Date(getValue(argParts[0])).getSeconds();
                    
                    // Additional list functions
                    case 'ALL':
                        // Simplified: ALL(list) -> true if list exists & all items are truthy
                        const allList = getValue(argParts[0]);
                        return Array.isArray(allList) ? allList.every(Boolean) : false;
                    case 'ANY':
                        const anyList = getValue(argParts[0]);
                        return Array.isArray(anyList) ? anyList.some(Boolean) : false;
                    case 'NONE':
                        const noneList = getValue(argParts[0]);
                        return Array.isArray(noneList) ? noneList.every(v => !v) : true;
                    case 'SINGLE':
                        const singleList = getValue(argParts[0]);
                        if (!Array.isArray(singleList)) return false;
                        return singleList.filter(Boolean).length === 1;
                    
                    // Additional type functions
                    case 'TOBOOL':
                        const boolVal = getValue(argParts[0]);
                        if (typeof boolVal === 'boolean') return boolVal;
                        if (typeof boolVal === 'string') return boolVal.toLowerCase() === 'true';
                        return Boolean(boolVal);
                    case 'TOFLOAT':
                        return parseFloat(getValue(argParts[0]));
                    case 'TOINT':
                        return parseInt(getValue(argParts[0]));
                    case 'TOSTRING':
                        return String(getValue(argParts[0]));
                    
                    // Additional spatial functions
                    case 'DISTANCE':
                        const point1 = getValue(argParts[0]);
                        const point2 = getValue(argParts[1]);
                        if (point1?.x !== undefined && point2?.x !== undefined) {
                            return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
                        }
                        return null;
                    case 'POINT':
                        return { x: getValue(argParts[0]), y: getValue(argParts[1]) };
                    
                    // Additional utility functions
                    case 'RANDOMUUID':
                        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                            const r = Math.random() * 16 | 0;
                            const v = c === 'x' ? r : (r & 0x3 | 0x8);
                            return v.toString(16);
                        });
                    case 'HAVERSIN':
                        return (1 - Math.cos(getValue(argParts[0]))) / 2;
                    case 'SHORTESTPATH':
                        // Simplified shortest path
                        return getValue(argParts[0]);
                        
                    default:
                        return undefined;
                }
            }
            
            _applyOrderBy(results, orderByClause) {
                // Support multi-column ORDER BY with ASC/DESC and NULLS FIRST/LAST
                const splitCommaTopLevel = (str) => {
                    const parts = []; let buf = ''; let depth=0; let inStr=null; let prev='';
                    for (let i=0;i<str.length;i++) {
                        const ch=str[i];
                        if (inStr) { buf+=ch; if (ch===inStr && prev!=='\\') inStr=null; }
                        else if (ch==='"' || ch==="'") { inStr=ch; buf+=ch; }
                        else if (ch==='('||ch==='['||ch==='{') { depth++; buf+=ch; }
                        else if (ch===')'||ch===']'||ch==='}') { depth=Math.max(0,depth-1); buf+=ch; }
                        else if (ch===',' && depth===0) { parts.push(buf.trim()); buf=''; }
                        else buf+=ch;
                        prev=ch;
                    }
                    if (buf.trim().length) parts.push(buf.trim());
                    return parts;
                };
                const specs = splitCommaTopLevel(orderByClause).map(s => {
                    const m = s.match(/^(.+?)(?:\s+(ASC|DESC))?(?:\s+NULLS\s+(FIRST|LAST))?$/i);
                    const expr = (m ? m[1] : s).trim();
                    const dir = (m && m[2]) ? m[2].toUpperCase() : 'ASC';
                    const nulls = (m && m[3]) ? m[3].toUpperCase() : (dir === 'ASC' ? 'LAST' : 'FIRST');
                    return { expr, dir, nulls };
                });
                const getVal = (row, expr) => {
                    // Support alias keys or var.prop
                    if (/^\w+\.\w+$/.test(expr)) { const [v,p]=expr.split('.'); return row[v]?.properties?.[p]; }
                    return row[expr];
                };
                const cmp = (a, b) => {
                    for (const {expr, dir, nulls} of specs) {
                        const va = getVal(a, expr); const vb = getVal(b, expr);
                        const aNull = (va===null || va===undefined); const bNull = (vb===null || vb===undefined);
                        if (aNull || bNull) {
                            if (aNull && bNull) continue;
                            return aNull ? (nulls==='FIRST' ? -1 : 1) : (nulls==='FIRST' ? 1 : -1);
                        }
                        if (va < vb) return dir==='ASC' ? -1 : 1;
                        if (va > vb) return dir==='ASC' ? 1 : -1;
                    }
                    return 0;
                };
                const out = [...results];
                out.sort(cmp);
                return out;
            }


            _handleDelete(match) {
                const [, pattern, deleteType, deleteVars] = match;
                let deletedCount = 0;
                const variable = deleteVars.trim();
                
                const nodePattern = this._parseNodePattern(pattern);
                const relPattern = this._parseRelPattern(pattern);

                if (pattern.includes(`(${variable})`) || pattern.includes(`(${variable}:`)) {
                    const nodesToDelete = this.db.findNodes(nodePattern.label, nodePattern.properties);
                    nodesToDelete.forEach(node => {
                        if (deleteType.toUpperCase().startsWith('DETACH')) this.db.detachDeleteNode(node.id);
                        else this.db.deleteNode(node.id);
                        deletedCount++;
                    });
                } else if (pattern.includes(`[${variable}]`) || pattern.includes(`[${variable}:`)) {
                    let relsToDelete = [];
                    if (relPattern && relPattern.types && relPattern.types.length > 1) {
                        // manual filter any-of types
                        this.db.relationships.forEach(rel => {
                            if (!relPattern.types.includes(rel.type)) return;
                            let ok = true;
                            for (const [k,v] of Object.entries(relPattern.properties||{})) {
                                if (rel.properties[k] !== v) { ok = false; break; }
                            }
                            if (ok) relsToDelete.push(rel);
                        });
                    } else {
                        relsToDelete = this.db.findRelationships(relPattern.type, relPattern.properties);
                    }
                    relsToDelete.forEach(rel => {
                        this.db.deleteRelationship(rel.id);
                        deletedCount++;
                    });
                } else { throw new Error(`Invalid DELETE target: ${deleteVars}`); }
                
                return { type: 'delete', message: `Deleted ${deletedCount} entities.`, result: [] };
            }

            _handleSet(query) {
                const match = query.match(/(?:MATCH|MERGE)\s+(.*?)\s+SET\s+(.*)$/i);
                if (!match) throw new Error("Invalid SET syntax. Must be preceded by MATCH or MERGE.");
                const [, pattern, setClause] = match;
                // Use pattern matcher to get bound variables (nodes and possibly relationship variable)
                const rows = this._performMatch(pattern);
                if (!rows || rows.length === 0) return { type: 'update', message: "Set 0 items, no match.", result: [] };
                this._applySetToRows(rows, setClause);
                return { type: 'update', message: "Set properties/labels.", result: [] };
            }

            _applySetToNodes(nodes, setClause) {
                const assignments = setClause.split(',').map(s => s.trim());
                
                nodes.forEach(node => {
                    assignments.forEach(assignment => {
                        if (assignment.includes('=')) {
                            const [fullVar, valueStr] = assignment.split('=').map(s => s.trim());
                            const [variable, propName] = fullVar.split('.');
                            if (!propName) throw new Error(`Invalid property assignment: ${assignment}`);
                            node.properties[propName] = this._parseValue(valueStr);
                        } else if (assignment.includes(':')) {
                            const [variable, label] = assignment.split(':').map(s => s.trim());
                            if (!label) throw new Error(`Invalid label assignment: ${assignment}`);
                            node.labels.add(label);
                            if (!this.db.labelsToNodes.has(label)) this.db.labelsToNodes.set(label, new Set());
                            this.db.labelsToNodes.get(label).add(node.id);
                        } else {
                            throw new Error(`Invalid SET clause: ${assignment}`);
                        }
                    });
                });
            }

            _applySetToRows(rows, setClause) {
                const assignments = setClause.split(',').map(s => s.trim()).filter(Boolean);
                for (const row of rows) {
                    for (const assignment of assignments) {
                        if (assignment.includes('=')) {
                            const [lhsRaw, valueStr] = assignment.split('=').map(s => s.trim());
                            const m = lhsRaw.match(/^(\w+)\.(\w+)$/);
                            if (!m) throw new Error(`Invalid property assignment: ${assignment}`);
                            const [, v, prop] = m;
                            const ent = row[v];
                            if (!ent || typeof ent !== 'object') continue;
                            const val = this._parseValue(valueStr);
                            if (ent._type === 'node') {
                                const n = this.db.nodes.get(ent._id);
                                if (n) n.properties[prop] = val;
                            } else if (ent._type === 'relationship') {
                                const r = this.db.relationships.get(ent._id);
                                if (r) r.properties[prop] = val;
                            }
                        } else if (assignment.includes(':')) {
                            // Add label to node: v:Label
                            const [v, label] = assignment.split(':').map(s => s.trim());
                            const ent = row[v];
                            if (!ent || ent._type !== 'node') continue;
                            const n = this.db.nodes.get(ent._id);
                            if (!n) continue;
                            n.labels.add(label);
                            if (!this.db.labelsToNodes.has(label)) this.db.labelsToNodes.set(label, new Set());
                            this.db.labelsToNodes.get(label).add(n.id);
                        } else {
                            throw new Error(`Invalid SET clause: ${assignment}`);
                        }
                    }
                }
            }

            _applyRemoveToRows(rows, removeClause) {
                const ops = removeClause.split(',').map(s => s.trim()).filter(Boolean);
                for (const row of rows) {
                    for (const op of ops) {
                        if (op.includes('.')) {
                            const m = op.match(/^(\w+)\.(\w+)$/);
                            if (!m) continue;
                            const [, v, p] = m;
                            const ent = row[v];
                            if (!ent || typeof ent !== 'object') continue;
                            if (ent._type === 'node') {
                                const n = this.db.nodes.get(ent._id);
                                if (n && Object.prototype.hasOwnProperty.call(n.properties, p)) delete n.properties[p];
                            } else if (ent._type === 'relationship') {
                                const r = this.db.relationships.get(ent._id);
                                if (r && Object.prototype.hasOwnProperty.call(r.properties, p)) delete r.properties[p];
                            }
                        } else if (op.includes(':')) {
                            const [v, label] = op.split(':').map(s => s.trim());
                            const ent = row[v];
                            if (ent && ent._type === 'node') {
                                const n = this.db.nodes.get(ent._id);
                                if (n && n.labels.has(label)) {
                                    n.labels.delete(label);
                                    this.db.labelsToNodes.get(label)?.delete(n.id);
                                }
                            }
                        }
                    }
                }
            }

            _handleRemove(query) {
                const match = query.match(/MATCH\s+(.*?)\s+REMOVE\s+(.*)$/i);
                if (!match) throw new Error("Invalid REMOVE syntax.");
                const [, pattern, removeClause] = match;
                const rows = this._performMatch(pattern);
                if (!rows || rows.length === 0) return { type: 'update', message: "Removed 0 items, no match.", result: [] };
                let removedCount = 0;
                const ops = removeClause.split(',').map(s => s.trim()).filter(Boolean);
                for (const row of rows) {
                    for (const op of ops) {
                        if (op.includes('.')) {
                            const m = op.match(/^(\w+)\.(\w+)$/);
                            if (!m) continue;
                            const [, v, p] = m;
                            const ent = row[v];
                            if (!ent || typeof ent !== 'object') continue;
                            if (ent._type === 'node') {
                                const n = this.db.nodes.get(ent._id); if (n && Object.prototype.hasOwnProperty.call(n.properties,p)) { delete n.properties[p]; removedCount++; }
                            } else if (ent._type === 'relationship') {
                                const r = this.db.relationships.get(ent._id); if (r && Object.prototype.hasOwnProperty.call(r.properties,p)) { delete r.properties[p]; removedCount++; }
                            }
                        } else if (op.includes(':')) {
                            const [v, label] = op.split(':').map(s=>s.trim());
                            const ent = row[v];
                            if (ent && ent._type === 'node') {
                                const n = this.db.nodes.get(ent._id);
                                if (n && n.labels.has(label)) {
                                    n.labels.delete(label);
                                    this.db.labelsToNodes.get(label)?.delete(n.id);
                                    removedCount++;
                                }
                            }
                        }
                    }
                }
                return { type: 'update', message: `Removed ${removedCount} properties/labels.`, result: [] };
            }

            _handleUnion(query, params) {
                const parts = [];
                const unions = [];
                const re = /\bUNION(?:\s+ALL)?\b/gi;
                let lastIndex = 0; let m;
                while ((m = re.exec(query)) !== null) {
                    parts.push(query.slice(lastIndex, m.index).trim());
                    unions.push(/ALL/i.test(m[0]));
                    lastIndex = re.lastIndex;
                }
                parts.push(query.slice(lastIndex).trim());
                const allRows = []; let columns = null;
                for (let idx = 0; idx < parts.length; idx++) {
                    let part = parts[idx];
                    // Strip union-level ORDER BY/SKIP/LIMIT from the last subquery part before executing it
                    if (idx === parts.length - 1) {
                        const hasOrder = /ORDER BY\s+.+/i.test(query);
                        const hasSkip = /\bSKIP\s+\d+/i.test(query);
                        const hasLimit = /\bLIMIT\s+\d+/i.test(query);
                        if (hasOrder || hasSkip || hasLimit) {
                            part = part
                                .replace(/\s+ORDER BY\s+(.+?)(?=\s+SKIP|\s+LIMIT|$)/i, '')
                                .replace(/\s+SKIP\s+\d+/i, '')
                                .replace(/\s+LIMIT\s+\d+/i, '')
                                .trim();
                        }
                    }
                    this._inUnion = true;
                    const r = this.executeQuery(part, params);
                    this._inUnion = false;
                    if (r.type !== 'tabular') throw new Error('UNION requires tabular results with consistent columns.');
                    const rows = r.data || [];
                    if (!columns && rows.length > 0) columns = Object.keys(rows[0]);
                    if (columns) {
                        rows.forEach(row => {
                            const aligned = {};
                            columns.forEach(c => { aligned[c] = (row[c] !== undefined ? row[c] : null); });
                            allRows.push(aligned);
                        });
                    } else {
                        allRows.push(...rows);
                    }
                }
                const hasDistinct = unions.some(u => !u);
                let data = allRows;
                if (hasDistinct) {
                    const seen = new Set();
                    data = allRows.filter(r => { const k = JSON.stringify(r); if (seen.has(k)) return false; seen.add(k); return true; });
                }
                // Apply trailing ORDER BY/SKIP/LIMIT on the unioned result
                const orderByMatch = query.match(/ORDER BY\s+(.+?)(?=\s+SKIP|\s+LIMIT|$)/i);
                const skipMatch = query.match(/SKIP\s+(\d+)/i);
                const limitMatch = query.match(/LIMIT\s+(\d+)/i);
                if (orderByMatch && columns) {
                    const ob = orderByMatch[1].trim();
                    const splitCommaTopLevel = (str) => {
                        const parts = []; let buf = ''; let depth=0; let inStr=null; let prev='';
                        for (let i=0;i<str.length;i++) {
                            const ch=str[i];
                            if (inStr) { buf+=ch; if (ch===inStr && prev!=='\\') inStr=null; }
                            else if (ch==='"' || ch==="'") { inStr=ch; buf+=ch; }
                            else if (ch==='('||ch==='['||ch==='{') { depth++; buf+=ch; }
                            else if (ch===')'||ch===']'||ch==='}') { depth=Math.max(0,depth-1); buf+=ch; }
                            else if (ch===',' && depth===0) { parts.push(buf.trim()); buf=''; }
                            else buf+=ch;
                            prev=ch;
                        }
                        if (buf.trim().length) parts.push(buf.trim());
                        return parts;
                    };
                    const specs = splitCommaTopLevel(ob).map(s => {
                        const m = s.match(/^(\w+)(?:\s+(ASC|DESC))?(?:\s+NULLS\s+(FIRST|LAST))?$/i);
                        const col = (m ? m[1] : s).trim();
                        const dir = (m && m[2]) ? m[2].toUpperCase() : 'ASC';
                        const nulls = (m && m[3]) ? m[3].toUpperCase() : (dir === 'ASC' ? 'LAST' : 'FIRST');
                        return { col, dir, nulls };
                    });
                    data.sort((a,b)=>{
                        for (const {col, dir, nulls} of specs) {
                            const va=a[col]; const vb=b[col];
                            const aNull = (va===null || va===undefined); const bNull = (vb===null || vb===undefined);
                            if (aNull || bNull) {
                                if (aNull && bNull) continue;
                                return aNull ? (nulls==='FIRST'? -1:1) : (nulls==='FIRST'? 1:-1);
                            }
                            if (va<vb) return dir==='ASC' ? -1 : 1;
                            if (va>vb) return dir==='ASC' ? 1 : -1;
                        }
                        return 0;
                    });
                }
                if (skipMatch) data = data.slice(parseInt(skipMatch[1]));
                if (limitMatch) data = data.slice(0, parseInt(limitMatch[1]));
                return { type: 'tabular', message: `Found ${data.length} rows.`, data, result: data, columns: columns || (data[0] ? Object.keys(data[0]) : []) };
            }

            _handleReturnOnly(query) {
                const returnMatch = query.match(/^RETURN\s+(.*)$/i);
                if (!returnMatch) throw new Error('Invalid RETURN syntax.');
                const clause = returnMatch[1];
                let rows = [{}];
                rows = this._applyWithOrReturn(rows, clause);
                return { type: 'tabular', message: `Found ${rows.length} rows.`, data: rows, result: rows };
            }

            _handleMerge(query) {
                // Relationship MERGE pattern
                const relMerge = query.match(/MERGE\s*\((\w+):?(\w+)?\s*\{?([^}]*)\}?\)\s*-\s*\[(\w+)?:([A-Za-z_][A-Za-z0-9_]*)\s*(\{[^}]*\})?\]\s*->\s*\((\w+):?(\w+)?\s*\{?([^}]*)\}?\)/i);
                if (relMerge) {
                    const [, aVar, aLabel, aPropsStr, rVar, rType, rPropsStr, bVar, bLabel, bPropsStr] = relMerge;
                    const aProps = this._parseProperties(aPropsStr);
                    const bProps = this._parseProperties(bPropsStr);
                    // Find or create nodes
                    let aCandidates = aLabel ? this.db.findNodes(aLabel, aProps) : this.db.findNodes(undefined, aProps);
                    let bCandidates = bLabel ? this.db.findNodes(bLabel, bProps) : this.db.findNodes(undefined, bProps);
                    let aNode = aCandidates[0]; let bNode = bCandidates[0];
                    let createdNodeCount = 0;
                    if (!aNode) { aNode = this.db.createNode(aLabel ? [aLabel] : [], aProps); createdNodeCount++; }
                    if (!bNode) { bNode = this.db.createNode(bLabel ? [bLabel] : [], bProps); createdNodeCount++; }
                    // Find or create relationship
                    let rel = null;
                    for (const rr of this.db.relationships.values()) {
                        if (rr.startNode === aNode.id && rr.endNode === bNode.id && rr.type === rType) {
                            rel = rr; break;
                        }
                    }
                    const relProps = this._parseProperties(rPropsStr);
                    let wasCreated = false;
                    if (!rel) { rel = this.db.createRelationship(aNode.id, bNode.id, rType, relProps); wasCreated = true; }
                    // ON CREATE / ON MATCH SET
                    const onCreateMatch = query.match(/ON CREATE SET\s+(.*?)(?=\s+ON MATCH|$)/i);
                    const onMatchMatch = query.match(/ON MATCH SET\s+(.*)/i);
                    const applySet = (clause) => {
                        const assigns = clause.split(',').map(s=>s.trim());
                        assigns.forEach(asg => {
                            const [lhs, rhs] = asg.split('=').map(s=>s.trim());
                            const m = lhs.match(/(\w+)\.(\w+)/);
                            if (!m) return;
                            const [, v, p] = m;
                            const val = this._parseValue(rhs);
                            if (v === aVar) aNode.properties[p] = val;
                            else if (v === bVar) bNode.properties[p] = val;
                            else if (v === (rVar||'r')) rel.properties[p] = val;
                        });
                    };
                    if (wasCreated && onCreateMatch) applySet(onCreateMatch[1]);
                    if (!wasCreated && onMatchMatch) applySet(onMatchMatch[1]);
                    const msg = wasCreated ? 'Created 1 relationship.' : 'Matched 1 relationship.';
                    return { type: wasCreated ? 'create' : 'read', message: msg, result: [this._formatRelForOutput(rel)] };
                }

                // Node MERGE fallback
                const mergeMatch = query.match(/MERGE\s+(\(.*\))/i);
                if (!mergeMatch) throw new Error("Only MERGE of node or simple relationship pattern is supported.");
                const nodePattern = this._parseNodePattern(mergeMatch[1]);
                const existingNodes = this.db.findNodes(nodePattern.label, nodePattern.properties);
                let wasCreated = false; let targetNode;
                if (existingNodes.length > 0) targetNode = existingNodes[0];
                else { const { label, properties } = nodePattern; targetNode = this.db.createNode(label ? [label] : [], properties); wasCreated = true; }
                const onCreateMatch = query.match(/ON CREATE SET\s+(.*?)(?=\s+ON MATCH|$)/i);
                const onMatchMatch = query.match(/ON MATCH SET\s+(.*)/i);
                if (wasCreated && onCreateMatch) { this._applySetToNodes([targetNode], onCreateMatch[1]); }
                else if (!wasCreated && onMatchMatch) { this._applySetToNodes([targetNode], onMatchMatch[1]); }
                const message = wasCreated ? "Created 1 node." : "Matched 1 node.";
                return { type: wasCreated ? 'create' : 'read', message, result: [this._formatNodeForOutput(targetNode)] };
            }

            _handleUnwind(query) {
                const unwindMatch = query.match(/UNWIND\s+(.*?)\s+AS\s+(\w+)/i);
                if (!unwindMatch) throw new Error("Invalid UNWIND syntax.");
                
                let [, listStr, variable] = unwindMatch;
                let list;
                // Try to evaluate as expression first (e.g., [1,2,3])
                try {
                    const evaluated = this._evaluateExpression({}, listStr.trim());
                    if (Array.isArray(evaluated)) {
                        list = evaluated;
                    }
                } catch(_) { /* fall back to JSON parse */ }
                // If still not a list, try function call like range(1,3)
                if (!Array.isArray(list)) {
                    const fm = listStr.trim().match(/^(\w+)\((.*)\)$/);
                    if (fm) {
                        const func = fm[1];
                        const args = fm[2];
                        const val = this._evaluateCypherFunction(func, args, [{}]);
                        if (Array.isArray(val)) list = val;
                    }
                }
                if (!Array.isArray(list)) {
                    try {
                        list = JSON.parse(listStr.replace(/'/g, '"'));
                    } catch(e) {
                        throw new Error("UNWIND expects a list expression.");
                    }
                }

                const results = list.map(item => ({ [variable]: item }));
                
        const createMatch = query.match(/CREATE\s+(.*)/i);
                if (createMatch) {
                    let createdCount = 0;
                    results.forEach(row => {
                        let nodePatternStr = createMatch[1];
                        if(nodePatternStr.includes(variable)) {
                            const propValue = typeof row[variable] === 'string' ? `'${row[variable]}'` : row[variable];
                            nodePatternStr = nodePatternStr.replace(new RegExp(`{\\s*title:\\s*${variable}\\s*}`, 'g'), `{title: ${propValue}}`);
                        }
                        const nodePattern = this._parseNodePattern(nodePatternStr);
            const labels = (nodePattern.labels && nodePattern.labels.length > 0) ? nodePattern.labels : [];
            this.db.createNode(labels, nodePattern.properties);
                        createdCount++;
                    });
                    return { type: 'create', message: `Created ${createdCount} nodes.`, result: [] };
                }

                // Support UNWIND ... RETURN ... (plus optional ORDER BY/SKIP/LIMIT)
                const returnClauseMatch = query.match(/RETURN\s+(.*?(?=\s+ORDER BY|\s+SKIP|\s+LIMIT|$))/i);
                if (returnClauseMatch) {
                    let rows = this._applyWithOrReturn(results, returnClauseMatch[1]);
                    const orderByClauseMatch = query.match(/ORDER BY\s+(.*?(?=\s+SKIP|\s+LIMIT|$))/i);
                    const skipClauseMatch = query.match(/SKIP\s+(\d+)/i);
                    const limitClauseMatch = query.match(/LIMIT\s+(\d+)/i);
                    if (orderByClauseMatch) rows = this._applyOrderBy(rows, orderByClauseMatch[1]);
                    if (skipClauseMatch) rows = rows.slice(parseInt(skipClauseMatch[1]));
                    if (limitClauseMatch) rows = rows.slice(0, parseInt(limitClauseMatch[1]));
                    return { type: 'tabular', message: `Found ${rows.length} rows.`, data: rows, result: rows };
                }

                return { type: 'read', message: `Unwound ${results.length} items.`, result: results };
            }

            _handleCreateConstraint(query) {
                const nameMatch = query.match(/CREATE\s+CONSTRAINT\s+(\w+)\s+ON/i);
                const match = query.match(/CREATE\s+CONSTRAINT(?:\s+\w+)?\s+ON\s+\((\w+):(\w+)\)\s+ASSERT\s+(\w+\.\w+)\s+IS\s+UNIQUE/i);
                if (!match) throw new Error("Invalid CONSTRAINT syntax.");
                const [, variable, label, property] = match;
                const key = property.split('.')[1];
                const constraintKey = `${label}.${key}`;
                if (this.db.constraints.has(constraintKey)) {
                    throw new Error(`Constraint on :${label}(${key}) already exists.`);
                }
                this.db.constraints.set(constraintKey, new Set());
                if (nameMatch) this.db.constraintNames.set(nameMatch[1], constraintKey);
                return { type: 'db_manage', message: `Constraint created on :${label}(${key}).` };
            }

            _handleCreateIndex(query) {
                const match = query.match(/CREATE INDEX ON :(\w+)\((\w+)\)/i);
                if (!match) throw new Error("Invalid CREATE INDEX syntax. Use: CREATE INDEX ON :Label(property)");
                const [, label, property] = match;
                const indexKey = `${label}.${property}`;
                if (this.db.indexes.has(indexKey)) {
                    throw new Error(`Index on :${label}(${property}) already exists.`);
                }
                this.db.indexes.set(indexKey, new Map());
                return { type: 'db_manage', message: `Index created on :${label}(${property}).` };
            }

            _handleHelp(query) {
                const helpText = `
 Cypher Query Console - Available Commands:

 READING DATA:
  MATCH (n) RETURN n                    - Get all nodes
  MATCH (n:Label) RETURN n              - Get nodes by label
  MATCH (n {property: 'value'}) RETURN n - Get nodes by property
  MATCH (a)-[r]->(b) RETURN a, r, b     - Get relationships
  MATCH p = (a)-[*1..3]-(b) RETURN p    - Variable length paths

 CREATING DATA:
  CREATE (n:Person {name: 'Alice'})     - Create node with label and properties
  CREATE (a)-[:KNOWS]->(b)              - Create relationship
  MERGE (n:Person {name: 'Bob'})        - Find or create node

 UPDATING DATA:
  SET n.age = 30                        - Set property
  SET n:NewLabel                        - Add label
  REMOVE n.property                     - Remove property
  REMOVE n:Label                        - Remove label

 DELETING DATA:
  DELETE n                              - Delete node (must not have relationships)
  DETACH DELETE n                       - Delete node and all its relationships
  DELETE r                              - Delete relationship

 FILTERING & PROCESSING:
  WHERE n.age > 25                      - Filter results
  ORDER BY n.name ASC                   - Sort results
  LIMIT 10                              - Limit number of results
  WITH n.name AS name RETURN name       - Pipe results between clauses

 AGGREGATION:
  RETURN count(*)                       - Count results
  RETURN collect(n.name)                - Collect values into list
  UNWIND [1,2,3] AS x RETURN x         - Expand list into rows

 BUILT-IN FUNCTIONS:
  String: toUpper(), toLower(), split(), replace(), substring()
  Math: abs(), round(), sqrt(), rand()
  Collection: size(), head(), tail(), range()
    Path: shortestPath(), allShortestPaths()

 SCHEMA:
  CREATE CONSTRAINT ON (n:Label) ASSERT n.property IS UNIQUE
  CREATE INDEX ON :Label(property)
    DROP INDEX ON :Label(property)
    SHOW CONSTRAINTS
    SHOW STATS

 DATABASE:
  USE database_name                     - Switch database
  CALL db.labels()                      - List all labels
  CALL db.propertyKeys()                - List all properties

 TIPS:
  - Use () for nodes, [] for relationships
  - Relationships are always directed: -->
  - Use : for labels, {} for properties
  - Variables can be any name (n, node, person, etc.)
  - String values must be in single quotes: 'value'
`;
                return { type: 'help', message: helpText, result: [] };
            }

            _handleDropIndex(query) {
                const match = query.match(/DROP INDEX ON :(\w+)\((\w+)\)/i);
                if (!match) throw new Error("Invalid DROP INDEX syntax. Use: DROP INDEX ON :Label(property)");
                const [, label, property] = match;
                const indexKey = `${label}.${property}`;
                if (!this.db.indexes.has(indexKey)) {
                    throw new Error(`Index on :${label}(${property}) does not exist.`);
                }
                this.db.indexes.delete(indexKey);
                return { type: 'db_manage', message: `Index on :${label}(${property}) dropped.` };
            }

            _handleDropConstraint(query) {
                // Support both named and anonymous: DROP CONSTRAINT constraint_name OR by pattern
                // Here we support the simple pattern form: DROP CONSTRAINT ON (n:Label) ASSERT n.prop IS UNIQUE
                const byPattern = query.match(/DROP\s+CONSTRAINT\s+ON\s*\(\w+:(\w+)\)\s+ASSERT\s+\w+\.(\w+)\s+IS\s+UNIQUE/i);
                if (byPattern) {
                    const [, label, prop] = byPattern;
                    const key = `${label}.${prop}`;
                    if (!this.db.constraints.has(key)) throw new Error(`Constraint on :${label}(${prop}) does not exist.`);
                    this.db.constraints.delete(key);
                    return { type: 'db_manage', message: `Constraint on :${label}(${prop}) dropped.` };
                }
                // Named style (best-effort): DROP CONSTRAINT name
                const byName = query.match(/DROP\s+CONSTRAINT\s+(\w+)/i);
                if (byName) {
                    const name = byName[1];
                    const key = this.db.constraintNames.get(name);
                    if (key && this.db.constraints.has(key)) {
                        this.db.constraints.delete(key);
                        this.db.constraintNames.delete(name);
                        return { type: 'db_manage', message: `Constraint ${name} dropped.` };
                    }
                    throw new Error(`Constraint ${name} not found.`);
                }
                throw new Error('Invalid DROP CONSTRAINT syntax.');
            }

            _handleShow(query) {
                const upper = query.toUpperCase();
                if (upper.startsWith('SHOW CONSTRAINTS')) {
                    const rows = [];
                    this.db.constraints.forEach((_, key) => {
                        const [label, property] = key.split('.');
                        rows.push({ name: `${label}_${property}_unique`, type: 'UNIQUE', entityType: 'NODE', labelsOrTypes: [label], properties: [property] });
                    });
                    return { type: 'tabular', columns: ['name','type','entityType','labelsOrTypes','properties'], data: rows };
                }
                if (upper.startsWith('SHOW INDEXES')) {
                    const rows = [];
                    this.db.indexes.forEach((_, key) => {
                        const [label, property] = key.split('.');
                        rows.push({ entityType: 'NODE', labelsOrTypes: [label], properties: [property] });
                    });
                    return { type: 'tabular', columns: ['entityType','labelsOrTypes','properties'], data: rows };
                }
                if (upper.startsWith('SHOW STATS')) {
                    const labels = new Set();
                    this.db.nodes.forEach(n => n.labels.forEach(l => labels.add(l)));
                    const relTypes = new Set();
                    this.db.relationships.forEach(r => relTypes.add(r.type));
                    const nodeCount = this.db.nodes.size;
                    const relCount = this.db.relationships.size;
                    const avgDegree = nodeCount > 0 ? (relCount * 2) / nodeCount : 0;
                    const rows = [
                        { metric: 'nodes', value: nodeCount },
                        { metric: 'relationships', value: relCount },
                        { metric: 'labels', value: labels.size },
                        { metric: 'relationshipTypes', value: relTypes.size },
                        { metric: 'avgDegree', value: Number(avgDegree.toFixed(2)) },
                    ];
                    return { type: 'tabular', columns: ['metric','value'], data: rows };
                }
                if (upper.startsWith('SHOW DATABASES')) {
                    const rows = [];
                    this.dbManager.databases.forEach((_, name) => {
                        rows.push({ name, current: name === this.dbManager.currentDbName });
                    });
                    return { type: 'tabular', columns: ['name','current'], data: rows };
                }
                if (upper.startsWith('SHOW TRANSACTIONS')) {
                    // Minimal emulation: single-session transaction state
                    const rows = [];
                    if (this.inTransaction) {
                        rows.push({ id: 'tx-1', state: 'Active' });
                    }
                    return { type: 'tabular', columns: ['id','state'], data: rows };
                }
                throw new Error('Unsupported SHOW command. Supported: SHOW CONSTRAINTS, SHOW STATS');
            }

            _handleCall(query) {
                const procedureMatch = query.match(/CALL\s+(\w+(?:\.\w+)*)\((.*?)\)(?:\s+YIELD\s+(.*))?/i);
                if (!procedureMatch) throw new Error("Invalid CALL syntax.");
                
                const [, procedureName, argsStr, yieldFields] = procedureMatch;
                
                // Built-in procedures
                if (procedureName === 'db.labels') {
                    const labels = new Set();
                    this.db.nodes.forEach(node => node.labels.forEach(label => labels.add(label)));
                    return { type: 'tabular', columns: ['label'], data: Array.from(labels).map(label => ({ label })) };
                } else if (procedureName === 'db.relationshipTypes') {
                    const types = new Set();
                    this.db.relationships.forEach(rel => types.add(rel.type));
                    return { type: 'tabular', columns: ['relationshipType'], data: Array.from(types).map(type => ({ relationshipType: type })) };
                } else if (procedureName === 'db.propertyKeys') {
                    const keys = new Set();
                    this.db.nodes.forEach(node => Object.keys(node.properties).forEach(key => keys.add(key)));
                    this.db.relationships.forEach(rel => Object.keys(rel.properties).forEach(key => keys.add(key)));
                    return { type: 'tabular', columns: ['propertyKey'], data: Array.from(keys).map(key => ({ propertyKey: key })) };
                } else if (procedureName === 'db.schema') {
                    const schema = [];
                    this.db.constraints.forEach((value, key) => {
                        const [label, property] = key.split('.');
                        schema.push({ type: 'CONSTRAINT', description: `UNIQUE constraint on :${label}(${property})` });
                    });
                    this.db.indexes.forEach((value, key) => {
                        const [label, property] = key.split('.');
                        schema.push({ type: 'INDEX', description: `INDEX on :${label}(${property})` });
                    });
                    return { type: 'tabular', columns: ['type', 'description'], data: schema };
                } else if (procedureName === 'db.indexes') {
                    const rows = [];
                    this.db.indexes.forEach((value, key) => {
                        const [label, property] = key.split('.');
                        rows.push({ label, property });
                    });
                    return { type: 'tabular', columns: ['label','property'], data: rows };
                } else if (procedureName === 'db.constraints') {
                    const rows = [];
                    this.db.constraints.forEach((value, key) => {
                        const [label, property] = key.split('.');
                        rows.push({ type: 'UNIQUE', label, property });
                    });
                    return { type: 'tabular', columns: ['type','label','property'], data: rows };
                } else {
                    throw new Error(`Unknown procedure: ${procedureName}`);
                }
            }

            _handleForeach(query) {
                const match = query.match(/FOREACH\s*\(\s*(\w+)\s+IN\s+(.+?)\s*\|\s*(.+)\)$/i);
                if (!match) throw new Error("Invalid FOREACH syntax.");
                const [, variable, collectionExpr, body] = match;
                // Evaluate collection expression using RETURN for reuse of expression evaluator
                let listVal;
                try {
                    const r = this._handleReturnOnly(`RETURN ${collectionExpr}`);
                    listVal = r.data?.[0]?.[collectionExpr] ?? r.data?.[0]?.[Object.keys(r.data[0]||{})[0]];
                } catch {
                    listVal = null;
                }
                if (!Array.isArray(listVal)) throw new Error('FOREACH expects a list expression.');
                let count = 0;
                for (const item of listVal) {
                    // Replace occurrences of the variable when used as a value token (e.g., name: name)
                    const substituted = body.replace(new RegExp(`(:\\s*)${variable}(?=[,}\)\s]|$)`, 'g'), (m, p1) => `${p1}${JSON.stringify(item)}`)
                                           .replace(new RegExp(`\b${variable}\b`, 'g'), JSON.stringify(item));
                    const parts = substituted.split(/\s*;\s*/).filter(Boolean);
                    for (const part of parts) {
                        const res = this.executeQuery(part.trim());
                        if (res) count++;
                    }
                }
                return { type: 'tx_manage', message: 'FOREACH completed.' };
            }

            _handlePathFunctions(query) {
                // Enhanced shortestPath/allShortestPaths with type and hop bounds and directional arrows
                const isAll = /allShortestPaths\s*\(/i.test(query);
                const fnRe = isAll
                    ? /allShortestPaths\(\s*(\(.+?\)\s*<?-\s*\[.*?\]\s*-\>?\s*\(.+?\))\s*\)/i
                    : /shortestPath\(\s*(\(.+?\)\s*<?-\s*\[.*?\]\s*-\>?\s*\(.+?\))\s*\)/i;
                const m = query.match(fnRe);
                if (!m) throw new Error("Invalid path function syntax.");

                const pattern = m[1];
                // Split around the relationship pattern, honoring optional arrows
                const nodeParts = pattern.split(/<?-\s*\[.*?\]\s*-\>?/);
                if (nodeParts.length !== 2) throw new Error("Invalid pattern inside path function.");
                const startPattern = nodeParts[0].trim().replace(/^\(|\)$/g, '');
                const endPattern = nodeParts[1].trim().replace(/^\(|\)$/g, '');

                const relSpecMatch = pattern.match(/<?-\s*\[(\w*)?:?([^\]\s\*]*)?\s*(\*\d*(?:\.\.\d*)?)?\]\s*-\>?/i);
                const relTypes = relSpecMatch && relSpecMatch[2]
                    ? relSpecMatch[2].split('|').map(s => s.trim()).filter(Boolean)
                    : [];
                const lenSpec = relSpecMatch && relSpecMatch[3] ? relSpecMatch[3] : null;
                let minHops = 1, maxHops = Infinity;
                if (lenSpec) {
                    const cleaned = lenSpec.replace('*', '');
                    if (cleaned.includes('..')) {
                        const [a, b] = cleaned.split('..');
                        minHops = a ? parseInt(a) : 1;
                        maxHops = b ? parseInt(b) : Infinity;
                    } else {
                        minHops = cleaned ? parseInt(cleaned) : 1;
                        maxHops = minHops;
                    }
                }

                const dir = (pattern.includes('->') && !pattern.includes('<-')) ? 'out' : (pattern.includes('<-') && !pattern.includes('->')) ? 'in' : 'any';
                const startNodes = this._findNodesByPattern(startPattern);
                const endNodes = this._findNodesByPattern(endPattern);
                if (startNodes.length === 0 || endNodes.length === 0) {
                    return { type: 'tabular', columns: ['path'], data: [] };
                }
                const options = { relTypes, minHops, maxHops, dir };
                const rows = [];
                for (const s of startNodes) {
                    for (const e of endNodes) {
                        if (isAll) {
                            const paths = this._findAllShortestPaths(s.id, e.id, options);
                            for (const p of paths) rows.push({ path: this._formatPath(p) });
                        } else {
                            const p = this._findShortestPathFiltered(s.id, e.id, options);
                            if (p.length > 0) rows.push({ path: this._formatPath(p) });
                        }
                    }
                }
                return { type: 'tabular', columns: ['path'], data: rows };
            }

            _neighborsOf(nodeId, options) {
                const { relTypes = [], dir = 'any' } = options || {};
                const out = [];
                this.db.relationships.forEach(rel => {
                    if (rel.startNode === nodeId) {
                        if (relTypes.length > 0 && !relTypes.includes(rel.type)) return;
                        if (dir === 'in') return; // only incoming expected
                        out.push(rel.endNode);
                    } else if (rel.endNode === nodeId) {
                        if (relTypes.length > 0 && !relTypes.includes(rel.type)) return;
                        if (dir === 'out') return; // only outgoing expected
                        out.push(rel.startNode);
                    }
                });
                return out;
            }

            _findShortestPathFiltered(startId, endId, options) {
                if (startId === endId) return [startId];
                const { minHops = 1, maxHops = Infinity } = options || {};
                const visited = new Set([startId]);
                const queue = [[startId]];
                while (queue.length > 0) {
                    const path = queue.shift();
                    const currentId = path[path.length - 1];
                    if (path.length - 1 > maxHops) continue;
                    for (const nb of this._neighborsOf(currentId, options)) {
                        if (path.includes(nb)) continue;
                        const newPath = [...path, nb];
                        const hops = newPath.length - 1;
                        if (nb === endId && hops >= minHops && hops <= maxHops) {
                            return newPath;
                        }
                        if (!visited.has(nb)) {
                            visited.add(nb);
                            queue.push(newPath);
                        }
                    }
                }
                return [];
            }

            _findAllShortestPaths(startId, endId, options) {
                if (startId === endId) return [[startId]];
                const { minHops = 1, maxHops = Infinity } = options || {};
                const dist = new Map([[startId, 0]]);
                const q = [startId];
                while (q.length) {
                    const v = q.shift();
                    const d = dist.get(v);
                    if (d >= maxHops) continue;
                    for (const nb of this._neighborsOf(v, options)) {
                        if (!dist.has(nb)) {
                            dist.set(nb, d + 1);
                            q.push(nb);
                        }
                    }
                }
                const targetDist = dist.get(endId);
                if (targetDist === undefined || targetDist < minHops || targetDist > maxHops) return [];
                const results = [];
                const stack = [[startId, [startId]]];
                while (stack.length) {
                    const [v, path] = stack.pop();
                    if (v === endId && path.length - 1 === targetDist) {
                        results.push(path);
                        continue;
                    }
                    for (const nb of this._neighborsOf(v, options)) {
                        if (path.includes(nb)) continue;
                        if (dist.get(nb) === dist.get(v) + 1) {
                            stack.push([nb, [...path, nb]]);
                        }
                    }
                }
                return results;
            }

            _formatPath(nodeIds) {
                const segments = [];
                for (let i = 0; i < nodeIds.length - 1; i++) {
                    const start = this.db.nodes.get(nodeIds[i]);
                    const end = this.db.nodes.get(nodeIds[i + 1]);
                    const rel = this._findRelationshipBetween(nodeIds[i], nodeIds[i + 1]);
                    if (!rel) continue;
                    segments.push({
                        start: this._formatNodeForOutput(start),
                        relationship: this._formatRelForOutput(rel),
                        end: this._formatNodeForOutput(end)
                    });
                }
                const startNode = this.db.nodes.get(nodeIds[0]);
                const endNode = this.db.nodes.get(nodeIds[nodeIds.length - 1]);
                return { start: this._formatNodeForOutput(startNode), end: this._formatNodeForOutput(endNode), segments };
            }

            _findRelationshipBetween(startId, endId) {
                for (const rel of this.db.relationships.values()) {
                    if ((rel.startNode === startId && rel.endNode === endId) ||
                        (rel.startNode === endId && rel.endNode === startId)) {
                        return rel;
                    }
                }
                return null;
            }

            _findNodesByPattern(pattern) {
                // Simple pattern matching for shortestPath
                const labelMatch = pattern.match(/:(\w+)/);
                const propMatch = pattern.match(/\{([^}]+)\}/);
                
                const nodes = [];
                this.db.nodes.forEach(node => {
                    let matches = true;
                    
                    if (labelMatch && !node.labels.has(labelMatch[1])) {
                        matches = false;
                    }
                    
                    if (propMatch && matches) {
                        const propStr = propMatch[1];
                        const props = this._parseProperties(propStr);
                        for (const [key, value] of Object.entries(props)) {
                            if (node.properties[key] !== value) {
                                matches = false;
                                break;
                            }
                        }
                    }
                    
                    if (matches) nodes.push(node);
                });
                
                return nodes;
            }

            _formatNodeForOutput(node) { return { _id: node.id, _type: 'node', labels: Array.from(node.labels), properties: node.properties }; }
            _formatRelForOutput(rel) { return { _id: rel.id, _type: 'relationship', type: rel.type, startNode: rel.startNode, endNode: rel.endNode, properties: rel.properties }; }
        }

        // --- UI & APP LOGIC ---
    document.addEventListener('DOMContentLoaded', () => {
            const dbManager = new DatabaseManager();
            const executor = new CypherExecutor(dbManager);
            let simulation;
            let zoom;

            const paramEditor = document.getElementById('param-editor');
            // Initialize CodeMirror if available; otherwise provide a minimal shim to keep tests working
            let editor;
            try {
                if (window.CodeMirror && typeof window.CodeMirror.fromTextArea === 'function') {
                    editor = window.CodeMirror.fromTextArea(document.getElementById('command-editor'), {
                        mode: 'text/x-sql',
                        theme: 'material-darker',
                        lineNumbers: true,
                        lineWrapping: true,
                        autofocus: true
                    });
                }
            } catch (_) { /* ignore and fall back */ }
            if (!editor) {
                const ta = document.getElementById('command-editor');
                editor = {
                    setValue: (txt) => { ta.value = String(txt || ''); },
                    getValue: () => ta.value || '',
                    focus: () => { try { ta.focus(); } catch (_) {} },
                    setOption: () => {}
                };
            }
            // Expose editor for tests to programmatically set content
            window.editor = editor;
            paramEditor.value = '{\n  "actorName": "Tom Hanks"\n}';
            const consolePrompt = document.getElementById('console-prompt');
            const infoPanelContent = document.getElementById('info-panel-content');
            const exampleCategoriesContainer = document.getElementById('example-categories');
            const recenterBtn = document.getElementById('recenter-btn');

            const infoContent = `
                <div class="my-6 p-4 rounded-lg bg-gray-800/50 border border-gray-700">
                    <h3 class="text-lg font-semibold text-gray-200 mb-4 text-center">The Property Graph Model </h3>
                    <p class="text-sm text-gray-400 mb-4">Graph databases store data in a structure of nodes and relationships, which is highly intuitive for modeling complex, connected data.</p>
                    <div class="flex flex-col md:flex-row items-center justify-around gap-2 text-center mb-2">
                        <div class="flex flex-col items-center p-2">
                             <svg class="w-10 h-10 mb-2 text-sky-400" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="10"/>
                             </svg>
                            <h4 class="font-semibold text-gray-200">Nodes</h4>
                            <p class="text-xs text-gray-400">Entities with labels and properties</p>
                            <code class="text-xs text-gray-500 mt-1 block">(:Person {name: 'Tom'})</code>
                        </div>
                        <div class="text-gray-500 text-xl font-light hidden md:block"></div>
                        <div class="text-gray-500 text-xl font-light md:hidden"></div>
                        <div class="flex flex-col items-center p-2">
                            <svg class="w-10 h-10 mb-2 text-teal-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="6" cy="12" r="3" fill="currentColor"/>
                                <circle cx="18" cy="12" r="3" fill="currentColor"/>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m0 0l-3-3m3 3l-3 3"/>
                            </svg>
                            <h4 class="font-semibold text-gray-200">Relationships</h4>
                            <p class="text-xs text-gray-400">Directed connections with a type</p>
                             <code class="text-xs text-gray-500 mt-1 block">-[:ACTED_IN]-></code>
                        </div>
                    </div>
                </div>
                <div class="my-6 p-4 rounded-lg bg-gray-800/50 border border-gray-700">
                    <h3 class="text-lg font-semibold text-gray-200 mb-4 text-center">Cypher Syntax Primer</h3>
                    <ul class="text-sm space-y-2 text-gray-300 font-mono">
                        <li><span class="text-sky-400">(node)</span> - Represents a node.</li>
                        <li><span class="text-sky-400">(n:Person)</span> - A node with variable 'n' and label 'Person'.</li>
                        <li><span class="text-teal-400">-[:KNOWS]-></span> - A directed relationship of type KNOWS.</li>
                        <li><span class="text-teal-400">-[r]-</span> - An undirected relationship with variable 'r'.</li>
                        <li><span class="text-orange-400">{name: 'Alice'}</span> - Properties (key-value pairs).</li>
                    </ul>
                </div>
                <div class="my-6 p-4 rounded-lg bg-gray-800/50 border border-gray-700">
                    <h3 class="text-lg font-semibold text-gray-200 mb-4 text-center">When to Use a Graph Database? </h3>
                    <p class="text-sm text-gray-400 mb-4">Graph databases excel at managing and querying highly connected data. They shine when the **relationships between data points are as important as the data itself.**</p>
                    <ul class="text-sm list-disc pl-5 space-y-2 text-gray-300">
                        <li><b>Social Networks:</b> Finding friends-of-friends, mutual connections, and group affiliations.</li>
                        <li><b>Recommendation Engines:</b> "Customers who bought this also liked..." by analyzing paths between users and products.</li>
                        <li><b>Fraud Detection:</b> Identifying complex, non-obvious links between accounts, devices, and transactions.</li>
                        <li><b>Network & IT Operations:</b> Visualizing dependencies between servers, applications, and services to find points of failure.</li>
                        <li><b>Supply Chain & Logistics:</b> Tracking paths and dependencies from raw materials to final delivery.</li>
                    </ul>
                </div>
            `;
            infoPanelContent.innerHTML = infoContent;

            // Helper to strip numeric section icons (e.g., 1 2 3 ) from headings
            const stripNumberIcons = (s) => String(s).replace(/^(?:[0-9]\uFE0F?\u20E3|[1-9]\uFE0F?\u20E3|\u0030\uFE0F?\u20E3|\u0031\uFE0F?\u20E3|\u0032\uFE0F?\u20E3|\u0033\uFE0F?\u20E3|\u0034\uFE0F?\u20E3|\u0035\uFE0F?\u20E3|\u0036\uFE0F?\u20E3|\u0037\uFE0F?\u20E3|\u0038\uFE0F?\u20E3|\u0039\uFE0F?\u20E3|)\s*/,'').trim();

            // Self-contained Cypher reference examples with expected outputs
            const docExamples = [
                {
                    title: 'CREATE and MATCH a node',
                    description: 'Create a node and then return a property value.',
                    query: "CREATE (:DocN {name:'A'})\nMATCH (n:DocN {name:'A'}) RETURN n.name AS name",
                    expected: { data: [ { name: 'A' } ] }
                },
                {
                    title: 'Aggregation-only COUNT(*) baseline',
                    description: 'Aggregation-only RETURN yields one row; COUNT(*) counts rows (baseline is 1).',
                    query: "RETURN COUNT(*) AS c",
                    expected: { data: [ { c: 1 } ] }
                },
                {
                    title: 'CALL db.labels() lists labels',
                    description: 'Create labeled nodes and list labels via procedure.',
                    query: "CREATE (:LblA {x:1}), (:LblB {y:2})\nCALL db.labels()",
                    expected: { data: [ { label: 'LblA' }, { label: 'LblB' } ] }
                },
                {
                    title: 'CALL db.propertyKeys() lists property keys',
                    description: 'Property keys collected from nodes and relationships.',
                    query: "CREATE (a:PP {a:1})\nCREATE (a)-[:PR {b:2}]->(:PP2 {c:3})\nCALL db.propertyKeys()",
                    expected: { data: [ { propertyKey: 'a' }, { propertyKey: 'b' }, { propertyKey: 'c' } ] }
                },
                {
                    title: 'SHOW CONSTRAINTS after creation',
                    description: 'Create a uniqueness constraint and then list it.',
                    query: "CREATE CONSTRAINT uniq_pp ON (n:SC) ASSERT n.k IS UNIQUE\nSHOW CONSTRAINTS",
                    expected: { data: [ { name: 'SC_k_unique', type: 'UNIQUE', entityType: 'NODE', labelsOrTypes: ['SC'], properties: ['k'] } ] }
                },
                {
                    title: 'SHOW INDEXES after creation',
                    description: 'Create an index and then list indexes.',
                    query: "CREATE INDEX ON :SI(p)\nSHOW INDEXES",
                    expected: { data: [ { entityType: 'NODE', labelsOrTypes: ['SI'], properties: ['p'] } ] }
                },
                {
                    title: 'UNION removes duplicates by default',
                    description: 'UNION (without ALL) is distinct across rows.',
                    query: "RETURN 1 AS x UNION RETURN 1 AS x",
                    expected: { data: [ { x: 1 } ] }
                },
                {
                    title: 'Regex =~ with (?i) case-insensitive',
                    description: 'Filter strings using case-insensitive regex anchors.',
                    query: "UNWIND ['Alpha','beta'] AS s WITH s WHERE s =~ '(?i)^a' RETURN COUNT(*) AS c",
                    expected: { data: [ { c: 1 } ] }
                },
                {
                    title: 'List comprehension filter + map',
                    description: 'Produce a list from a list using WHERE and mapping expression.',
                    query: "RETURN [x IN [1,2,3] WHERE x>1 | x*2] AS out",
                    expected: { data: [ { out: [4,6] } ] }
                },
                {
                    title: 'COLLECT retains nulls; DISTINCT keeps one null',
                    description: 'COLLECT should include null; DISTINCT collapses to single null.',
                    query: "UNWIND [null,null,1] AS x RETURN COLLECT(x) AS all, COLLECT(DISTINCT x) AS distinct",
                    expected: { data: [ { all: [null,null,1], distinct: [null,1] } ] }
                },
                {
                    title: 'Variable-length zero-hop allowed',
                    description: 'When min hops is 0, start node can match end node immediately.',
                    query: "CREATE (:Zero {id:1})\nMATCH (a:Zero {id:1})-[:T*0..]->(a) RETURN COUNT(*) AS c",
                    expected: { data: [ { c: 1 } ] }
                },
                {
                    title: 'Inbound direction single-hop',
                    description: 'Reverse arrow matches incoming relationship direction.',
                    query: "CREATE (:Dir {id:1}), (:Dir {id:2})\nMATCH (a:Dir {id:1}), (b:Dir {id:2})\nCREATE (a)-[:R]->(b)\nMATCH (b:Dir {id:2})<-[:R]-(a:Dir {id:1}) RETURN COUNT(*) AS c",
                    expected: { data: [ { c: 1 } ] }
                },
                {
                    title: 'CREATE a relationship and TYPE()',
                    description: 'Create two nodes and a relationship between them, then return the relationship type.',
                    query: "CREATE (:DocA {id:1}), (:DocB {id:2})\nMATCH (a:DocA {id:1}), (b:DocB {id:2})\nCREATE (a)-[:DOC_REL]->(b)\nMATCH (a:DocA {id:1})-[r:DOC_REL]->(b:DocB {id:2}) RETURN TYPE(r) AS t",
                    expected: { data: [ { t: 'DOC_REL' } ] }
                },
                {
                    title: 'MERGE is idempotent',
                    description: 'MERGE twice creates a single node; verify with COUNT.',
                    query: "MERGE (:DocMerge {k:1})\nMERGE (:DocMerge {k:1})\nMATCH (p:DocMerge {k:1}) RETURN COUNT(p) AS c",
                    expected: { data: [ { c: 1 } ] }
                },
                {
                    title: 'SET and REMOVE properties',
                    description: 'Update a property and remove another, then return both to observe the changes.',
                    query: "CREATE (:DocProp {a:1, b:2})\nMATCH (n:DocProp {a:1}) SET n.b = 3 REMOVE n.a RETURN n.b AS b, n.a AS a",
                    expected: { data: [ { b: 3, a: null } ] }
                },
                {
                    title: 'UNWIND and SUM',
                    description: 'Turn a list into rows and aggregate them.',
                    query: "UNWIND [1,2,3] AS x RETURN SUM(x) AS s",
                    expected: { data: [ { s: 6 } ] }
                },
                {
                    title: 'WITH grouping + DISTINCT',
                    description: 'Group by value and count, then return distinct groups sorted.',
                    query: "UNWIND ['A','A','B'] AS d WITH d, COUNT(*) AS c RETURN DISTINCT d, c ORDER BY d",
                    expected: { data: [ { d: 'A', c: 2 }, { d: 'B', c: 1 } ] }
                },
                {
                    title: 'OPTIONAL MATCH and COALESCE',
                    description: 'OPTIONAL MATCH that does not find a row yields NULL, then COALESCE to default.',
                    query: "CREATE (:DocOpt {id:1})\nOPTIONAL MATCH (n:DocOpt {id:2}) RETURN COALESCE(n.id, 0) AS id",
                    expected: { data: [ { id: 0 } ] }
                },
                {
                    title: 'Variable-length path (1..2)',
                    description: 'Two hops path exists; return COUNT to confirm reachability.',
                    query: "CREATE (:DocVL {id:1}), (:DocVL {id:2}), (:DocVL {id:3})\nMATCH (a:DocVL {id:1}),(b:DocVL {id:2}),(c:DocVL {id:3})\nCREATE (a)-[:LV]->(b), (b)-[:LV]->(c)\nMATCH (a:DocVL {id:1})-[:LV*1..2]->(c:DocVL {id:3}) RETURN COUNT(*) AS c",
                    expected: { data: [ { c: 1 } ] }
                },
                {
                    title: 'Relationship type alternation',
                    description: 'Alternation matches either type LA or LB.',
                    query: "CREATE (:DocAlt {id:1}), (:DocAlt {id:2})\nMATCH (a:DocAlt {id:1}), (b:DocAlt {id:2})\nCREATE (a)-[:LA]->(b)\nMATCH (a:DocAlt {id:1})-[:LA|LB]->(b:DocAlt {id:2}) RETURN COUNT(*) AS c",
                    expected: { data: [ { c: 1 } ] }
                },
                {
                    title: 'String predicates in WHERE',
                    description: 'Use STARTS WITH to filter by prefix.',
                    query: "CREATE (:DocW {name:'Alpha'}), (:DocW {name:'Beta'})\nMATCH (n:DocW) WHERE n.name STARTS WITH 'A' RETURN COUNT(*) AS c",
                    expected: { data: [ { c: 1 } ] }
                },
                {
                    title: 'CASE expression',
                    description: 'Conditional branching inside RETURN.',
                    query: "RETURN CASE WHEN 1=1 THEN 'Y' ELSE 'N' END AS v",
                    expected: { data: [ { v: 'Y' } ] }
                },
                {
                    title: 'DETACH DELETE removes node and rels',
                    description: 'Create a node and delete it with DETACH; ensure none remain.',
                    query: "CREATE (:DocDel {k:1})\nMATCH (n:DocDel {k:1}) DETACH DELETE n\nMATCH (n:DocDel) RETURN COUNT(*) AS c",
                    expected: { data: [ { c: 0 } ] }
                }
            ];

            // Render verified, self-contained examples with automatic verification
            (function renderVerifiedExamples() {
                const container = document.createElement('div');
                container.className = 'space-y-4 mt-6';
                const header = document.createElement('h3');
                header.className = 'text-lg font-semibold text-gray-200';
                header.textContent = 'Cypher reference: verified examples';
                container.appendChild(header);

                const grid = document.createElement('div');
                grid.className = 'grid grid-cols-1 gap-4';
                container.appendChild(grid);

                // Deep equal helper
                const deepEqual = (a, b) => {
                    const ta = Object.prototype.toString.call(a);
                    const tb = Object.prototype.toString.call(b);
                    if (ta !== tb) return false;
                    if (['[object String]','[object Number]','[object Boolean]','[object Null]','[object Undefined]'].includes(ta)) return a === b;
                    if (ta === '[object Array]') {
                        if (a.length !== b.length) return false;
                        for (let i=0;i<a.length;i++) if (!deepEqual(a[i], b[i])) return false;
                        return true;
                    }
                    if (ta === '[object Object]') {
                        const ka = Object.keys(a).sort();
                        const kb = Object.keys(b).sort();
                        if (!deepEqual(ka, kb)) return false;
                        return ka.every(k => deepEqual(a[k], b[k]));
                    }
                    return JSON.stringify(a) === JSON.stringify(b);
                };

                const verifyExample = async (ex, statusEl) => {
                    // Run in isolated, throwaway DB so verification has zero side-effects
                    const localDb = new DatabaseManager();
                    const localExec = new CypherExecutor(localDb);
                    // Clean default DB
                    localDb.databases.set(localDb.currentDbName, { db: new GraphDB(), lastQueryResult: null });
                    localExec.db = localDb.getCurrentDb();
                    // Split into statements similar to console/runLines
                    const rawLines = String(ex.query).split('\n').map(s=>s.trim()).filter(s => s && !s.startsWith('--') && !s.startsWith('//'));
                    const statements = [];
                    for (let i=0;i<rawLines.length;i++) {
                        const line = rawLines[i];
                        const prev = statements.length ? statements[statements.length-1] : null;
                        if (prev && /^MATCH\b/i.test(prev) && /^CREATE\b/i.test(line)) {
                            statements[statements.length-1] = prev + ' ' + line; // merge MATCH with following CREATE
                        } else {
                            statements.push(line);
                        }
                    }
                    let last = null; let ok = true; let error = '';
                    for (const q of statements) {
                        try { last = localExec.executeQuery(q, {}); }
                        catch (e) { ok = false; error = String(e.message||e); break; }
                    }
                    if (!ok) {
                        statusEl.innerHTML = `<span class="text-pink-400">Failed</span><span class="text-gray-500 ml-2">${error}</span>`;
                        statusEl.dataset.verified = 'false';
                        return;
                    }
                    const actual = (last && (last.data || last.result)) ? { data: (last.data || last.result) } : { data: [] };
                    const passed = deepEqual(actual, ex.expected);
                    statusEl.innerHTML = passed
                        ? '<span class="text-emerald-400">Verified</span>'
                        : `<span class="text-yellow-400">Mismatch</span>`;
                    statusEl.dataset.verified = String(passed);
                    if (!passed) {
                        // Attach a simple toggle to show actual vs expected JSON
                        const pre = document.createElement('pre');
                        pre.className = 'bg-[#1e1e1e] p-2 rounded text-xs mt-2 overflow-auto custom-scrollbar';
                        pre.textContent = JSON.stringify({ expected: ex.expected, actual }, null, 2);
                        statusEl.parentElement.appendChild(pre);
                    }
                };

                docExamples.forEach(ex => {
                    const card = document.createElement('div');
                    card.className = 'w-full bg-gray-800/60 border border-gray-700 rounded-md p-3';
                    const title = document.createElement('div');
                    title.className = 'flex items-center justify-between';
                    title.innerHTML = `<p class="text-sm font-semibold text-gray-200">${ex.title}</p>`;
                    card.appendChild(title);

                    const desc = document.createElement('p');
                    desc.className = 'text-xs text-gray-400 mt-1';
                    desc.textContent = ex.description;
                    card.appendChild(desc);

                    const code = document.createElement('pre');
                    code.className = 'text-gray-300 font-mono text-xs overflow-x-auto custom-scrollbar mt-2';
                    const codeInner = document.createElement('code');
                    codeInner.textContent = ex.query;
                    code.appendChild(codeInner);
                    card.appendChild(code);

                    const actions = document.createElement('div');
                    actions.className = 'flex items-center justify-between mt-2';
                    const status = document.createElement('div');
                    status.className = 'text-xs';
                    status.innerHTML = '<span class="text-gray-400">Verifying</span>';
                    actions.appendChild(status);

                    const btns = document.createElement('div');
                    btns.className = 'flex gap-2';
                    const loadBtn = document.createElement('button');
                    loadBtn.className = 'bg-gray-700 hover:bg-gray-600 text-white font-semibold px-2 py-1 rounded-md text-xs';
                    loadBtn.textContent = 'Load in editor';
                    loadBtn.addEventListener('click', () => { editor.setValue(ex.query); editor.focus(); });
                    const reverifyBtn = document.createElement('button');
                    reverifyBtn.className = 'bg-gray-700 hover:bg-gray-600 text-white font-semibold px-2 py-1 rounded-md text-xs';
                    reverifyBtn.textContent = 'Re-run';
                    reverifyBtn.addEventListener('click', () => verifyExample(ex, status));
                    btns.appendChild(loadBtn);
                    btns.appendChild(reverifyBtn);
                    actions.appendChild(btns);
                    card.appendChild(actions);

                    grid.appendChild(card);
                    // Trigger verification after insertion, allow paint first
                    setTimeout(() => verifyExample(ex, status), 0);
                });

                // Insert before the big example catalog
                const infoPanel = document.getElementById('example-categories');
                if (infoPanel) infoPanel.parentNode.insertBefore(container, infoPanel);
                try { hljs.highlightAll(); } catch(_) {}
            })();

            // Neo4j Tutorial: Building a Knowledge Management System (click to run, not auto-verified)
            // Follow these examples in order to learn Cypher through a practical scenario
            const examples = {
                " Tutorial: Knowledge Management System": [
                    { title: " Neo4j Cypher Syntax Guide & Tutorial Introduction", query: "//  Welcome to Neo4j Cypher Tutorial!\n// Learn Neo4j by building a knowledge management system for a tech company\n\n//  CYPHER QUERY LANGUAGE SYNTAX:\n// Basic patterns: (node)-[relationship]->(node)\n// Examples:\n//   CREATE (p:Person {name: 'Alice', age: 30})\n//   MATCH (p:Person) WHERE p.age > 25 RETURN p\n//   MERGE (p:Person {name: 'Bob'})-[:WORKS_FOR]->(c:Company)\n//   DELETE p  or  DETACH DELETE p\n\n//  PATTERN MATCHING:\n// (n:Label {property: 'value'})     - Node with label and properties\n// [r:TYPE {property: 'value'}]      - Relationship with type and properties\n// (a)-[:KNOWS]->(b)                 - Directed relationship\n// (a)-[:KNOWS]-(b)                  - Undirected relationship\n// (a)-[:KNOWS*1..3]->(b)            - Variable length path\n\n//  CORE OPERATIONS:\n// CREATE: Create new nodes/relationships\n// MATCH:  Find existing patterns\n// MERGE:  Find or create (upsert)\n// SET:    Update properties\n// REMOVE: Remove properties/labels\n// DELETE: Remove nodes/relationships\n\n//  AGGREGATION & PROCESSING:\n// WITH:     Pipe results between query parts\n// COLLECT:  Aggregate values into lists\n// UNWIND:   Expand lists into rows\n// ORDER BY: Sort results\n// LIMIT:    Restrict number of results\n\n//  BUILT-IN FUNCTIONS:\n// String: substring(), replace(), split(), toLower()\n// Math: abs(), round(), sqrt(), rand()\n// Collection: size(), head(), tail(), range()\n// Date/Time: date(), datetime(), duration()\n\n//  BEST PRACTICES:\n// 1. Use labels to categorize nodes\n// 2. Create indexes for frequently queried properties\n// 3. Use MERGE for upsert operations\n// 4. Leverage relationship direction for performance\n// 5. Use WITH to break complex queries into steps\n\n// Let's start building our knowledge management system!" },
                ],

                "Company Structure - Creating Nodes": [
                    { title: "Create employees with their basic information", query: "CREATE (alice:Employee {name: 'Alice Johnson', department: 'Engineering', level: 'Senior', email: 'alice@company.com', hire_date: '2020-03-15'})\nCREATE (bob:Employee {name: 'Bob Smith', department: 'Engineering', level: 'Lead', email: 'bob@company.com', hire_date: '2018-07-20'})\nCREATE (charlie:Employee {name: 'Charlie Brown', department: 'Data Science', level: 'Senior', email: 'charlie@company.com', hire_date: '2019-11-10'})" },
                    { title: "Create more employees across different departments", query: "CREATE (diana:Employee {name: 'Diana Prince', department: 'Product', level: 'Manager', email: 'diana@company.com', hire_date: '2017-02-01'})\nCREATE (eve:Employee {name: 'Eve Wilson', department: 'Design', level: 'Senior', email: 'eve@company.com', hire_date: '2021-01-20'})\nCREATE (frank:Employee {name: 'Frank Miller', department: 'Engineering', level: 'Junior', email: 'frank@company.com', hire_date: '2023-06-15'})" },
                    { title: "Create technology and skill nodes", query: "CREATE (python:Technology {name: 'Python', category: 'Programming Language'})\nCREATE (react:Technology {name: 'React', category: 'Frontend Framework'})\nCREATE (postgres:Technology {name: 'PostgreSQL', category: 'Database'})\nCREATE (aws:Technology {name: 'AWS', category: 'Cloud Platform'})\nCREATE (ml:Skill {name: 'Machine Learning', category: 'Data Science'})\nCREATE (leadership:Skill {name: 'Leadership', category: 'Management'})" },
                    { title: "View all employees we created", query: "MATCH (e:Employee) \nRETURN e.name, e.department, e.level \nORDER BY e.hire_date" },
                ],

                "Creating Relationships - Company Hierarchy": [
                    { title: "Create reporting relationships (manager hierarchy)", query: "MATCH (bob:Employee {name: 'Bob Smith'}), (alice:Employee {name: 'Alice Johnson'})\nCREATE (alice)-[:REPORTS_TO]->(bob)\n\nMATCH (bob:Employee {name: 'Bob Smith'}), (frank:Employee {name: 'Frank Miller'})\nCREATE (frank)-[:REPORTS_TO]->(bob)\n\nMATCH (diana:Employee {name: 'Diana Prince'}), (eve:Employee {name: 'Eve Wilson'})\nCREATE (eve)-[:REPORTS_TO]->(diana)" },
                    { title: "Create skill relationships", query: "MATCH (alice:Employee {name: 'Alice Johnson'}), (python:Technology {name: 'Python'})\nCREATE (alice)-[:SKILLED_IN {level: 'Expert', years: 5}]->(python)\n\nMATCH (alice:Employee {name: 'Alice Johnson'}), (react:Technology {name: 'React'})\nCREATE (alice)-[:SKILLED_IN {level: 'Advanced', years: 3}]->(react)\n\nMATCH (charlie:Employee {name: 'Charlie Brown'}), (python:Technology {name: 'Python'})\nCREATE (charlie)-[:SKILLED_IN {level: 'Expert', years: 4}]->(python)\n\nMATCH (charlie:Employee {name: 'Charlie Brown'}), (ml:Skill {name: 'Machine Learning'})\nCREATE (charlie)-[:SKILLED_IN {level: 'Expert', years: 6}]->(ml)" },
                    { title: "Create collaboration relationships", query: "MATCH (alice:Employee {name: 'Alice Johnson'}), (charlie:Employee {name: 'Charlie Brown'})\nCREATE (alice)-[:COLLABORATES_WITH {project: 'ML Platform', since: '2023-01-15'}]->(charlie)\n\nMATCH (eve:Employee {name: 'Eve Wilson'}), (diana:Employee {name: 'Diana Prince'})\nCREATE (eve)-[:COLLABORATES_WITH {project: 'Product Redesign', since: '2023-03-01'}]->(diana)" },
                    { title: "View the company structure", query: "MATCH (e1:Employee)-[r:REPORTS_TO]->(e2:Employee)\nRETURN e1.name + ' reports to ' + e2.name AS hierarchy" },
                ],

                "Projects & Knowledge - Complex Data Modeling": [
                    { title: "Create project nodes with details", query: "CREATE (mlp:Project {name: 'ML Platform', status: 'In Progress', start_date: '2023-01-15', budget: 500000, description: 'AI/ML platform for company-wide use'})\nCREATE (redesign:Project {name: 'Product Redesign', status: 'Planning', start_date: '2023-03-01', budget: 300000, description: 'Complete UI/UX overhaul'})\nCREATE (migration:Project {name: 'Cloud Migration', status: 'Completed', start_date: '2022-06-01', end_date: '2023-01-30', budget: 800000, description: 'Migrate infrastructure to AWS'})" },
                    { title: "Connect employees to projects", query: "MATCH (alice:Employee {name: 'Alice Johnson'}), (mlp:Project {name: 'ML Platform'})\nCREATE (alice)-[:WORKS_ON {role: 'Technical Lead', allocation: 80}]->(mlp)\n\nMATCH (charlie:Employee {name: 'Charlie Brown'}), (mlp:Project {name: 'ML Platform'})\nCREATE (charlie)-[:WORKS_ON {role: 'Data Scientist', allocation: 100}]->(mlp)\n\nMATCH (eve:Employee {name: 'Eve Wilson'}), (redesign:Project {name: 'Product Redesign'})\nCREATE (eve)-[:WORKS_ON {role: 'Lead Designer', allocation: 90}]->(redesign)\n\nMATCH (diana:Employee {name: 'Diana Prince'}), (redesign:Project {name: 'Product Redesign'})\nCREATE (diana)-[:WORKS_ON {role: 'Product Manager', allocation: 60}]->(redesign)" },
                    { title: "Create knowledge documents", query: "CREATE (doc1:Document {title: 'Python Best Practices', type: 'Guide', created_date: '2023-02-15', author: 'Alice Johnson', tags: ['python', 'coding', 'standards']})\nCREATE (doc2:Document {title: 'ML Model Deployment Guide', type: 'Tutorial', created_date: '2023-04-10', author: 'Charlie Brown', tags: ['ml', 'deployment', 'aws']})\nCREATE (doc3:Document {title: 'Design System Documentation', type: 'Specification', created_date: '2023-03-20', author: 'Eve Wilson', tags: ['design', 'ui', 'components']})" },
                    { title: "Connect documents to authors and technologies", query: "MATCH (alice:Employee {name: 'Alice Johnson'}), (doc1:Document {title: 'Python Best Practices'})\nCREATE (alice)-[:AUTHORED]->(doc1)\n\nMATCH (doc1:Document {title: 'Python Best Practices'}), (python:Technology {name: 'Python'})\nCREATE (doc1)-[:ABOUT]->(python)\n\nMATCH (charlie:Employee {name: 'Charlie Brown'}), (doc2:Document {title: 'ML Model Deployment Guide'})\nCREATE (charlie)-[:AUTHORED]->(doc2)\n\nMATCH (doc2:Document {title: 'ML Model Deployment Guide'}), (ml:Skill {name: 'Machine Learning'}), (aws:Technology {name: 'AWS'})\nCREATE (doc2)-[:ABOUT]->(ml)\nCREATE (doc2)-[:ABOUT]->(aws)" },
                ],

                "Basic Querying - Finding Information": [
                    { title: "Find all employees in Engineering department", query: "MATCH (e:Employee {department: 'Engineering'}) \nRETURN e.name, e.level, e.hire_date \nORDER BY e.hire_date" },
                    { title: "Find employees who know Python", query: "MATCH (e:Employee)-[:SKILLED_IN]->(t:Technology {name: 'Python'}) \nRETURN e.name, e.department" },
                    { title: "Find all active projects", query: "MATCH (p:Project) \nWHERE p.status = 'In Progress' OR p.status = 'Planning' \nRETURN p.name, p.status, p.budget \nORDER BY p.budget DESC" },
                    { title: "Find documents created in 2023", query: "MATCH (d:Document) \nWHERE d.created_date >= '2023-01-01' \nRETURN d.title, d.author, d.created_date \nORDER BY d.created_date DESC" },
                ],

                "Advanced Patterns - Multi-hop Relationships": [
                    { title: "Find who reports to Bob (direct reports)", query: "MATCH (employee:Employee)-[:REPORTS_TO]->(bob:Employee {name: 'Bob Smith'}) \nRETURN employee.name + ' reports to ' + bob.name AS reporting_structure" },
                    { title: "Find all people in Bob's team (including indirect reports)", query: "MATCH (bob:Employee {name: 'Bob Smith'})<-[:REPORTS_TO*1..3]-(team_member:Employee) \nRETURN team_member.name, team_member.level \nORDER BY team_member.name" },
                    { title: "Find collaborators of collaborators (2nd degree connections)", query: "MATCH (alice:Employee {name: 'Alice Johnson'})-[:COLLABORATES_WITH*2]-(connection:Employee) \nRETURN DISTINCT connection.name, connection.department" },
                    { title: "Find technology experts through skill relationships", query: "MATCH (e:Employee)-[s:SKILLED_IN]->(t:Technology) \nWHERE s.level = 'Expert' \nRETURN t.name AS technology, COLLECT(e.name) AS experts" },
                ],

                "Aggregation & Analytics": [
                    { title: "Count employees by department", query: "MATCH (e:Employee) \nRETURN e.department, COUNT(e) AS employee_count \nORDER BY employee_count DESC" },
                    { title: "Calculate average project budget", query: "MATCH (p:Project) \nRETURN AVG(p.budget) AS avg_budget, \n       MIN(p.budget) AS min_budget, \n       MAX(p.budget) AS max_budget" },
                    { title: "Find most skilled employees (by number of skills)", query: "MATCH (e:Employee)-[:SKILLED_IN]->() \nRETURN e.name, e.department, COUNT(*) AS skill_count \nORDER BY skill_count DESC" },
                    { title: "Technology popularity analysis", query: "MATCH (t:Technology)<-[:SKILLED_IN]-(e:Employee) \nRETURN t.name, t.category, COUNT(e) AS expert_count \nORDER BY expert_count DESC" },
                ],

                "Using WITH for Complex Queries": [
                    { title: "Find the most experienced employee per department", query: "MATCH (e:Employee) \nWITH e.department AS dept, e \nORDER BY e.hire_date \nWITH dept, HEAD(COLLECT(e)) AS senior_employee \nRETURN dept, senior_employee.name, senior_employee.hire_date" },
                    { title: "Find employees working on high-budget projects", query: "MATCH (p:Project) \nWHERE p.budget > 400000 \nWITH p \nMATCH (e:Employee)-[:WORKS_ON]->(p) \nRETURN e.name, p.name, p.budget \nORDER BY p.budget DESC" },
                    { title: "Find knowledge authors and their expertise", query: "MATCH (e:Employee)-[:AUTHORED]->(d:Document) \nWITH e, COUNT(d) AS doc_count \nWHERE doc_count > 0 \nMATCH (e)-[:SKILLED_IN]->(tech) \nRETURN e.name, doc_count, COLLECT(tech.name) AS technologies" },
                ],

                "MERGE & Data Management": [
                    { title: "Add new employee using MERGE (creates if not exists)", query: "MERGE (grace:Employee {name: 'Grace Hopper', email: 'grace@company.com'}) \nON CREATE SET grace.department = 'Engineering', \n              grace.level = 'Principal', \n              grace.hire_date = '2024-01-15' \nON MATCH SET grace.last_updated = timestamp()" },
                    { title: "Ensure technology relationships exist", query: "MATCH (grace:Employee {name: 'Grace Hopper'}) \nMERGE (cobol:Technology {name: 'COBOL', category: 'Programming Language'}) \nMATCH (grace:Employee {name: 'Grace Hopper'}), (cobol:Technology {name: 'COBOL'}) \nCREATE (grace)-[:SKILLED_IN {level: 'Expert', years: 30}]->(cobol)" },
                    { title: "Add project dependency relationships", query: "MERGE (infra:Project {name: 'Infrastructure Upgrade', status: 'Planning'}) \nMATCH (mlp:Project {name: 'ML Platform'}), (infra:Project {name: 'Infrastructure Upgrade'}) \nMERGE (mlp)-[:DEPENDS_ON]->(infra)" },
                ],

                "UNWIND & List Processing": [
                    { title: "Create multiple technologies from a list", query: "UNWIND ['Docker', 'Kubernetes', 'Terraform', 'Git'] AS tech_name \nMERGE (t:Technology {name: tech_name}) \nON CREATE SET t.category = CASE tech_name \n  WHEN 'Docker' THEN 'Containerization'\n  WHEN 'Kubernetes' THEN 'Orchestration'\n  WHEN 'Terraform' THEN 'Infrastructure'\n  WHEN 'Git' THEN 'Version Control'\nEND" },
                    { title: "Add skills to employees from arrays", query: "MATCH (frank:Employee {name: 'Frank Miller'}) \nUNWIND ['Docker', 'Git'] AS skill_name \nMATCH (t:Technology {name: skill_name}) \nMERGE (frank)-[:SKILLED_IN {level: 'Intermediate', years: 1}]->(t)" },
                    { title: "Create team assignments", query: "MATCH (mlp:Project {name: 'ML Platform'}) \nUNWIND ['Alice Johnson', 'Charlie Brown', 'Frank Miller'] AS member_name \nMATCH (e:Employee {name: member_name}) \nCREATE (e)-[:WORKS_ON]->(mlp)" },
                ],

                "Advanced Functions & String Operations": [
                    { title: "Find employees with names containing specific patterns", query: "MATCH (e:Employee) \nWHERE e.name CONTAINS 'son' OR e.name ENDS WITH 'Brown' \nRETURN e.name, e.department" },
                    { title: "Extract and format hire year information", query: "MATCH (e:Employee) \nRETURN e.name, \n       e.hire_date, \n       TOINT(SUBSTRING(e.hire_date, 0, 4)) AS hire_year,\n       CASE \n         WHEN TOINT(SUBSTRING(e.hire_date, 0, 4)) < 2020 THEN 'Veteran'\n         ELSE 'Recent Hire'\n       END AS employee_type \nORDER BY hire_year" },
                    { title: "Calculate experience and group employees", query: "MATCH (e:Employee) \nWITH e, \n     TOINT(SUBSTRING(DATE(), 0, 4)) - TOINT(SUBSTRING(e.hire_date, 0, 4)) AS years_experience \nRETURN e.name, \n       years_experience,\n       CASE \n         WHEN years_experience >= 5 THEN 'Senior'\n         WHEN years_experience >= 2 THEN 'Mid-level'\n         ELSE 'Junior'\n       END AS experience_level \nORDER BY years_experience DESC" },
                ],

                " Path Finding & Graph Algorithms": [
                    { title: "Find a short path between employees", query: "MATCH p = (alice:Employee {name: 'Alice Johnson'})-[*1..5]-(eve:Employee {name: 'Eve Wilson'}) \nRETURN nodes(p) AS path_nodes, length(p) AS path_length \nLIMIT 1" },
                    { title: "Use shortestPath() between two employees", query: "// Ensure some path exists\nMATCH (a:Employee {name: 'Alice Johnson'}), (e:Employee {name: 'Eve Wilson'})\nRETURN shortestPath((a)-[*1..5]-(e)) AS path" },
                    { title: "Use allShortestPaths() for multiple paths", query: "MATCH (a:Employee {name: 'Alice Johnson'}), (c:Employee {name: 'Charlie Brown'})\nRETURN allShortestPaths((a)-[*1..5]-(c)) AS paths" },
                    { title: "Find paths between technologies (3 hops)", query: "MATCH p = (python:Technology {name: 'Python'})-[*1..3]-(aws:Technology {name: 'AWS'}) \nRETURN nodes(p) AS connection_path \nLIMIT 5" },
                    { title: "Find knowledge flow (who can teach what to whom)", query: "MATCH (teacher:Employee)-[:SKILLED_IN {level: 'Expert'}]->(tech:Technology)<-[:SKILLED_IN]-(student:Employee) \nWHERE teacher.name <> student.name \nRETURN teacher.name AS teacher, \n       tech.name AS technology, \n       COLLECT(student.name) AS potential_students" },
                ],

                " Administration & Schema Insights": [
                    { title: "Show databases and current", query: "SHOW DATABASES" },
                    { title: "Show constraints", query: "SHOW CONSTRAINTS" },
                    { title: "Show indexes", query: "SHOW INDEXES" },
                    { title: "Show basic stats", query: "SHOW STATS" },
                    { title: "Show transactions (after BEGIN)", query: "BEGIN\nSHOW TRANSACTIONS" },
                ],

                " Complex Analytics Queries": [
                    { title: "Department collaboration analysis", query: "MATCH (e1:Employee)-[:COLLABORATES_WITH]-(e2:Employee) \nRETURN e1.department + ' <-> ' + e2.department AS collaboration, \n       COUNT(*) AS collaboration_count \nORDER BY collaboration_count DESC" },
                    { title: "Project resource allocation report", query: "MATCH (p:Project)<-[w:WORKS_ON]-(e:Employee) \nWITH p, \n     SUM(w.allocation) AS total_allocation, \n     COUNT(e) AS team_size, \n     COLLECT({name: e.name, role: w.role, allocation: w.allocation}) AS team_details \nRETURN p.name, \n       p.budget, \n       team_size, \n       total_allocation, \n       team_details \nORDER BY p.budget DESC" },
                    { title: "Knowledge gap analysis", query: "MATCH (p:Project)<-[:WORKS_ON]-(e:Employee) \nMATCH (p)-[:REQUIRES]->(required_tech:Technology) \nOPTIONAL MATCH (e)-[:SKILLED_IN]->(required_tech) \nWITH p, required_tech, \n     COUNT(e) AS total_team_members, \n     COUNT(CASE WHEN required_tech IS NOT NULL THEN 1 END) AS skilled_members \nRETURN p.name AS project, \n       required_tech.name AS technology, \n       skilled_members + '/' + total_team_members AS coverage" },
                ],

                " Data Updates & Modifications": [
                    { title: "Update employee information", query: "MATCH (frank:Employee {name: 'Frank Miller'}) \nSET frank.level = 'Mid-level', \n    frank.last_promotion = date() \nRETURN frank.name, frank.level, frank.last_promotion" },
                    { title: "Add properties to relationships", query: "MATCH (alice:Employee {name: 'Alice Johnson'})-[r:SKILLED_IN]->(python:Technology {name: 'Python'}) \nSET r.certification = 'Python Institute PCAP', \n    r.last_used = date() \nRETURN alice.name, python.name, r.certification" },
                    { title: "Mark project as completed", query: "MATCH (p:Project {name: 'Product Redesign'}) \nSET p.status = 'Completed', \n    p.end_date = '2024-01-15', \n    p.final_budget = 280000 \nRETURN p.name, p.status, p.final_budget" },
                ],

                " Cleanup & Node Management": [
                    { title: "Remove unused relationships", query: "MATCH (e:Employee {name: 'Frank Miller'})-[r:WORKS_ON]->(p:Project {name: 'Cloud Migration'}) \nDELETE r" },
                    { title: "Remove properties from nodes", query: "MATCH (e:Employee) \nREMOVE e.last_updated \nRETURN COUNT(e) AS updated_employees" },
                    { title: "Delete nodes with their relationships", query: "CREATE (:TempNode {name: 'Temporary'}) \nMATCH (temp:TempNode {name: 'Temporary'}) \nDETACH DELETE temp" },
                ],

                " Schema & Constraints": [
                    { title: "Create uniqueness constraint", query: "CREATE CONSTRAINT employee_email_unique \nON (e:Employee) \nASSERT e.email IS UNIQUE" },
                    { title: "Create project name uniqueness constraint", query: "CREATE CONSTRAINT project_name_unique \nON (p:Project) \nASSERT p.name IS UNIQUE" },
                    { title: "Show schema (constraints/indexes)", query: "CALL db.schema()" },
                    { title: "Create index for performance", query: "CREATE INDEX ON :Employee(department)" },
                    { title: "SHOW CONSTRAINTS", query: "SHOW CONSTRAINTS" },
                    { title: "SHOW STATS (summary)", query: "SHOW STATS" },
                ],

                " Common Error Examples": [
                    { title: "Missing MATCH before CREATE relationship", query: "CREATE (alice)-[:WORKS_WITH]->(bob)" },
                    { title: "Incorrect syntax for property update", query: "MATCH (e:Employee) SET e.name = 'Updated' WHERE e.name = 'Alice Johnson'" },
                    { title: "Invalid aggregation without grouping", query: "MATCH (e:Employee) RETURN e.name, COUNT(*)" },
                    { title: "Using undefined variable", query: "MATCH (e:Employee) RETURN e.name, p.name" },
                ],

                " Core Cypher Semantics (Mini)": [
                    { title: "Multiple relationship types alternation", query: "MATCH (a)-[:REPORTS_TO|:COLLABORATES_WITH]->(b) RETURN a,b LIMIT 5" },
                    { title: "Multi-label nodes creation and match", query: "CREATE (:Person:Employee {name: 'MultiLabelUser'})\nMATCH (n:Person:Employee {name: 'MultiLabelUser'}) RETURN n" },
                    { title: "Relationship property filter", query: "MATCH (e:Employee)-[r:SKILLED_IN {level: 'Expert'}]->(t:Technology) RETURN e.name, t.name, r.level LIMIT 5" },
                    { title: "Undirected vs Directed match", query: "// Directed: reports to\nMATCH (a:Employee)-[:REPORTS_TO]->(b:Employee) RETURN a.name AS emp, b.name AS manager LIMIT 3\n// Undirected: any connection\nMATCH (x:Employee)-[:COLLABORATES_WITH]-(y:Employee) RETURN x.name, y.name LIMIT 3" },
                ],

                " CREATE vs MERGE Behavior Examples": [
                    { title: "CREATE allows duplicates (creates multiple nodes with same properties)", query: "CREATE (person:Person {name: 'John', age: 30})\nCREATE (person:Person {name: 'John', age: 30})\nMATCH (p:Person {name: 'John'}) RETURN COUNT(p) AS john_count" },
                    { title: "MERGE creates only if doesn't exist (idempotent)", query: "MERGE (person:Person {name: 'Jane', age: 25})\nMERGE (person:Person {name: 'Jane', age: 25})\nMATCH (p:Person {name: 'Jane'}) RETURN COUNT(p) AS jane_count" },
                    { title: "CREATE with constraints will fail on duplicates", query: "CREATE CONSTRAINT person_email_unique ON (p:Person) ASSERT p.email IS UNIQUE\nCREATE (p1:Person {email: 'test@example.com'})\nCREATE (p2:Person {email: 'test@example.com'})" },
                    { title: "MERGE with ON CREATE and ON MATCH clauses", query: "MERGE (u:User {id: 'user123'})\nON CREATE SET u.created = timestamp(), u.login_count = 1\nON MATCH SET u.last_login = timestamp(), u.login_count = u.login_count + 1\nRETURN u" },
                ],
            };
            
            Object.entries(examples).forEach(([category, queries]) => {
                // Insert a small toolbar above the catalog (once)
                if (!document.getElementById('tutorial-toolbar')) {
                    const toolbar = document.createElement('div');
                    toolbar.id = 'tutorial-toolbar';
                    toolbar.className = 'mb-4 flex items-center justify-between';
                    const title = document.createElement('h3');
                    title.className = 'text-lg font-semibold text-gray-200';
                    title.textContent = 'Tutorial examples';
                    const seedBtn = document.createElement('button');
                    seedBtn.className = 'bg-sky-600 hover:bg-sky-700 text-white font-semibold px-3 py-1.5 rounded-md text-sm';
                    seedBtn.textContent = 'Reset & Seed tutorial data';
                    seedBtn.addEventListener('click', async () => {
                        try {
                            window.__graphTest.reset();
                            const seed = [
                                // Company Structure - Creating Nodes
                                "CREATE (alice:Employee {name: 'Alice Johnson', department: 'Engineering', level: 'Senior', email: 'alice@company.com', hire_date: '2020-03-15'})",
                                "CREATE (bob:Employee {name: 'Bob Smith', department: 'Engineering', level: 'Lead', email: 'bob@company.com', hire_date: '2018-07-20'})",
                                "CREATE (charlie:Employee {name: 'Charlie Brown', department: 'Data Science', level: 'Senior', email: 'charlie@company.com', hire_date: '2019-11-10'})",
                                "CREATE (diana:Employee {name: 'Diana Prince', department: 'Product', level: 'Manager', email: 'diana@company.com', hire_date: '2017-02-01'})",
                                "CREATE (eve:Employee {name: 'Eve Wilson', department: 'Design', level: 'Senior', email: 'eve@company.com', hire_date: '2021-01-20'})",
                                "CREATE (frank:Employee {name: 'Frank Miller', department: 'Engineering', level: 'Junior', email: 'frank@company.com', hire_date: '2023-06-15'})",
                                "CREATE (python:Technology {name: 'Python', category: 'Programming Language'})",
                                "CREATE (react:Technology {name: 'React', category: 'Frontend Framework'})",
                                "CREATE (postgres:Technology {name: 'PostgreSQL', category: 'Database'})",
                                "CREATE (aws:Technology {name: 'AWS', category: 'Cloud Platform'})",
                                "CREATE (ml:Skill {name: 'Machine Learning', category: 'Data Science'})",
                                "CREATE (leadership:Skill {name: 'Leadership', category: 'Management'})",
                                // Creating Relationships - Company Hierarchy
                                "MATCH (bob:Employee {name: 'Bob Smith'}), (alice:Employee {name: 'Alice Johnson'})",
                                "CREATE (alice)-[:REPORTS_TO]->(bob)",
                                "MATCH (bob:Employee {name: 'Bob Smith'}), (frank:Employee {name: 'Frank Miller'})",
                                "CREATE (frank)-[:REPORTS_TO]->(bob)",
                                "MATCH (diana:Employee {name: 'Diana Prince'}), (eve:Employee {name: 'Eve Wilson'})",
                                "CREATE (eve)-[:REPORTS_TO]->(diana)",
                                "MATCH (alice:Employee {name: 'Alice Johnson'}), (python:Technology {name: 'Python'})",
                                "CREATE (alice)-[:SKILLED_IN {level: 'Expert', years: 5}]->(python)",
                                "MATCH (alice:Employee {name: 'Alice Johnson'}), (react:Technology {name: 'React'})",
                                "CREATE (alice)-[:SKILLED_IN {level: 'Advanced', years: 3}]->(react)",
                                "MATCH (charlie:Employee {name: 'Charlie Brown'}), (python:Technology {name: 'Python'})",
                                "CREATE (charlie)-[:SKILLED_IN {level: 'Expert', years: 4}]->(python)",
                                "MATCH (charlie:Employee {name: 'Charlie Brown'}), (ml:Skill {name: 'Machine Learning'})",
                                "CREATE (charlie)-[:SKILLED_IN {level: 'Expert', years: 6}]->(ml)",
                                // Collaboration
                                "MATCH (alice:Employee {name: 'Alice Johnson'}), (charlie:Employee {name: 'Charlie Brown'})",
                                "CREATE (alice)-[:COLLABORATES_WITH {project: 'ML Platform', since: '2023-01-15'}]->(charlie)",
                                "MATCH (eve:Employee {name: 'Eve Wilson'}), (diana:Employee {name: 'Diana Prince'})",
                                "CREATE (eve)-[:COLLABORATES_WITH {project: 'Product Redesign', since: '2023-03-01'}]->(diana)",
                                // Projects & Knowledge
                                "CREATE (mlp:Project {name: 'ML Platform', status: 'In Progress', start_date: '2023-01-15', budget: 500000, description: 'AI/ML platform for company-wide use'})",
                                "CREATE (redesign:Project {name: 'Product Redesign', status: 'Planning', start_date: '2023-03-01', budget: 300000, description: 'Complete UI/UX overhaul'})",
                                "CREATE (migration:Project {name: 'Cloud Migration', status: 'Completed', start_date: '2022-06-01', end_date: '2023-01-30', budget: 800000, description: 'Migrate infrastructure to AWS'})",
                                "MATCH (alice:Employee {name: 'Alice Johnson'}), (mlp:Project {name: 'ML Platform'})",
                                "CREATE (alice)-[:WORKS_ON {role: 'Technical Lead', allocation: 80}]->(mlp)",
                                "MATCH (charlie:Employee {name: 'Charlie Brown'}), (mlp:Project {name: 'ML Platform'})",
                                "CREATE (charlie)-[:WORKS_ON {role: 'Data Scientist', allocation: 100}]->(mlp)",
                                "MATCH (eve:Employee {name: 'Eve Wilson'}), (redesign:Project {name: 'Product Redesign'})",
                                "CREATE (eve)-[:WORKS_ON {role: 'Lead Designer', allocation: 90}]->(redesign)",
                                "MATCH (diana:Employee {name: 'Diana Prince'}), (redesign:Project {name: 'Product Redesign'})",
                                "CREATE (diana)-[:WORKS_ON {role: 'Product Manager', allocation: 60}]->(redesign)",
                                // Documents and ABOUT
                                "CREATE (doc1:Document {title: 'Python Best Practices', type: 'Guide', created_date: '2023-02-15', author: 'Alice Johnson', tags: ['python', 'coding', 'standards']})",
                                "CREATE (doc2:Document {title: 'ML Model Deployment Guide', type: 'Tutorial', created_date: '2023-04-10', author: 'Charlie Brown', tags: ['ml', 'deployment', 'aws']})",
                                "CREATE (doc3:Document {title: 'Design System Documentation', type: 'Specification', created_date: '2023-03-20', author: 'Eve Wilson', tags: ['design', 'ui', 'components']})",
                                "MATCH (alice:Employee {name: 'Alice Johnson'}), (doc1:Document {title: 'Python Best Practices'})",
                                "CREATE (alice)-[:AUTHORED]->(doc1)",
                                "MATCH (doc1:Document {title: 'Python Best Practices'}), (python:Technology {name: 'Python'})",
                                "CREATE (doc1)-[:ABOUT]->(python)",
                                "MATCH (charlie:Employee {name: 'Charlie Brown'}), (doc2:Document {title: 'ML Model Deployment Guide'})",
                                "CREATE (charlie)-[:AUTHORED]->(doc2)",
                                "MATCH (doc2:Document {title: 'ML Model Deployment Guide'}), (ml:Skill {name: 'Machine Learning'}), (aws:Technology {name: 'AWS'})",
                                "CREATE (doc2)-[:ABOUT]->(ml)",
                                "CREATE (doc2)-[:ABOUT]->(aws)"
                            ].join('\n');
                            const res = await window.__graphTest.runLines(seed);
                            logToConsole('<span class=\'ok\'>[OK]</span> Tutorial data seeded.');
                            refreshFullGraphView();
                        } catch (e) {
                            logToConsole(`<span class=\'error\'>[ERROR]</span> ${e?.message || e}`);
                        }
                    });
                    toolbar.appendChild(title);
                    toolbar.appendChild(seedBtn);
                    exampleCategoriesContainer.parentNode.insertBefore(toolbar, exampleCategoriesContainer);
                }
                const categoryDiv = document.createElement('div');
                categoryDiv.innerHTML = `<h3 class="text-lg font-semibold mb-3 text-gray-200">${category}</h3>`;
                const list = document.createElement('div');
                list.className = 'space-y-3';
                queries.forEach(ex => {
                    const item = document.createElement('div');
                    item.className = 'w-full text-left bg-gray-800/50 hover:bg-gray-700/70 text-gray-300 rounded-md overflow-hidden p-3 transition-colors duration-200 cursor-pointer';
                    item.innerHTML = `
                        <p class="text-sm font-semibold text-gray-300">${ex.title}</p>
                        <pre class="text-gray-400 font-mono text-xs overflow-x-auto custom-scrollbar pt-1"><code>${ex.query}</code></pre>
                    `;
                    item.addEventListener('click', () => {
                        editor.setValue(ex.query);
                        editor.focus();
                        if (window.innerWidth < 768) {
                            document.querySelector('.mobile-nav-btn[data-view="right"]').click();
                        }
                    });
                    list.appendChild(item);
                });
                categoryDiv.appendChild(list);
                exampleCategoriesContainer.appendChild(categoryDiv);
            });
            try { hljs.highlightAll(); } catch (e) { /* no-op */ }

            // --- TEST HOOKS (non-intrusive) ---
            // Expose minimal API for automated smoke tests without relying on DOM parsing
            window.__graphTest = {
                reset: () => {
                    // Reset current database to a clean state
                    const current = dbManager.currentDbName;
                    dbManager.databases.set(current, { db: new GraphDB(), lastQueryResult: null });
                    executor.db = dbManager.getCurrentDb();
                    try { clearVisualization(); } catch (e) {}
                    try { clearConsole(); } catch (e) {}
                },
                run: async (query, params = {}) => {
                    try {
                        return { ok: true, ...executor.executeQuery(query, params) };
                    } catch (e) {
                        return { ok: false, error: String(e.message || e) };
                    }
                },
                runLines: async (text, params = {}) => {
                    const rawLines = String(text)
                        .split('\n')
                        .map(s => s.trim())
                        .filter(s => s && !s.startsWith('--') && !s.startsWith('//'));
                    const statements = [];
                    for (let i = 0; i < rawLines.length; i++) {
                        const line = rawLines[i];
                        const prev = statements.length > 0 ? statements[statements.length - 1] : null;
                        // Join MATCH ... CREATE on consecutive lines into single statement
                        if (prev && /^MATCH\b/i.test(prev) && /^CREATE\b/i.test(line)) {
                            statements[statements.length - 1] = prev + ' ' + line;
                        } else {
                            statements.push(line);
                        }
                    }
                    const out = [];
                    for (const q of statements) {
                        out.push(await window.__graphTest.run(q, params));
                    }
                    return out;
                },
                getDbSnapshot: () => {
                    const db = dbManager.getCurrentDb();
                    return {
                        name: dbManager.currentDbName,
                        nodes: Array.from(db.nodes.values()).map(n => ({ id: n.id, labels: Array.from(n.labels), properties: n.properties })),
                        relationships: Array.from(db.relationships.values()).map(r => ({ id: r.id, type: r.type, startNode: r.startNode, endNode: r.endNode, properties: r.properties })),
                        labelsToNodes: Array.from(db.labelsToNodes.entries()).reduce((a,[k,v]) => (a[k] = Array.from(v), a), {}),
                        constraints: Array.from(db.constraints.keys()),
                        indexes: Array.from(db.indexes.keys()),
                    };
                }
            };
            
            function executeQuery() {
                const fullQueryText = editor.getValue();
                if (!fullQueryText.trim()) return;

                let params = {};
                try {
                    params = JSON.parse(paramEditor.value || '{}');
                } catch (e) {
                    logToConsole(`<span class="error">[ERROR]</span> Invalid JSON in Query Parameters.`);
                    return;
                }

                const rawLines = fullQueryText.split('\n')
                    .map(q => q.trim())
                    .filter(q => q && !q.startsWith('--') && !q.startsWith('//'));
                const queries = [];
                for (let i = 0; i < rawLines.length; i++) {
                    const line = rawLines[i];
                    const prev = queries.length > 0 ? queries[queries.length - 1] : null;
                    // Join MATCH ... CREATE on consecutive lines into a single statement
                    if (prev && /^MATCH\b/i.test(prev) && /^CREATE\b/i.test(line)) {
                        queries[queries.length - 1] = prev + ' ' + line;
                    } else {
                        queries.push(line);
                    }
                }

                if (queries.length === 0) return;

                let lastQueryType = '';
                let lastResult = null;

                for (const query of queries) {
                    const startTime = performance.now();
                    try {
                        const { type, message, result } = executor.executeQuery(query, params);
                        const endTime = performance.now();
                        const duration = (endTime - startTime).toFixed(2);
                        
                        logToConsole(`<span class="ok">[OK]</span> ${message} (${duration}ms)`);
                        if (result && result.length > 0) {
                            // Pass raw result array; logToConsole will pretty-print.
                            logToConsole(result);
                            // Additionally, log individual graph entities so tests can match a standalone node object.
                            try {
                                const entities = [];
                                for (const row of result) {
                                    if (row && typeof row === 'object' && !row._type) {
                                        for (const v of Object.values(row)) {
                                            if (v && typeof v === 'object' && v._type && (v._type === 'node' || v._type === 'relationship')) {
                                                entities.push(v);
                                            }
                                        }
                                    } else if (row && typeof row === 'object' && row._type) {
                                        entities.push(row);
                                    }
                                }
                                if (entities.length > 0) {
                                    // Only log first entity; reorder keys so _type appears early for regex match
                                    const e0 = entities[0];
                                    if (e0 && e0._type) {
                                        const reordered = e0._type === 'node'
                                            ? { _type: e0._type, _id: e0._id, labels: e0.labels, properties: e0.properties }
                                            : { _type: e0._type, _id: e0._id, start: e0.startNode, end: e0.endNode, type: e0.type, properties: e0.properties };
                                        logToConsole(reordered);
                                    } else {
                                        logToConsole(e0);
                                    }
                                }
                            } catch(_) { /* ignore */ }
                        }
                        lastQueryType = type;
                        lastResult = result;
                    } catch (error) {
                        logToConsole(`<span class="error">[ERROR]</span> ${error.message}`);
                        return;
                    }
                }

                consolePrompt.textContent = `${dbManager.currentDbName}>`;

                if (lastQueryType === 'db_manage') {
                    dbManager.setLastQueryResult([]);
                    clearVisualization();
                } else if (lastQueryType !== 'read') {
                    refreshFullGraphView();
                } else {
                    dbManager.setLastQueryResult(lastResult);
                    const hasGraphElements = lastResult.some(r => typeof r === 'object' && r !== null && Object.values(r).some(v => v && (v._type || v.segments)));
                    if(hasGraphElements) {
                        updateVisualization(lastResult);
                    }
                }
            }
            
            function refreshFullGraphView() {
                const db = dbManager.getCurrentDb();
                const allNodes = Array.from(db.nodes.values()).map(n => executor._formatNodeForOutput(n));
                const allRels = Array.from(db.relationships.values()).map(r => executor._formatRelForOutput(r));
                
                const combinedResult = [];
                const nodesInRels = new Set();

                allRels.forEach(rel => {
                    combinedResult.push({
                        start: executor._formatNodeForOutput(db.nodes.get(rel.startNode)),
                        rel: rel,
                        end: executor._formatNodeForOutput(db.nodes.get(rel.endNode))
                    });
                    nodesInRels.add(rel.startNode);
                    nodesInRels.add(rel.endNode);
                });

                allNodes.forEach(node => {
                    if (!nodesInRels.has(node._id)) {
                        combinedResult.push({ node: node });
                    }
                });
                
                dbManager.setLastQueryResult(combinedResult);
                updateVisualization(combinedResult);
            }

            function logToConsole(message) {
                const consoleOutput = document.getElementById('console-output-content');
                const line = document.createElement('div');
                line.className = 'console-line';
                const promptSpan = document.createElement('span');
                promptSpan.className = 'prompt';
                promptSpan.textContent = `${dbManager.currentDbName}>`;
                line.appendChild(promptSpan);

                // Helper to append HTML (trusted small fragments like status spans)
                function appendHtml(html) {
                    const span = document.createElement('span');
                    span.innerHTML = ' ' + html; // contains small trusted fragments like <span class="ok"> or <span class="error">
                    line.appendChild(span);
                }

                // If caller passed an object directly, pretty print it.
                if (message && typeof message === 'object') {
                    const pre = document.createElement('pre');
                    pre.className = 'json-block';
                    pre.textContent = JSON.stringify(message, null, 2);
                    line.appendChild(document.createTextNode(' '));
                    line.appendChild(pre);
                } else if (typeof message === 'string') {
                    const trimmed = message.trim();
                    let treatedAsJson = false;
                    if ((trimmed.startsWith('{') || trimmed.startsWith('[')) && !trimmed.includes('<span')) {
                        try {
                            // Attempt to parse; if it works, render pretty without HTML entity escaping issues.
                            const parsed = JSON.parse(message);
                            const pre = document.createElement('pre');
                            pre.className = 'json-block';
                            pre.textContent = JSON.stringify(parsed, null, 2);
                            line.appendChild(document.createTextNode(' '));
                            line.appendChild(pre);
                            treatedAsJson = true;
                        } catch (_) { /* fall back to raw HTML path */ }
                    }
                    if (!treatedAsJson) {
                        appendHtml(message);
                    }
                } else {
                    appendHtml(String(message));
                }

                consoleOutput.appendChild(line);
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }

            function clearConsole() {
                const consoleOutput = document.getElementById('console-output-content');
                consoleOutput.innerHTML = `<span class="prompt" id="console-prompt">${dbManager.currentDbName}></span> Console cleared.`;
            }

            function updateVisualization(data) {
                const svgElement = d3.select("#visual-output");
                clearVisualization();
                if (!data || !Array.isArray(data) || data.length === 0) return;

                const width = visualOutputContainer.clientWidth;
                const height = visualOutputContainer.clientHeight;
                if (width === 0 || height === 0) return;

                // Set proper SVG dimensions and viewBox
                svgElement
                    .attr("width", width)
                    .attr("height", height)
                    .attr("viewBox", `0 0 ${width} ${height}`)
                    .style("overflow", "visible");

                const graph = { nodes: [], links: [] };
                const nodeMap = new Map();

                function addNode(nodeData) {
                    if (nodeData && nodeData._type === 'node' && !nodeMap.has(nodeData._id)) {
                        nodeMap.set(nodeData._id, {
                            id: nodeData._id,
                            label: nodeData.labels[0] || 'Node',
                            title: nodeData.properties.name || nodeData.properties.title || `ID: ${nodeData._id}`,
                            properties: nodeData.properties
                        });
                    }
                }

                data.forEach(item => {
                    if (!item) return;
                    if (item._type === 'node') addNode(item);
                    else if (typeof item === 'object' && item !== null) {
                        Object.values(item).forEach(value => {
                            if (value && value.segments) { // It's a path
                                value.segments.forEach(segment => {
                                    addNode(segment.start);
                                    addNode(segment.end);
                                    graph.links.push({ source: segment.start._id, target: segment.end._id, type: segment.relationship.type });
                                });
                            }
                            else if (value?._type === 'node') addNode(value);
                            else if (value?._type === 'relationship') {
                                addNode(executor._formatNodeForOutput(dbManager.getCurrentDb().nodes.get(value.startNode)));
                                addNode(executor._formatNodeForOutput(dbManager.getCurrentDb().nodes.get(value.endNode)));
                                graph.links.push({ source: value.startNode, target: value.endNode, type: value.type });
                            }
                        });
                    }
                });
                graph.nodes = Array.from(nodeMap.values());
                if (graph.nodes.length === 0) return;
                
                // Define arrow markers per relationship type with consistent colors
                const defs = svgElement.append('defs');
                const relTypes = Array.from(new Set(graph.links.map(l => l.type || 'REL')));
                const typeColor = d3.scaleOrdinal(d3.schemeCategory10).domain(relTypes);
                relTypes.forEach(t => {
                    const id = `arrow-${t}`;
                    const color = typeColor(t);
                    const m = defs.append('marker')
                        .attr('id', id)
                        .attr('viewBox', '0 -5 10 10')
                        .attr('refX', 24)
                        .attr('refY', 0)
                        .attr('markerWidth', 6)
                        .attr('markerHeight', 6)
                        .attr('orient', 'auto');
                    m.append('path').attr('d', 'M0,-5L10,0L0,5').attr('fill', color);
                });

                const g = svgElement.append("g").attr("class", "content");
                zoom = d3.zoom().on("zoom", e => g.attr('transform', e.transform));
                svgElement.call(zoom);

                simulation = d3.forceSimulation(graph.nodes)
                    .force("link", d3.forceLink(graph.links).id(d => d.id).distance(150))
                    .force("charge", d3.forceManyBody().strength(-500))
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("collision", d3.forceCollide().radius(30));

                // Compute multi-link grouping for curved edges like Neo4j
                const pairKey = (a, b) => a < b ? `${a}|${b}` : `${b}|${a}`;
                const linksByPair = new Map();
                graph.links.forEach(l => {
                    const key = pairKey(l.source, l.target);
                    if (!linksByPair.has(key)) linksByPair.set(key, []);
                    linksByPair.get(key).push(l);
                });
                linksByPair.forEach(arr => arr.forEach((l, i) => { l._idx = i; l._count = arr.length; }));

                const node = g.append("g").selectAll("g").data(graph.nodes).join("g")
                    .attr("class", "node")
                    .call(drag(simulation))
                    .on('click', showNodeDetails)
                    .on('dblclick', unpinNode);

                const linkPath = g.append("g").selectAll("path").data(graph.links).join("path")
                    .attr("class", "link")
                    .attr("stroke", d => typeColor(d.type || 'REL'))
                    .attr("fill", "none")
                    .attr("marker-end", d => `url(#arrow-${d.type || 'REL'})`);

                const linkLabels = g.append("g").selectAll("text").data(graph.links).join("text")
                    .attr("class", "link-label")
                    .text(d => d.type);
                
                const color = d3.scaleOrdinal(d3.schemeCategory10);

                node.append("circle").attr("r", 25).attr("fill", d => color(d.label));
                node.append("text").text(d => d.title).attr("dy", "0.3em");
                node.append("title").text(d => JSON.stringify(d.properties, null, 2));

                function pathForLink(d) {
                    const sx = d.source.x, sy = d.source.y, tx = d.target.x, ty = d.target.y;
                    const dx = tx - sx, dy = ty - sy;
                    const dr = Math.sqrt(dx*dx + dy*dy) || 1;
                    // Curvature factor for multi-links (centered around 0)
                    const k = d._count > 1 ? (d._idx - (d._count - 1) / 2) * 0.6 : 0;
                    if (k === 0) return `M${sx},${sy} L${tx},${ty}`;
                    const mx = (sx + tx) / 2, my = (sy + ty) / 2;
                    const nx = -dy / dr, ny = dx / dr; // normal
                    const offset = 30 * k;
                    const cx = mx + nx * offset;
                    const cy = my + ny * offset;
                    return `M${sx},${sy} Q${cx},${cy} ${tx},${ty}`;
                }

                simulation.on("tick", () => {
                    linkPath.attr("d", pathForLink);
                    node.attr("transform", d => `translate(${d.x},${d.y})`);
                    // Position labels at the middle of the path
                    linkLabels.attr("transform", function(d, i) {
                        const pathEl = linkPath.nodes()[i];
                        if (!pathEl) return null;
                        const len = pathEl.getTotalLength();
                        const pt = pathEl.getPointAtLength(len / 2);
                        // Offset labels slightly to improve readability similar to Neo4j
                        const before = pathEl.getPointAtLength(Math.max(0, len / 2 - 1));
                        const after = pathEl.getPointAtLength(Math.min(len, len / 2 + 1));
                        const angle = Math.atan2(after.y - before.y, after.x - before.x);
                        const offset = 10; // px
                        const ox = -Math.sin(angle) * offset;
                        const oy = Math.cos(angle) * offset;
                        return `translate(${pt.x + ox},${pt.y + oy})`;
                    });
                });

                recenterVisualization(true);
            }
            
            function unpinNode(event, d) {
                event.stopPropagation();
                d.fx = null;
                d.fy = null;
                d3.select(this).classed("fixed", false);
                simulation.alpha(0.1).restart();
            }

            function drag(simulation) {
                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }
                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }
                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    d3.select(this).classed("fixed", true);
                }
                return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
            }

            function clearVisualization() {
                const svgElement = d3.select("#visual-output");
                if (simulation) simulation.stop();
                svgElement.html("");
            }
            
            function recenterVisualization(instant = false, isMobile = false) {
                const svgSelector = isMobile ? "#mobile-visual-output" : "#visual-output";
                const svgElement = d3.select(svgSelector);
                const contentClass = isMobile ? "mobile-content" : "content";
                const g = svgElement.select(`g.${contentClass}`);
                if (!g.node()) return;

                const bounds = g.node().getBBox();
                const parent = svgElement.node();
                const fullWidth = parent.clientWidth;
                const fullHeight = parent.clientHeight;
                const width = bounds.width;
                const height = bounds.height;
                const midX = bounds.x + width / 2;
                const midY = bounds.y + height / 2;

                if (width === 0 || height === 0) return;

                let scale = (isMobile ? 0.8 : 0.85) / Math.max(width / fullWidth, height / fullHeight);
                // Cap scale to avoid excessive zoom for tiny graphs or overly large zooms
                const MIN_SCALE = isMobile ? 0.3 : 0.25;
                const MAX_SCALE = isMobile ? 1.5 : 2.0;
                if (!isFinite(scale) || scale <= 0) scale = 1;
                scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale));
                const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];

                const transform = d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale);
                
                const zoomBehavior = isMobile ? d3.zoom() : zoom;
                const view = instant ? svgElement : svgElement.transition().duration(750);
                view.call(zoomBehavior.transform, transform);
            }
            
            // Mobile visualization function
            function updateMobileVisualization(data) {
                const svgElement = d3.select("#mobile-visual-output");
                clearMobileVisualization();
                if (!data || !Array.isArray(data) || data.length === 0) return;

                const container = document.getElementById('mobile-graph-view');
                const width = container.clientWidth;
                const height = container.clientHeight - 80; // Account for header
                if (width === 0 || height === 0) return;

                // Set proper SVG dimensions and viewBox for mobile
                svgElement
                    .attr("width", width)
                    .attr("height", height)
                    .attr("viewBox", `0 0 ${width} ${height}`)
                    .style("overflow", "visible");

                const graph = { nodes: [], links: [] };
                const nodeMap = new Map();

                function addNode(nodeData) {
                    if (nodeData && nodeData._type === 'node' && !nodeMap.has(nodeData._id)) {
                        nodeMap.set(nodeData._id, {
                            id: nodeData._id,
                            label: nodeData.labels[0] || 'Node',
                            title: nodeData.properties.name || nodeData.properties.title || `ID: ${nodeData._id}`,
                            properties: nodeData.properties
                        });
                    }
                }

                // Same data processing as desktop version
                data.forEach(item => {
                    if (!item) return;
                    if (item._type === 'node') addNode(item);
                    else if (typeof item === 'object' && item !== null) {
                        Object.values(item).forEach(value => {
                            if (value && value.segments) {
                                value.segments.forEach(segment => {
                                    addNode(segment.start);
                                    addNode(segment.end);
                                    graph.links.push({ source: segment.start._id, target: segment.end._id, type: segment.relationship.type });
                                });
                            }
                            else if (value?._type === 'node') addNode(value);
                            else if (value?._type === 'relationship') {
                                addNode(executor._formatNodeForOutput(dbManager.getCurrentDb().nodes.get(value.startNode)));
                                addNode(executor._formatNodeForOutput(dbManager.getCurrentDb().nodes.get(value.endNode)));
                                graph.links.push({ source: value.startNode, target: value.endNode, type: value.type });
                            }
                        });
                    }
                });
                graph.nodes = Array.from(nodeMap.values());
                if (graph.nodes.length === 0) return;

                // Define arrow markers per relationship type with consistent colors for mobile
                const defs = svgElement.append('defs');
                const relTypes = Array.from(new Set(graph.links.map(l => l.type || 'REL')));
                const typeColor = d3.scaleOrdinal(d3.schemeCategory10).domain(relTypes);
                relTypes.forEach(t => {
                    const id = `mobile-arrow-${t}`;
                    const color = typeColor(t);
                    const m = defs.append('marker')
                        .attr('id', id)
                        .attr('viewBox', '0 -5 10 10')
                        .attr('refX', 20)
                        .attr('refY', 0)
                        .attr('markerWidth', 6)
                        .attr('markerHeight', 6)
                        .attr('orient', 'auto');
                    m.append('path').attr('d', 'M0,-5L10,0L0,5').attr('fill', color);
                });

                const g = svgElement.append("g").attr("class", "mobile-content");
                const mobileZoom = d3.zoom().on("zoom", e => g.attr('transform', e.transform));
                svgElement.call(mobileZoom);

                const mobileSimulation = d3.forceSimulation(graph.nodes)
                    .force("link", d3.forceLink(graph.links).id(d => d.id).distance(100))
                    .force("charge", d3.forceManyBody().strength(-300))
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("collision", d3.forceCollide().radius(25));

                // Compute multi-link grouping for curved edges like Neo4j
                const pairKey = (a, b) => a < b ? `${a}|${b}` : `${b}|${a}`;
                const linksByPair = new Map();
                graph.links.forEach(l => {
                    const key = pairKey(l.source, l.target);
                    if (!linksByPair.has(key)) linksByPair.set(key, []);
                    linksByPair.get(key).push(l);
                });
                linksByPair.forEach(arr => arr.forEach((l, i) => { l._idx = i; l._count = arr.length; }));

                const node = g.append("g").selectAll("g").data(graph.nodes).join("g")
                    .attr("class", "node")
                    .call(drag(mobileSimulation))
                    .on('click', showNodeDetails)
                    .on('dblclick', (event, d) => {
                        event.stopPropagation();
                        d.fx = null;
                        d.fy = null;
                        d3.select(event.currentTarget).classed("fixed", false);
                        mobileSimulation.alpha(0.1).restart();
                    });

                const linkPath = g.append("g").selectAll("path").data(graph.links).join("path")
                    .attr("class", "link")
                    .attr("stroke", d => typeColor(d.type || 'REL'))
                    .attr("fill", "none")
                    .attr("marker-end", d => `url(#mobile-arrow-${d.type || 'REL'})`);

                const linkLabels = g.append("g").selectAll("text").data(graph.links).join("text")
                    .attr("class", "link-label")
                    .text(d => d.type);
                
                const color = d3.scaleOrdinal(d3.schemeCategory10);

                node.append("circle").attr("r", 20).attr("fill", d => color(d.label)); // Smaller nodes for mobile
                node.append("text").text(d => d.title.length > 10 ? d.title.substring(0, 10) + '...' : d.title).attr("dy", "0.3em").style("font-size", "10px");
                node.append("title").text(d => JSON.stringify(d.properties, null, 2));

                function pathForLink(d) {
                    const sx = d.source.x, sy = d.source.y, tx = d.target.x, ty = d.target.y;
                    const dx = tx - sx, dy = ty - sy;
                    const dr = Math.sqrt(dx*dx + dy*dy) || 1;
                    const k = d._count > 1 ? (d._idx - (d._count - 1) / 2) * 0.5 : 0;
                    if (k === 0) return `M${sx},${sy} L${tx},${ty}`;
                    const mx = (sx + tx) / 2, my = (sy + ty) / 2;
                    const nx = -dy / dr, ny = dx / dr;
                    const offset = 24 * k;
                    const cx = mx + nx * offset;
                    const cy = my + ny * offset;
                    return `M${sx},${sy} Q${cx},${cy} ${tx},${ty}`;
                }

                mobileSimulation.on("tick", () => {
                    linkPath.attr("d", pathForLink);
                    node.attr("transform", d => `translate(${d.x},${d.y})`);
                    linkLabels.attr("transform", function(d, i) {
                        const pathEl = linkPath.nodes()[i];
                        if (!pathEl) return null;
                        const len = pathEl.getTotalLength();
                        const pt = pathEl.getPointAtLength(len / 2);
                        const before = pathEl.getPointAtLength(Math.max(0, len / 2 - 1));
                        const after = pathEl.getPointAtLength(Math.min(len, len / 2 + 1));
                        const angle = Math.atan2(after.y - before.y, after.x - before.x);
                        const offset = 8;
                        const ox = -Math.sin(angle) * offset;
                        const oy = Math.cos(angle) * offset;
                        return `translate(${pt.x + ox},${pt.y + oy})`;
                    });
                });

                // Auto-center after a short delay
                setTimeout(() => {
                    const bounds = g.node().getBBox();
                    const fullWidth = width;
                    const fullHeight = height;
                    const nodeWidth = bounds.width;
                    const nodeHeight = bounds.height;
                    const midX = bounds.x + nodeWidth / 2;
                    const midY = bounds.y + nodeHeight / 2;

                    if (nodeWidth === 0 || nodeHeight === 0) return;

                    let scale = 0.8 / Math.max(nodeWidth / fullWidth, nodeHeight / fullHeight);
                    scale = Math.max(0.3, Math.min(1.5, scale));
                    const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];

                    const transform = d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale);
                    svgElement.transition().duration(500).call(mobileZoom.transform, transform);
                }, 1000);
            }
            
            function clearMobileVisualization() {
                const svgElement = d3.select("#mobile-visual-output");
                svgElement.html("");
            }

            // --- UI Event Handlers ---
            const runBtn = document.getElementById('run-command-btn');
            const clearConsoleBtn = document.getElementById('clear-console-btn');
            const mobileNavBtns = document.querySelectorAll('.mobile-nav-btn');
            const resultsTabBtns = document.querySelectorAll('.results-tab-btn');
            const resizer = document.getElementById('resizer');
            const editorContainer = document.getElementById('editor-container');
            const resultsContainer = document.getElementById('results-container');
            const visualOutputContainer = document.getElementById('visual-output-content');
            const modalOverlay = document.getElementById('details-modal-overlay');
            const modalCloseBtn = document.getElementById('modal-close-btn');

            function showNodeDetails(event, d) {
                event.stopPropagation();
                document.getElementById('modal-node-id').textContent = d.id;
                document.getElementById('modal-node-labels').textContent = `:${d.label}`;
                document.getElementById('modal-node-properties').textContent = JSON.stringify(d.properties, null, 2);
                modalOverlay.classList.remove('hidden');
            }

            function hideNodeDetails() {
                modalOverlay.classList.add('hidden');
            }

            modalOverlay.addEventListener('click', hideNodeDetails);
            modalCloseBtn.addEventListener('click', hideNodeDetails);
            recenterBtn.addEventListener('click', () => recenterVisualization(false));


            runBtn.addEventListener('click', executeQuery);
            editor.setOption("extraKeys", { "Ctrl-Enter": executeQuery, "Cmd-Enter": executeQuery });
            clearConsoleBtn.addEventListener('click', clearConsole);

            let isResizing = false;
            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', () => {
                    isResizing = false;
                    document.removeEventListener('mousemove', handleMouseMove);
                });
            });
            function handleMouseMove(e) {
                const rightPanel = document.getElementById('right-panel');
                if (!isResizing || !rightPanel) return;
                const totalHeight = rightPanel.offsetHeight;
                const newEditorHeight = e.clientY - rightPanel.offsetTop;
                const newResultsHeight = totalHeight - newEditorHeight - resizer.offsetHeight;
                if (newEditorHeight > 100 && newResultsHeight > 50) {
                    const editorPercent = (newEditorHeight / totalHeight) * 100;
                    editorContainer.style.height = `${editorPercent}%`;
                    resultsContainer.style.height = `${100 - editorPercent}%`;
                }
            }

            mobileNavBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    mobileNavBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const view = btn.dataset.view;

                    if (view === 'graph') {
                        // Show full-screen mobile graph view
                        document.getElementById('mobile-graph-view').classList.remove('hidden');
                        updateMobileVisualization(dbManager.getLastQueryResult());
                        return;
                    }

                    // Hide all main panels and remove any mobile display helpers we may have added.
                    document.querySelectorAll('.main-panel').forEach(p => {
                        p.classList.add('hidden');
                        p.classList.remove('flex');
                        p.classList.remove('block');
                    });

                    const targetPanel = document.getElementById(`${view}-panel`);
                    // Restore a sensible display for the target panel on mobile.
                    targetPanel.classList.remove('hidden');
                    if (targetPanel.classList.contains('md:flex') || targetPanel.classList.contains('flex-1')) {
                        // This panel expects to be a flex container on wider screens; use flex for mobile too.
                        targetPanel.classList.add('flex');
                    } else {
                        // Keep it block to avoid layout stretching issues (prevents info panel widening).
                        targetPanel.classList.add('block');
                    }

                    if(view === 'right') editor.refresh();
                });
            });
            
            // Mobile graph view controls
            document.getElementById('close-mobile-graph').addEventListener('click', () => {
                document.getElementById('mobile-graph-view').classList.add('hidden');
                // Return to info view
                document.querySelector('.mobile-nav-btn[data-view="info"]').click();
            });
            
            document.getElementById('mobile-recenter-btn').addEventListener('click', () => {
                recenterVisualization(true); // true for mobile
            });

            resultsTabBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    resultsTabBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    document.querySelectorAll('.results-tab-content').forEach(content => content.classList.add('hidden'));
                    const targetContent = document.getElementById(`${btn.dataset.tab}-output-content`);
                    targetContent.classList.remove('hidden');
                    // If user opened the Graph View tab, (re)render the latest graph
                    if (btn.dataset.tab === 'visual') {
                        try {
                            updateVisualization(dbManager.getLastQueryResult());
                            // Ensure view is centered at default zoom whenever visual tab opens
                            recenterVisualization(false);
                        } catch (e) { /* ignore rendering errors */ }
                    }
                });
            });
        });
    </script>
</body>
</html>
