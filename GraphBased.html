<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Graph Database Emulator (Neo4j/Cypher) - Definitive Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- CodeMirror for the main editor -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/material-darker.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/sql/sql.min.js"></script>

    <!-- highlight.js for static example highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- D3.js for visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }
    :root { --mobile-nav-height: 56px; }
        .CodeMirror {
            font-family: 'Fira Code', monospace;
            font-size: 14px;
            line-height: 21px;
            height: 100%;
            background-color: #1e1e1e;
        }
        .CodeMirror-gutters {
            background-color: #252526 !important;
            border-right: 1px solid #3a3a3a;
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #2d2d2d;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #555;
            border-radius: 3px;
        }
        .resizer {
            background-color: #3a3a3a;
            cursor: row-resize;
            width: 100%;
            height: 5px;
            z-index: 10;
        }
    /* Keep the Run button visible even with long editors */
    #editor-container { min-height: 0; }
    #editor-wrapper { overflow: auto; }
    #action-bar { position: sticky; bottom: 0; z-index: 5; }
        .console-output {
            font-family: 'Fira Code', monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .console-output .ok { color: #6ee7b7; }
        .console-output .error { color: #f472b6; }
        .console-output .info { color: #a5b4fc; }
        .console-output .prompt { color: #6b7280; }
        .mobile-nav-btn.active {
            color: #6ee7b7;
            border-color: #6ee7b7;
        }
        .results-tab-btn.active {
            border-color: #6ee7b7;
            background-color: #2d2d2d;
        }
        




        /* D3 Visualization Styles */
        .node circle {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: grab;
        }
        .node.fixed circle {
             stroke: #6ee7b7; /* Highlight pinned nodes */
             stroke-width: 2.5px;
        }
        .node:active {
            cursor: grabbing;
        }
        .link {
            stroke-opacity: 0.6;
        }
        .link-label {
            font-size: 10px;
            fill: #a0a0a0;
            text-anchor: middle;
            pointer-events: none;
            paint-order: stroke;
            stroke: #1e1e1e;
            stroke-width: 2px;
        }
        .node text {
            fill: #e0e0e0;
            font-size: 11px;
            text-anchor: middle;
            pointer-events: none;
            paint-order: stroke;
            stroke: #1e1e1e;
            stroke-width: 2px;
        }
        /* Modal Styles */
        #details-modal-overlay {
            z-index: 50;
        }

                /* Mobile bottom nav: fixed + safe-area and content padding */
                @media (max-width: 768px) {
                    nav.md\\:hidden { position: fixed; bottom: 0; left: 0; right: 0; z-index: 45; padding-bottom: env(safe-area-inset-bottom); }
                    main { padding-bottom: calc(var(--mobile-nav-height) + env(safe-area-inset-bottom)); }
                }
    </style>
</head>
<body class="flex flex-col h-screen">

    <main class="flex flex-grow overflow-hidden md:flex-row flex-col">
        <!-- Left Panel: Information and Examples -->
        <div id="info-panel" class="main-panel w-full md:w-2/5 h-full bg-[#1e1e1e] p-6 custom-scrollbar overflow-y-auto overflow-x-hidden border-r border-gray-700 min-w-0">
            <div class="prose prose-invert max-w-none">
                <h2 class="text-2xl font-bold text-gray-100">Graph Database Emulator</h2>
                <p class="text-sm text-gray-400">A feature-complete, in-memory emulator for a Property Graph database, inspired by Neo4j and its Cypher query language.</p>

                <div id="info-panel-content">
                    <!-- Content injected by JS -->
                </div>

                <div id="example-categories" class="space-y-6 mt-6">
                    <!-- Examples will be injected here by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Right Panel: Editor and Console/Visualizer -->
        <div id="right-panel" class="main-panel flex-1 flex-col w-full md:w-3/5 h-full bg-[#252526] hidden md:flex min-w-0">
            <!-- Title Bar for Editor -->
            <div class="flex-shrink-0 bg-[#282828] p-3 border-b border-gray-700">
                <h3 class="text-lg font-semibold text-gray-200">Cypher Query Console</h3>
                <p class="text-sm text-gray-400">Write Cypher queries to explore and manipulate the graph database.</p>
            </div>
            <div id="editor-container" class="flex-grow flex flex-col overflow-hidden" style="height: 70%;">
                <div id="editor-wrapper" class="flex-grow relative">
                    <textarea id="command-editor"></textarea>
                </div>
                <div id="action-bar" class="flex-shrink-0 bg-[#282828] p-2 flex justify-end items-center gap-3 border-t border-gray-700">
                    <button id="run-command-btn" class="bg-green-600 hover:bg-green-700 text-white font-semibold px-4 py-1.5 rounded-md text-sm transition-colors">Run (Ctrl+Enter)</button>
                </div>
            </div>
            <div id="resizer" class="resizer"></div>
            <div id="results-container" class="flex-grow flex flex-col overflow-hidden" style="height: 30%;">
                <div class="flex-shrink-0 bg-[#282828] border-b border-gray-700">
                    <div class="flex items-center justify-between p-2">
                        <div class="flex">
                            <button class="results-tab-btn active px-3 py-1 text-sm font-medium border-b-2" data-tab="console">Console</button>
                            <button class="results-tab-btn px-3 py-1 text-sm font-medium border-b-2 border-transparent" data-tab="visual">Graph View</button>
                            <button class="results-tab-btn px-3 py-1 text-sm font-medium border-b-2 border-transparent" data-tab="params">Parameters</button>
                        </div>
                        <button id="clear-console-btn" class="text-xs text-gray-400 hover:text-white">Clear</button>
                    </div>
                </div>
                <div id="console-output-content" class="results-tab-content flex-grow bg-[#1e1e1e] overflow-auto custom-scrollbar p-3 console-output">
                    <span class="prompt" id="console-prompt">></span> Welcome! This is the feature-complete Graph DB Emulator.
                </div>
                <div id="visual-output-content" class="results-tab-content flex-grow bg-[#1e1e1e] overflow-hidden hidden relative">
                     <div class="absolute top-2 left-2 z-10">
                        <button id="recenter-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold px-3 py-1.5 rounded-md text-xs">Recenter</button>
                    </div>
                    <svg id="visual-output" class="w-full h-full"></svg>
                    <div class="absolute bottom-2 right-2 text-xs text-gray-500">Click to inspect, Drag to pin, Double-click to unpin</div>
                </div>
                <div id="params-output-content" class="results-tab-content flex-grow bg-[#1e1e1e] hidden">
                     <textarea id="param-editor" class="w-full h-full bg-[#1e1e1e] text-gray-300 font-mono text-sm p-2 focus:outline-none custom-scrollbar"></textarea>
                </div>
            </div>
        </div>
    </main>

    <nav id="mobile-nav" class="md:hidden bg-[#282828] border-t border-gray-700 w-full flex-shrink-0">
        <button class="mobile-nav-btn active flex-1 p-3 text-sm text-center font-medium border-t-2" data-view="info">
            <svg class="w-5 h-5 mx-auto mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
            </svg>
            Info
        </button>
        <button class="mobile-nav-btn flex-1 p-3 text-sm text-center font-medium border-t-2 border-transparent" data-view="right">
            <svg class="w-5 h-5 mx-auto mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
            </svg>
            Editor
        </button>
        <button class="mobile-nav-btn flex-1 p-3 text-sm text-center font-medium border-t-2 border-transparent" data-view="graph">
            <svg class="w-5 h-5 mx-auto mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
            </svg>
            Graph
        </button>
    </nav>
    
    <!-- Mobile Full-Screen Graph View -->
    <div id="mobile-graph-view" class="md:hidden fixed inset-0 bg-[#1e1e1e] z-50 hidden">
        <div class="flex flex-col h-full">
            <div class="flex items-center justify-between p-4 bg-[#282828] border-b border-gray-700">
                <h3 class="text-lg font-semibold text-gray-200">Graph Visualization</h3>
                <button id="close-mobile-graph" class="text-gray-400 hover:text-white">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div class="flex-1 relative">
                <div class="absolute top-2 left-2 z-10">
                    <button id="mobile-recenter-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold px-3 py-1.5 rounded-md text-xs">Recenter</button>
                </div>
                <svg id="mobile-visual-output" class="w-full h-full"></svg>
                <div class="absolute bottom-2 right-2 text-xs text-gray-500">Click to inspect, Drag to pin, Double-click to unpin</div>
            </div>
        </div>
    </div>
    
    <!-- Node Details Modal -->
    <div id="details-modal-overlay" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden">
        <div id="details-modal" class="bg-[#2d2d2d] rounded-lg shadow-xl p-6 w-full max-w-md border border-gray-700">
            <h3 class="text-lg font-bold text-gray-100 mb-2">Node Details</h3>
            <div class="text-sm mb-4">
                <p><strong class="text-gray-400">ID:</strong> <span id="modal-node-id" class="text-sky-400"></span></p>
                <p><strong class="text-gray-400">Labels:</strong> <span id="modal-node-labels" class="text-teal-400"></span></p>
            </div>
            <h4 class="font-semibold text-gray-200 mb-2">Properties:</h4>
            <pre id="modal-node-properties" class="bg-[#1e1e1e] p-3 rounded-md text-sm custom-scrollbar max-h-64 overflow-auto"></pre>
            <div class="mt-6 text-right">
                <button id="modal-close-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold px-4 py-1.5 rounded-md text-sm">Close</button>
            </div>
        </div>
    </div>


    <script>
        // --- DATABASE MANAGEMENT ---
        class DatabaseManager {
            constructor() {
                this.databases = new Map();
                this.currentDbName = 'default';
                this.databases.set(this.currentDbName, { db: new GraphDB(), lastQueryResult: null });
            }
            createDatabase(name) {
                if (this.databases.has(name)) throw new Error(`Database '${name}' already exists.`);
                this.databases.set(name, { db: new GraphDB(), lastQueryResult: null });
            }
            dropDatabase(name) {
                if (name === 'default') throw new Error("Cannot drop the default database.");
                if (!this.databases.delete(name)) throw new Error(`Database '${name}' not found.`);
                if (this.currentDbName === name) {
                    this.useDatabase('default');
                }
            }
            useDatabase(name) {
                if (!this.databases.has(name)) throw new Error(`Database '${name}' not found.`);
                this.currentDbName = name;
            }
            getCurrentDb() {
                return this.databases.get(this.currentDbName).db;
            }
            getLastQueryResult() {
                return this.databases.get(this.currentDbName).lastQueryResult;
            }
            setLastQueryResult(result) {
                this.databases.get(this.currentDbName).lastQueryResult = result;
            }
        }

        // --- CORE GRAPH DATABASE ENGINE ---
        class GraphDB {
            constructor() {
                this.nodes = new Map();
                this.relationships = new Map();
                this.labelsToNodes = new Map();
                this.nodeRelationships = new Map();
                this._nodeIdCounter = 0;
                this._relIdCounter = 0;
                this.constraints = new Map();
                this.indexes = new Map();
                this.constraintNames = new Map(); // name -> label.property
            }
            _getNextNodeId() { return this._nodeIdCounter++; }
            _getNextRelId() { return this._relIdCounter++; }
            createNode(labels = [], properties = {}) {
                for (const label of labels) {
                    for (const prop in properties) {
                        const key = `${label}.${prop}`;
                        if (this.constraints.has(key)) {
                            const value = properties[prop];
                            if (this.constraints.get(key).has(value)) {
                                throw new Error(`Constraint violation: Node with label '${label}' and property '${prop}' already exists with value '${value}'.`);
                            }
                        }
                    }
                }

                const id = this._getNextNodeId();
                const node = { id, labels: new Set(labels), properties };
                this.nodes.set(id, node);
                this.nodeRelationships.set(id, { incoming: new Set(), outgoing: new Set() });
                labels.forEach(label => {
                    if (!this.labelsToNodes.has(label)) this.labelsToNodes.set(label, new Set());
                    this.labelsToNodes.get(label).add(id);
                    for (const prop in properties) {
                        const key = `${label}.${prop}`;
                        if (this.constraints.has(key)) {
                            this.constraints.get(key).add(properties[prop]);
                        }
                    }
                });
                return node;
            }
            createRelationship(startNodeId, endNodeId, type, properties = {}) {
                if (!this.nodes.has(startNodeId) || !this.nodes.has(endNodeId)) throw new Error("Cannot create relationship between non-existent nodes.");
                const id = this._getNextRelId();
                const rel = { id, type, startNode: startNodeId, endNode: endNodeId, properties };
                this.relationships.set(id, rel);
                this.nodeRelationships.get(startNodeId).outgoing.add(id);
                this.nodeRelationships.get(endNodeId).incoming.add(id);
                return rel;
            }
            findNodes(label, properties) {
                let candidateIds = label ? (this.labelsToNodes.get(label) || new Set()) : new Set(this.nodes.keys());
                if (Object.keys(properties).length === 0) return Array.from(candidateIds).map(id => this.nodes.get(id));
                const results = [];
                for (const id of candidateIds) {
                    const node = this.nodes.get(id);
                    let match = true;
                    for (const key in properties) {
                        if (node.properties[key] !== properties[key]) {
                            match = false;
                            break;
                        }
                    }
                    if (match) results.push(node);
                }
                return results;
            }
            findRelationships(type, properties) {
                const results = [];
                for (const rel of this.relationships.values()) {
                    const typeMatch = !type || rel.type === type;
                    if (!typeMatch) continue;
                    let propsMatch = true;
                    for (const key in properties) {
                        if (rel.properties[key] !== properties[key]) {
                            propsMatch = false;
                            break;
                        }
                    }
                    if (propsMatch) results.push(rel);
                }
                return results;
            }
            deleteNode(nodeId) {
                const node = this.nodes.get(nodeId);
                if (!node) return false;
                const rels = this.nodeRelationships.get(nodeId);
                if (rels.incoming.size > 0 || rels.outgoing.size > 0) throw new Error("Cannot delete node with relationships. Use DETACH DELETE.");
                node.labels.forEach(label => {
                    this.labelsToNodes.get(label)?.delete(nodeId);
                     for (const prop in node.properties) {
                        const key = `${label}.${prop}`;
                        if (this.constraints.has(key)) {
                            this.constraints.get(key).delete(node.properties[prop]);
                        }
                    }
                });
                this.nodes.delete(nodeId);
                this.nodeRelationships.delete(nodeId);
                return true;
            }
            detachDeleteNode(nodeId) {
                if (!this.nodes.has(nodeId)) return false;
                const relsToDelete = new Set([...this.nodeRelationships.get(nodeId).incoming, ...this.nodeRelationships.get(nodeId).outgoing]);
                relsToDelete.forEach(relId => this.deleteRelationship(relId));
                this.deleteNode(nodeId);
                return true;
            }
            deleteRelationship(relId) {
                const rel = this.relationships.get(relId);
                if (!rel) return false;
                this.nodeRelationships.get(rel.startNode)?.outgoing.delete(relId);
                this.nodeRelationships.get(rel.endNode)?.incoming.delete(relId);
                this.relationships.delete(relId);
                return true;
            }
        }

        // --- CYPHER-LIKE PARSER & EXECUTOR ---
        class CypherExecutor {
            constructor(dbManager) {
                this.dbManager = dbManager;
                this.db = dbManager.getCurrentDb();
                this.inTransaction = false;
                this.txOperations = [];
            }

            // Enhanced Cypher query preprocessing with robust comment removal
            _cleanCypherQuery(query) {
                const lines = query.split('\n');
                return lines
                    .map(line => {
                        // Remove single-line comments (// or --)
                        line = line.replace(/\/\/.*$/, '');
                        line = line.replace(/--.*$/, '');
                        
                        // Remove multi-line comments (/* */) carefully
                        let result = '';
                        let inComment = false;
                        for (let i = 0; i < line.length; i++) {
                            if (!inComment && i < line.length - 1 && line.substr(i, 2) === '/*') {
                                inComment = true;
                                i++; // skip the next character
                            } else if (inComment && i < line.length - 1 && line.substr(i, 2) === '*/') {
                                inComment = false;
                                i++; // skip the next character
                            } else if (!inComment) {
                                result += line[i];
                            }
                        }
                        return result.trim();
                    })
                    .filter(line => line)
                    .join(' ')
                    .replace(/\s+/g, ' ')
                    .trim();
            }

            _substituteParameters(query, params) {
                let result = query;
                for (const key in params) {
                    const value = params[key];
                    const paramRegex = new RegExp('\\$' + key + '\\b', 'g');
                    let replacement;
                    
                    if (typeof value === 'string') {
                        replacement = `'${value.replace(/'/g, "\\'")}'`;
                    } else if (typeof value === 'object') {
                        replacement = JSON.stringify(value);
                    } else {
                        replacement = String(value);
                    }
                    
                    result = result.replace(paramRegex, replacement);
                }
                return result;
            }

            _parseCypherPattern(pattern) {
                // Enhanced pattern parsing for complex graph structures
                const nodePattern = /\((\w+)?(?::(\w+))?\s*(?:\{([^}]*)\})?\)/g;
                const relPattern = /-\[(\w+)?(?::(\w+))?\s*(?:\{([^}]*)\})?\]->/g;
                
                const nodes = [];
                const relationships = [];
                
                let match;
                while ((match = nodePattern.exec(pattern)) !== null) {
                    nodes.push({
                        variable: match[1] || null,
                        label: match[2] || null,
                        properties: match[3] ? this._parseProperties(match[3]) : {}
                    });
                }
                
                while ((match = relPattern.exec(pattern)) !== null) {
                    relationships.push({
                        variable: match[1] || null,
                        type: match[2] || null,
                        properties: match[3] ? this._parseProperties(match[3]) : {}
                    });
                }
                
                return { nodes, relationships };
            }

            executeQuery(query, params = {}) {
                // Enhanced query preprocessing with comment support
                const cleanQuery = this._cleanCypherQuery(query);
                if (!cleanQuery) throw new Error("No valid Cypher statements found.");
                
                // Parameter substitution with enhanced support
                let processedQuery = this._substituteParameters(cleanQuery, params);
                
                const upperQuery = processedQuery.toUpperCase().trim();

                if (upperQuery === 'BEGIN') {
                    this.inTransaction = true;
                    this.txOperations = [];
                    return { type: 'tx_manage', message: 'Transaction started.' };
                }
                if (upperQuery === 'COMMIT') {
                    if (!this.inTransaction) throw new Error("No active transaction to commit.");
                    this.inTransaction = false;
                    return { type: 'tx_manage', message: `Transaction committed.` };
                }
                if (upperQuery === 'ROLLBACK') {
                    if (!this.inTransaction) throw new Error("No active transaction to rollback.");
                    this.inTransaction = false;
                    return { type: 'tx_manage', message: 'Transaction rolled back. (Note: In-memory changes are not undone in this emulator).' };
                }

                if (upperQuery.startsWith('CREATE DATABASE')) {
                    const name = cleanQuery.split(' ')[2];
                    this.dbManager.createDatabase(name);
                    return { type: 'db_manage', message: `Database '${name}' created.` };
                }
                if (upperQuery.startsWith('DROP DATABASE')) {
                    const name = cleanQuery.split(' ')[2];
                    this.dbManager.dropDatabase(name);
                    return { type: 'db_manage', message: `Database '${name}' dropped.` };
                }
                if (upperQuery.startsWith('USE')) {
                    const name = cleanQuery.split(' ')[1];
                    this.dbManager.useDatabase(name);
                    return { type: 'db_manage', message: `Now using database '${name}'.` };
                }
                
                if (upperQuery.startsWith('HELP')) return this._handleHelp(cleanQuery);
                
                this.db = this.dbManager.getCurrentDb();
                if (upperQuery.startsWith('CREATE CONSTRAINT')) return this._handleCreateConstraint(cleanQuery);
                if (upperQuery.startsWith('CREATE INDEX')) return this._handleCreateIndex(cleanQuery);
                if (upperQuery.startsWith('DROP INDEX')) return this._handleDropIndex(cleanQuery);
                if (upperQuery.startsWith('DROP CONSTRAINT')) return this._handleDropConstraint(cleanQuery);
                if (upperQuery.startsWith('SHOW')) return this._handleShow(cleanQuery);
                if (upperQuery.startsWith('CALL')) return this._handleCall(cleanQuery);
                if (upperQuery.startsWith('FOREACH')) return this._handleForeach(cleanQuery);
                if (upperQuery.includes('SHORTESTPATH') || upperQuery.includes('ALLSHORTESTPATHS')) return this._handlePathFunctions(cleanQuery);
                if (upperQuery.startsWith('UNWIND')) return this._handleUnwind(cleanQuery);
                if (upperQuery.startsWith('MERGE')) return this._handleMerge(cleanQuery);
                if (upperQuery.includes('SET')) return this._handleSet(cleanQuery);
                if (upperQuery.includes('REMOVE')) return this._handleRemove(cleanQuery);
                if (upperQuery.startsWith('MATCH') && upperQuery.includes('CREATE')) return this._handleCreate(cleanQuery);
                if (upperQuery.startsWith('CREATE')) return this._handleCreate(cleanQuery);
                if (upperQuery.startsWith('MATCH') || upperQuery.startsWith('OPTIONAL MATCH')) return this._handleReadQuery(cleanQuery);
                
                throw new Error("Unsupported query.");
            }
            
            _parseValue(valueStr) {
                const s = String(valueStr).trim();
                if (s.toLowerCase().startsWith("date('")) return new Date(s.slice(6, -2)).toISOString().split('T')[0];
                if (s.toLowerCase().startsWith("datetime('")) return new Date(s.slice(10, -2)).toISOString();
                if (s.toLowerCase().startsWith("duration(")) return s;

                try {
                    return JSON.parse(s.replace(/'/g, '"'));
                } catch(e) {
                    return s;
                }
            }
            
            _parseProperties(propString) {
                if (!propString) return {};
                const properties = {};
                const propRegex = /(\w+)\s*:\s*(date\(.*?\)|datetime\(.*?\)|duration\(.*?\)|'.*?'|\[.*?\]|[0-9.-]+|true|false)/gi;
                let match;
                while((match = propRegex.exec(propString)) !== null) {
                    properties[match[1]] = this._parseValue(match[2]);
                }
                return properties;
            }

            _parseNodePattern(pattern) {
                // Support multi-labels like (n:Label1:Label2)
                const m = pattern.match(/\((\w*)\s*(:[\w:]+)?\s*({.*?})?\)/);
                if (!m) return null;
                const [, variable, labelsPart, propString] = m;
                const labels = labelsPart ? labelsPart.split(':').filter(Boolean) : [];
                return { variable, labels, properties: this._parseProperties(propString) };
            }

            _parseRelPattern(pattern) {
                // Support -[]-, -[]->, <-[]-, variable length like *1..3, and type alternation :A|:B
                // Ensure typePart does not capture the '*' length spec
                const re = /(<?)-\[(\w*)?:?([^\]\s\*]*)?\s*({.*?})?(\*\d*(?:\.\.\d*)?)?\]-(>?)*/;
                const m = pattern.match(re);
                if (!m) return null;
                const [, leftArrow, variable, typePart, propString, length, rightArrow] = m;
                let minHops = 1, maxHops = 1;
                if (length) {
                    const cleaned = length.replace('*', '');
                    const hasRange = cleaned.includes('..');
                    if (hasRange) {
                        const [minStr, maxStr] = cleaned.split('..');
                        minHops = minStr ? parseInt(minStr) : 1;
                        maxHops = maxStr ? parseInt(maxStr) : Infinity;
                    } else {
                        minHops = cleaned ? parseInt(cleaned) : 1;
                        maxHops = minHops;
                    }
                    if (!isFinite(maxHops)) maxHops = Infinity;
                }
                const directed = rightArrow === '>' && leftArrow !== '<';
                const undirected = leftArrow === '<' && rightArrow === '>' ? false : (!leftArrow && !rightArrow);
                // Parse alternation of types: A|B|C
                const types = (typePart || '')
                    .split('|')
                    .map(s => s.trim())
                    .filter(Boolean);
                return { variable, types, type: types.length === 1 ? types[0] : null, properties: this._parseProperties(propString), minHops, maxHops, directed, undirected };
            }

        _handleCreate(query) {
                const createNodeMatch = query.match(/^CREATE\s+(\(.*\))$/i);
                if (createNodeMatch) {
                    const nodePattern = this._parseNodePattern(createNodeMatch[1]);
                    if (!nodePattern) throw new Error("Invalid node creation syntax.");
            const { labels = [], properties } = nodePattern;
            const node = this.db.createNode(labels, properties);
                    return { type: 'create', message: "Created 1 node.", result: [this._formatNodeForOutput(node)] };
                }
                const createRelMatch = query.match(/^MATCH\s+(.*?)\s+CREATE\s+(.*)$/i);
                if (createRelMatch) {
                    const [, matchClause, createClause] = createRelMatch;
                    const nodePatterns = matchClause.split(',').map(s => this._parseNodePattern(s.trim()));
                    const relPatternMatch = createClause.match(/\((\w+)\)-\[.*:(\w+)\s*({.*})?\]->\((\w+)\)/);
                    if (!relPatternMatch) throw new Error(`Invalid relationship CREATE pattern: ${createClause}`);
                    
                    const foundNodes = nodePatterns.map(p => {
                        // For multi-label search, intersect node sets across labels
                        let candidates;
                        if (p.labels && p.labels.length > 0) {
                            const sets = p.labels.map(lbl => new Set(this.db.labelsToNodes.get(lbl) || []));
                            const intersect = sets.reduce((a, s) => new Set([...a].filter(x => s.has(x))));
                            candidates = [...intersect].map(id => this.db.nodes.get(id));
                        } else {
                            candidates = this.db.findNodes(undefined, {});
                        }
                        const nodes = candidates.filter(n => Object.entries(p.properties||{}).every(([k,v]) => n.properties[k] === v));
                        if (nodes.length !== 1) throw new Error(`Expected 1 node for pattern ${JSON.stringify(p)}, but found ${nodes.length}.`);
                        return nodes[0];
                    });
                    
                    const [, startVar, relType, relPropsStr, endVar] = relPatternMatch;
                    const startNodePattern = nodePatterns.find(p => p.variable === startVar);
                    const endNodePattern = nodePatterns.find(p => p.variable === endVar);
                    const findOne = (p) => {
                        let candidates;
                        if (p.labels && p.labels.length > 0) {
                            const sets = p.labels.map(lbl => new Set(this.db.labelsToNodes.get(lbl) || []));
                            const intersect = sets.reduce((a, s) => new Set([...a].filter(x => s.has(x))));
                            candidates = [...intersect].map(id => this.db.nodes.get(id));
                        } else {
                            candidates = this.db.findNodes(undefined, {});
                        }
                        return candidates.find(n => Object.entries(p.properties||{}).every(([k,v]) => n.properties[k] === v));
                    };
                    const startNode = findOne(startNodePattern);
                    const endNode = findOne(endNodePattern);
                    if (!startNode || !endNode) throw new Error("Could not find start or end node for relationship.");

                    const rel = this.db.createRelationship(startNode.id, endNode.id, relType, this._parseProperties(relPropsStr));
                    return { type: 'create', message: "Created 1 relationship.", result: [this._formatRelForOutput(rel)] };
                }
                throw new Error("Unsupported CREATE syntax.");
            }

            _handleReadQuery(query) {
                const deleteMatch = query.match(/MATCH\s+(.*?)\s+(DETACH\s+DELETE|DELETE)\s+(.*)$/i);
                if (deleteMatch) return this._handleDelete(deleteMatch);
                
                const matchClauseMatch = query.match(/(?:MATCH|OPTIONAL MATCH)\s+(.*?(?=\s+WHERE|\s+WITH|\s+RETURN|$))/i);
                const whereClauseMatch = query.match(/WHERE\s+(.*?(?=\s+WITH|\s+RETURN|$))/i);
                const withClauseMatch = query.match(/WITH\s+(.*?(?=\s+RETURN|$))/i);
                const returnClauseMatch = query.match(/RETURN\s+(.*?(?=\s+ORDER BY|\s+SKIP|\s+LIMIT|$))/i);
                const orderByClauseMatch = query.match(/ORDER BY\s+(.*?(?=\s+SKIP|\s+LIMIT|$))/i);
                const skipClauseMatch = query.match(/SKIP\s+(\d+)/i);
                const limitClauseMatch = query.match(/LIMIT\s+(\d+)/i);

                if (!matchClauseMatch || !returnClauseMatch) throw new Error("Read query must contain MATCH and RETURN clauses.");

                let results = this._performMatch(matchClauseMatch[1]);
                
                if (whereClauseMatch) results = this._applyWhere(results, whereClauseMatch[1]);
                if (withClauseMatch) results = this._applyWithOrReturn(results, withClauseMatch[1]);
                results = this._applyWithOrReturn(results, returnClauseMatch[1]);
                if (orderByClauseMatch) results = this._applyOrderBy(results, orderByClauseMatch[1]);
                if (skipClauseMatch) results = results.slice(parseInt(skipClauseMatch[1]));
                if (limitClauseMatch) results = results.slice(0, parseInt(limitClauseMatch[1]));

                return { type: 'read', message: `Found ${results.length} results.`, result: results };
            }

            _performMatch(matchClause) {
                let pattern = matchClause.replace(/^(OPTIONAL )?MATCH\s*/i, '').trim();
                let pathVar = null;
                if (pattern.match(/^\w+\s*=/)) {
                    [pathVar, pattern] = pattern.split('=').map(s => s.trim());
                }

                if (!pattern.includes('-')) {
                    const nodePattern = this._parseNodePattern(pattern);
                    // Multi-label filtering
                    let nodes;
                    if (nodePattern.labels && nodePattern.labels.length > 0) {
                        const sets = nodePattern.labels.map(lbl => new Set(this.db.labelsToNodes.get(lbl) || []));
                        const intersect = sets.reduce((a, s) => new Set([...a].filter(x => s.has(x))), new Set(this.db.nodes.keys()));
                        nodes = [...intersect].map(id => this.db.nodes.get(id));
                    } else {
                        nodes = this.db.findNodes(undefined, {});
                    }
                    nodes = nodes.filter(n => Object.entries(nodePattern.properties||{}).every(([k,v]) => n.properties[k] === v));
                    return nodes.map(n => ({ [nodePattern.variable]: this._formatNodeForOutput(n) }));
                }

                const [startNodePatternStr, relPatternStr, endNodePatternStrRaw] = pattern.split(/(-.+?-)/);
                const startNodePattern = this._parseNodePattern(startNodePatternStr);
                const relPattern = this._parseRelPattern(relPatternStr);
                // Determine direction using the full pattern to avoid losing '>' during split
                const isDirected = /-\[.*?\]->/.test(pattern);
                const endNodePatternStr = endNodePatternStrRaw.replace('>', '').trim();
                const endNodePattern = this._parseNodePattern(endNodePatternStr);

                // Build start node set with multi-label support
                let startNodes;
                if (startNodePattern.labels && startNodePattern.labels.length > 0) {
                    const sets = startNodePattern.labels.map(lbl => new Set(this.db.labelsToNodes.get(lbl) || []));
                    const intersect = sets.reduce((a, s) => new Set([...a].filter(x => s.has(x))), new Set(this.db.nodes.keys()));
                    startNodes = [...intersect].map(id => this.db.nodes.get(id));
                } else {
                    startNodes = this.db.findNodes(undefined, {});
                }
                startNodes = startNodes.filter(n => Object.entries(startNodePattern.properties||{}).every(([k,v]) => n.properties[k] === v));
                const finalResults = [];

                startNodes.forEach(startNode => {
                    const queue = [[startNode, []]]; 
                    const visitedPaths = new Set();

                    while (queue.length > 0) {
                        const [currentNode, currentPath] = queue.shift();
                        const currentDepth = currentPath.length;

                        if (currentDepth >= relPattern.maxHops) continue;

                        // Consider direction, relationship type, and relationship properties
                        const considerRel = (rel, fromNodeId) => {
                            if (relPattern && relPattern.types && relPattern.types.length > 0) {
                                if (!relPattern.types.includes(rel.type)) return false;
                            }
                            if (relPattern && relPattern.properties) {
                                for (const [k,v] of Object.entries(relPattern.properties)) {
                                    if (rel.properties[k] !== v) return false;
                                }
                            }
                            if (!isDirected) return rel.startNode === fromNodeId || rel.endNode === fromNodeId;
                            return rel.startNode === fromNodeId; // only outgoing if directed
                        };

                        for (const rel of this.db.relationships.values()) {
                            if (!considerRel(rel, currentNode.id)) continue;
                            const neighborId = rel.startNode === currentNode.id ? rel.endNode : rel.startNode;
                            const neighborNode = this.db.nodes.get(neighborId);
                            
                            const pathString = [...currentPath, rel].map(r => r.id).join('-');
                            if (visitedPaths.has(pathString)) continue;
                            visitedPaths.add(pathString);

                            const newPath = [...currentPath, rel];
                            const newDepth = newPath.length;

                            if (newDepth >= (relPattern?.minHops ?? 1)) {
                                const requiredLabels = endNodePattern.labels || [];
                                const endLabelMatch = requiredLabels.length === 0 || requiredLabels.some(l => neighborNode.labels.has(l));
                                const endPropsMatch = Object.entries(endNodePattern.properties || {}).every(([k,v]) => neighborNode.properties[k] === v);
                                if (endLabelMatch && endPropsMatch) {
                                    const resultRow = {
                                        [startNodePattern.variable]: this._formatNodeForOutput(startNode),
                                        [endNodePattern.variable]: this._formatNodeForOutput(neighborNode)
                                    };
                                    if (pathVar) {
                                        resultRow[pathVar] = {
                                            start: this._formatNodeForOutput(startNode),
                                            end: this._formatNodeForOutput(neighborNode),
                                            segments: newPath.map((r, i) => ({
                                                start: this._formatNodeForOutput(i === 0 ? startNode : this.db.nodes.get(newPath[i-1].endNode)),
                                                relationship: this._formatRelForOutput(r),
                                                end: this._formatNodeForOutput(this.db.nodes.get(r.endNode))
                                            }))
                                        };
                                    }
                                    finalResults.push(resultRow);
                                }
                            }
                            queue.push([neighborNode, newPath]);
                        }
                    }
                });
                return finalResults;
            }

            _applyWhere(results, whereClause) {
                const conditions = whereClause.split(/ AND /i).map(s => s.trim());
                return results.filter(row => {
                    return conditions.every(cond => {
                        const match = cond.match(/(\w+\.\w+)\s*([=><!]+)\s*(.*)/);
                        if (!match) return false;
                        const [, fullProp, operator, rawValue] = match;
                        const [variable, propName] = fullProp.split('.');
                        
                        const value = this._parseValue(rawValue);
                        const rowValue = row[variable]?.properties?.[propName];
                        if (rowValue === undefined) return false;

                        switch (operator) {
                            case '=': return rowValue == value;
                            case '!=': return rowValue != value;
                            case '>': return rowValue > value;
                            case '<': return rowValue < value;
                            case '>=': return rowValue >= value;
                            case '<=': return rowValue <= value;
                            default: return false;
                        }
                    });
                });
            }
            _applyWithOrReturn(results, clause) {
                const parts = clause.split(',').map(p => p.trim());
                
                const isAggregation = parts.some(p => /\w+\(.*\)/.test(p));

                if (isAggregation) {
                    const aggregated = {};
                    parts.forEach(part => {
                        const aggMatch = part.match(/(\w+)\((.*?)\)\s*(?:AS\s+(\w+))?/i);
                        if (aggMatch) {
                            const [, func, inner, alias] = aggMatch;
                            const key = alias || part;
                            
                            // Enhanced function evaluation with comprehensive Neo4j built-ins
                            // Path helper aggregation
                            if (func.toLowerCase() === 'nodes') {
                                aggregated[key] = results.map(r => (r[inner.trim()]?.segments||[])
                                    .map(seg => seg.start))
                                    .flat();
                                return;
                            } else if (func.toLowerCase() === 'relationships') {
                                aggregated[key] = results.map(r => (r[inner.trim()]?.segments||[])
                                    .map(seg => seg.relationship))
                                    .flat();
                                return;
                            } else if (func.toLowerCase() === 'length') {
                                aggregated[key] = results.map(r => (r[inner.trim()]?.segments||[]).filter(s => s.relationship).length)[0] ?? 0;
                                return;
                            }
                            const functionResult = this._evaluateCypherFunction(func, inner, results);
                            if (functionResult !== undefined) {
                                aggregated[key] = functionResult;
                            } else {
                                // Fallback to legacy handling
                                const values = results.map(row => {
                                    const [v, p] = inner.split('.');
                                    return p ? row[v]?.properties?.[p] : row[v];
                                }).filter(v => v !== undefined);

                                switch (func.toUpperCase()) {
                                    case 'COUNT': aggregated[key] = values.length; break;
                                    case 'SUM': aggregated[key] = values.reduce((a, b) => a + b, 0); break;
                                    case 'AVG': aggregated[key] = values.reduce((a, b) => a + b, 0) / values.length; break;
                                    case 'MIN': aggregated[key] = Math.min(...values); break;
                                    case 'MAX': aggregated[key] = Math.max(...values); break;
                                    case 'COLLECT': aggregated[key] = values; break;
                                }
                            }
                        }
                    });
                    return [aggregated];
                } else {
                    return results.map(row => {
                        const newRow = {};
                        parts.forEach(part => {
                            // Check for function calls in non-aggregated context
                            const funcMatch = part.match(/(\w+)\((.*?)\)\s*(?:AS\s+(\w+))?/i);
                            if (funcMatch) {
                                const [, func, inner, alias] = funcMatch;
                                const key = alias || part;
                                
                                // Path helper functions
                                if (func.toLowerCase() === 'nodes') {
                                    const pathObj = row[inner.trim()];
                                    const list = (pathObj?.segments || [])
                                        .filter(seg => seg.start || seg.node)
                                        .map(seg => seg.start || seg.node);
                                    newRow[key] = list;
                                    return;
                                } else if (func.toLowerCase() === 'relationships') {
                                    const pathObj = row[inner.trim()];
                                    const list = (pathObj?.segments || [])
                                        .filter(seg => seg.relationship)
                                        .map(seg => seg.relationship);
                                    newRow[key] = list;
                                    return;
                                } else if (func.toLowerCase() === 'length') {
                                    const pathObj = row[inner.trim()];
                                    const rels = (pathObj?.segments || []).filter(seg => seg.relationship).length;
                                    newRow[key] = rels;
                                    return;
                                }

                                const functionResult = this._evaluateCypherFunction(func, inner, [row]);
                                if (functionResult !== undefined) {
                                    newRow[key] = functionResult;
                                } else {
                                    // Fallback
                                    const [v, p] = inner.split('.');
                                    const value = p ? row[v]?.properties?.[p] : row[v];
                                    newRow[key] = value;
                                }
                            } else {
                                const alias = part.includes(' AS ') ? part.split(' AS ')[1].trim() : part;
                                const expr = part.includes(' AS ') ? part.split(' AS ')[0].trim() : part;
                                
                                if (expr.includes('.')) {
                                    const [v, p] = expr.split('.');
                                    newRow[alias] = row[v]?.properties?.[p];
                                } else {
                                    newRow[alias] = row[expr];
                                }
                            }
                        });
                        return newRow;
                    });
                }
            }
            
            // Comprehensive Cypher function evaluation
            _evaluateCypherFunction(funcName, args, context) {
                const func = funcName.toUpperCase();
                const argParts = args ? args.split(',').map(a => a.trim()) : [];
                
                // Helper to get value from context
                const getValue = (expr) => {
                    if (!expr || !context || context.length === 0) return undefined;
                    const row = context[0];
                    
                    if (expr.includes('.')) {
                        const [v, p] = expr.split('.');
                        return row[v]?.properties?.[p] || row[v]?.[p];
                    }
                    return row[expr] || expr;
                };
                
                const getValues = (expr) => {
                    return context.map(row => {
                        if (expr.includes('.')) {
                            const [v, p] = expr.split('.');
                            return row[v]?.properties?.[p] || row[v]?.[p];
                        }
                        return row[expr];
                    }).filter(v => v !== undefined);
                };

                switch (func) {
                    // Aggregation functions
                    case 'COUNT':
                        if (args === '*') return context.length;
                        return getValues(args).length;
                    case 'SUM':
                        return getValues(args).reduce((a, b) => a + b, 0);
                    case 'AVG':
                        const avgValues = getValues(args);
                        return avgValues.length > 0 ? avgValues.reduce((a, b) => a + b, 0) / avgValues.length : null;
                    case 'MIN':
                        const minValues = getValues(args);
                        return minValues.length > 0 ? Math.min(...minValues) : null;
                    case 'MAX':
                        const maxValues = getValues(args);
                        return maxValues.length > 0 ? Math.max(...maxValues) : null;
                    case 'COLLECT':
                        return getValues(args);
                    case 'STDEV':
                        const stdevValues = getValues(args);
                        if (stdevValues.length === 0) return null;
                        const mean = stdevValues.reduce((a, b) => a + b, 0) / stdevValues.length;
                        const variance = stdevValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / stdevValues.length;
                        return Math.sqrt(variance);
                    case 'STDEVP':
                        const stdevpValues = getValues(args);
                        if (stdevpValues.length === 0) return null;
                        const meanP = stdevpValues.reduce((a, b) => a + b, 0) / stdevpValues.length;
                        const varianceP = stdevpValues.reduce((sum, val) => sum + Math.pow(val - meanP, 2), 0) / (stdevpValues.length - 1);
                        return Math.sqrt(varianceP);
                    case 'PERCENTILECONT':
                    case 'PERCENTILEDISC':
                        const percentile = parseFloat(argParts[0]);
                        const percValues = getValues(argParts[1]).sort((a, b) => a - b);
                        if (percValues.length === 0) return null;
                        const index = (percentile / 100) * (percValues.length - 1);
                        return func === 'PERCENTILECONT' 
                            ? percValues[Math.floor(index)] + (percValues[Math.ceil(index)] - percValues[Math.floor(index)]) * (index - Math.floor(index))
                            : percValues[Math.round(index)];
                            
                    // String functions
                    case 'TOLOWER':
                        return String(getValue(args)).toLowerCase();
                    case 'TOUPPER':
                        return String(getValue(args)).toUpperCase();
                    case 'TRIM':
                        return String(getValue(args)).trim();
                    case 'LTRIM':
                        return String(getValue(args)).replace(/^\s+/, '');
                    case 'RTRIM':
                        return String(getValue(args)).replace(/\s+$/, '');
                    case 'REVERSE':
                        return String(getValue(args)).split('').reverse().join('');
                    case 'SIZE':
                        const sizeValue = getValue(args);
                        if (Array.isArray(sizeValue)) return sizeValue.length;
                        if (typeof sizeValue === 'string') return sizeValue.length;
                        return null;
                    case 'LENGTH':
                        return String(getValue(args)).length;
                    case 'SUBSTRING':
                        const str = String(getValue(argParts[0]));
                        const startPos = parseInt(argParts[1]) || 0;
                        const length = argParts[2] ? parseInt(argParts[2]) : undefined;
                        return length !== undefined ? str.substring(startPos, startPos + length) : str.substring(startPos);
                    case 'LEFT':
                        return String(getValue(argParts[0])).slice(0, parseInt(argParts[1]) || 0);
                    case 'RIGHT':
                        const rightStr = String(getValue(argParts[0]));
                        const rightLen = parseInt(argParts[1]) || 0;
                        return rightStr.slice(-rightLen);
                    case 'SPLIT':
                        return String(getValue(argParts[0])).split(argParts[1].replace(/['"]/g, ''));
                    case 'REPLACE':
                        return String(getValue(argParts[0])).replace(
                            new RegExp(argParts[1].replace(/['"]/g, ''), 'g'),
                            argParts[2].replace(/['"]/g, '')
                        );
                    case 'CONTAINS':
                        return String(getValue(argParts[0])).includes(argParts[1].replace(/['"]/g, ''));
                    case 'STARTSWITH':
                        return String(getValue(argParts[0])).startsWith(argParts[1].replace(/['"]/g, ''));
                    case 'ENDSWITH':
                        return String(getValue(argParts[0])).endsWith(argParts[1].replace(/['"]/g, ''));
                        
                    // Mathematical functions
                    case 'ABS':
                        return Math.abs(getValue(args));
                    case 'CEIL':
                        return Math.ceil(getValue(args));
                    case 'FLOOR':
                        return Math.floor(getValue(args));
                    case 'ROUND':
                        const roundValue = getValue(argParts[0]);
                        const precision = argParts[1] ? parseInt(argParts[1]) : 0;
                        return Math.round(roundValue * Math.pow(10, precision)) / Math.pow(10, precision);
                    case 'SIGN':
                        const signValue = getValue(args);
                        return signValue > 0 ? 1 : signValue < 0 ? -1 : 0;
                    case 'SQRT':
                        return Math.sqrt(getValue(args));
                    case 'SIN':
                        return Math.sin(getValue(args));
                    case 'COS':
                        return Math.cos(getValue(args));
                    case 'TAN':
                        return Math.tan(getValue(args));
                    case 'ASIN':
                        return Math.asin(getValue(args));
                    case 'ACOS':
                        return Math.acos(getValue(args));
                    case 'ATAN':
                        return Math.atan(getValue(args));
                    case 'ATAN2':
                        return Math.atan2(getValue(argParts[0]), getValue(argParts[1]));
                    case 'COT':
                        return 1 / Math.tan(getValue(args));
                    case 'DEGREES':
                        return getValue(args) * (180 / Math.PI);
                    case 'RADIANS':
                        return getValue(args) * (Math.PI / 180);
                    case 'LOG':
                        return Math.log(getValue(args));
                    case 'LOG10':
                        return Math.log10(getValue(args));
                    case 'EXP':
                        return Math.exp(getValue(args));
                    case 'E':
                        return Math.E;
                    case 'PI':
                        return Math.PI;
                    case 'RAND':
                        return Math.random();
                    case 'RANGE':
                        const rangeStart = parseInt(argParts[0]) || 0;
                        const rangeEnd = parseInt(argParts[1]) || 0;
                        const rangeStep = parseInt(argParts[2]) || 1;
                        const range = [];
                        for (let i = rangeStart; i <= rangeEnd; i += rangeStep) {
                            range.push(i);
                        }
                        return range;
                        
                    // List functions
                    case 'HEAD':
                        const headList = getValue(args);
                        return Array.isArray(headList) ? headList[0] : null;
                    case 'TAIL':
                        const tailList = getValue(args);
                        return Array.isArray(tailList) ? tailList.slice(1) : null;
                    case 'LAST':
                        const lastList = getValue(args);
                        return Array.isArray(lastList) ? lastList[lastList.length - 1] : null;
                    case 'EXTRACT':
                        // Simplified EXTRACT implementation
                        const extractList = getValue(argParts[1]);
                        const extractExpr = argParts[0];
                        return Array.isArray(extractList) ? extractList.map(item => item) : null;
                    case 'FILTER':
                        // Simplified FILTER implementation
                        const filterList = getValue(argParts[1]);
                        return Array.isArray(filterList) ? filterList.filter(item => item !== null) : null;
                    case 'REDUCE':
                        // Simplified REDUCE implementation
                        const reduceList = getValue(argParts[2]);
                        const initialValue = getValue(argParts[1]);
                        return Array.isArray(reduceList) ? reduceList.reduce((acc, val) => acc + val, initialValue) : initialValue;
                        
                    // Node/Relationship functions
                    case 'ID':
                        const idValue = getValue(args);
                        return idValue?.id || idValue;
                    case 'TYPE':
                        const typeValue = getValue(args);
                        return typeValue?.type || typeValue?.label;
                    case 'LABELS':
                        const labelsValue = getValue(args);
                        return labelsValue?.label ? [labelsValue.label] : [];
                    case 'KEYS':
                        const keysValue = getValue(args);
                        return keysValue?.properties ? Object.keys(keysValue.properties) : [];
                    case 'PROPERTIES':
                        const propsValue = getValue(args);
                        return propsValue?.properties || {};
                    case 'STARTNODE':
                        const startRel = getValue(args);
                        return startRel?.startNode;
                    case 'ENDNODE':
                        const endRel = getValue(args);
                        return endRel?.endNode;
                        
                    // Date/Time functions
                    case 'DATE':
                        if (!args || args === '()') return new Date().toISOString().split('T')[0];
                        return new Date(getValue(args)).toISOString().split('T')[0];
                    case 'DATETIME':
                        if (!args || args === '()') return new Date().toISOString();
                        return new Date(getValue(args)).toISOString();
                    case 'TIME':
                        if (!args || args === '()') return new Date().toTimeString().split(' ')[0];
                        return new Date(getValue(args)).toTimeString().split(' ')[0];
                    case 'TIMESTAMP':
                        return Date.now();
                    case 'DURATION':
                        // Simplified duration - return as string
                        return `P${argParts[0] || 0}DT${argParts[1] || 0}H${argParts[2] || 0}M${argParts[3] || 0}S`;
                        
                    // Type checking functions
                    case 'EXISTS':
                        return getValue(args) !== undefined && getValue(args) !== null;
                    case 'ISNULL':
                        return getValue(args) === null || getValue(args) === undefined;
                    case 'ISNAN':
                        return isNaN(getValue(args));
                    case 'ISINF':
                        return !isFinite(getValue(args));
                        
                    // Comparison functions
                    case 'COALESCE':
                        for (const arg of argParts) {
                            const val = getValue(arg);
                            if (val !== null && val !== undefined) return val;
                        }
                        return null;
                    case 'CASE':
                        // Simplified CASE implementation
                        return getValue(argParts[0]);
                    
                    // Additional string functions
                    case 'LPAD':
                        const lpadStr = String(getValue(argParts[0]));
                        const lpadLen = getValue(argParts[1]);
                        const lpadChar = argParts[2] ? String(getValue(argParts[2])) : ' ';
                        return lpadStr.padStart(lpadLen, lpadChar);
                    case 'RPAD':
                        const rpadStr = String(getValue(argParts[0]));
                        const rpadLen = getValue(argParts[1]);
                        const rpadChar = argParts[2] ? String(getValue(argParts[2])) : ' ';
                        return rpadStr.padEnd(rpadLen, rpadChar);
                    case 'UPPER':
                        return String(getValue(argParts[0])).toUpperCase();
                    case 'LOWER':
                        return String(getValue(argParts[0])).toLowerCase();
                    
                    // Additional math functions
                    case 'POWER':
                        return Math.pow(getValue(argParts[0]), getValue(argParts[1]));
                    case 'MOD':
                        return getValue(argParts[0]) % getValue(argParts[1]);
                    case 'FACTORIAL':
                        const factNum = getValue(argParts[0]);
                        let result = 1;
                        for (let i = 2; i <= factNum; i++) result *= i;
                        return result;
                    case 'GCD':
                        let a = getValue(argParts[0]), b = getValue(argParts[1]);
                        while (b !== 0) { const temp = b; b = a % b; a = temp; }
                        return a;
                    case 'LCM':
                        const gcdVal = this._evaluateBuiltinFunction('GCD', argParts, nodeVars);
                        return (getValue(argParts[0]) * getValue(argParts[1])) / gcdVal;
                    
                    // Additional date/time functions
                    case 'NOW':
                        return new Date();
                    case 'LOCALDATETIME':
                        return new Date().toISOString().slice(0, 19);
                    case 'LOCALTIME':
                        return new Date().toTimeString().slice(0, 8);
                    case 'YEAR':
                        return new Date(getValue(argParts[0])).getFullYear();
                    case 'MONTH':
                        return new Date(getValue(argParts[0])).getMonth() + 1;
                    case 'DAY':
                        return new Date(getValue(argParts[0])).getDate();
                    case 'HOUR':
                        return new Date(getValue(argParts[0])).getHours();
                    case 'MINUTE':
                        return new Date(getValue(argParts[0])).getMinutes();
                    case 'SECOND':
                        return new Date(getValue(argParts[0])).getSeconds();
                    
                    // Additional list functions
                    case 'ALL':
                        const allList = getValue(argParts[0]);
                        const allPredicate = argParts[1];
                        return Array.isArray(allList) ? allList.every(item => this._evaluateExpression(allPredicate, {...nodeVars, item})) : false;
                    case 'ANY':
                        const anyList = getValue(argParts[0]);
                        const anyPredicate = argParts[1];
                        return Array.isArray(anyList) ? anyList.some(item => this._evaluateExpression(anyPredicate, {...nodeVars, item})) : false;
                    case 'NONE':
                        const noneList = getValue(argParts[0]);
                        const nonePredicate = argParts[1];
                        return Array.isArray(noneList) ? !noneList.some(item => this._evaluateExpression(nonePredicate, {...nodeVars, item})) : true;
                    case 'SINGLE':
                        const singleList = getValue(argParts[0]);
                        const singlePredicate = argParts[1];
                        if (!Array.isArray(singleList)) return false;
                        const matches = singleList.filter(item => this._evaluateExpression(singlePredicate, {...nodeVars, item}));
                        return matches.length === 1;
                    
                    // Additional type functions
                    case 'TOBOOL':
                        const boolVal = getValue(argParts[0]);
                        if (typeof boolVal === 'boolean') return boolVal;
                        if (typeof boolVal === 'string') return boolVal.toLowerCase() === 'true';
                        return Boolean(boolVal);
                    case 'TOFLOAT':
                        return parseFloat(getValue(argParts[0]));
                    case 'TOINT':
                        return parseInt(getValue(argParts[0]));
                    case 'TOSTRING':
                        return String(getValue(argParts[0]));
                    
                    // Additional spatial functions
                    case 'DISTANCE':
                        const point1 = getValue(argParts[0]);
                        const point2 = getValue(argParts[1]);
                        if (point1?.x !== undefined && point2?.x !== undefined) {
                            return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
                        }
                        return null;
                    case 'POINT':
                        return { x: getValue(argParts[0]), y: getValue(argParts[1]) };
                    
                    // Additional utility functions
                    case 'RANDOMUUID':
                        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                            const r = Math.random() * 16 | 0;
                            const v = c === 'x' ? r : (r & 0x3 | 0x8);
                            return v.toString(16);
                        });
                    case 'HAVERSIN':
                        return (1 - Math.cos(getValue(argParts[0]))) / 2;
                    case 'SHORTESTPATH':
                        // Simplified shortest path
                        return getValue(argParts[0]);
                        
                    default:
                        return undefined;
                }
            }
            
            _applyOrderBy(results, orderByClause) {
                const [fullProp, direction = 'ASC'] = orderByClause.split(/\s+/);
                const [variable, propName] = fullProp.split('.');
                
                results.sort((a, b) => {
                    const valA = propName ? a[variable]?.properties?.[propName] : a[variable];
                    const valB = propName ? b[variable]?.properties?.[propName] : b[variable];
                    if (valA < valB) return direction.toUpperCase() === 'ASC' ? -1 : 1;
                    if (valA > valB) return direction.toUpperCase() === 'ASC' ? 1 : -1;
                    return 0;
                });
                return results;
            }


            _handleDelete(match) {
                const [, pattern, deleteType, deleteVars] = match;
                let deletedCount = 0;
                const variable = deleteVars.trim();
                
                const nodePattern = this._parseNodePattern(pattern);
                const relPattern = this._parseRelPattern(pattern);

                if (pattern.includes(`(${variable})`) || pattern.includes(`(${variable}:`)) {
                    const nodesToDelete = this.db.findNodes(nodePattern.label, nodePattern.properties);
                    nodesToDelete.forEach(node => {
                        if (deleteType.toUpperCase().startsWith('DETACH')) this.db.detachDeleteNode(node.id);
                        else this.db.deleteNode(node.id);
                        deletedCount++;
                    });
                } else if (pattern.includes(`[${variable}]`) || pattern.includes(`[${variable}:`)) {
                    let relsToDelete = [];
                    if (relPattern && relPattern.types && relPattern.types.length > 1) {
                        // manual filter any-of types
                        this.db.relationships.forEach(rel => {
                            if (!relPattern.types.includes(rel.type)) return;
                            let ok = true;
                            for (const [k,v] of Object.entries(relPattern.properties||{})) {
                                if (rel.properties[k] !== v) { ok = false; break; }
                            }
                            if (ok) relsToDelete.push(rel);
                        });
                    } else {
                        relsToDelete = this.db.findRelationships(relPattern.type, relPattern.properties);
                    }
                    relsToDelete.forEach(rel => {
                        this.db.deleteRelationship(rel.id);
                        deletedCount++;
                    });
                } else { throw new Error(`Invalid DELETE target: ${deleteVars}`); }
                
                return { type: 'delete', message: `Deleted ${deletedCount} entities.`, result: [] };
            }

            _handleSet(query) {
                const match = query.match(/(?:MATCH|MERGE)\s+(.*?)\s+SET\s+(.*)$/i);
                if (!match) throw new Error("Invalid SET syntax. Must be preceded by MATCH or MERGE.");
                const [, pattern, setClause] = match;
                const nodePattern = this._parseNodePattern(pattern);
                const nodes = this.db.findNodes(nodePattern.label, nodePattern.properties);
                if (nodes.length === 0) return { type: 'update', message: "Set 0 properties, node not found.", result: [] };
                
                this._applySetToNodes(nodes, setClause);
                return { type: 'update', message: `Set properties/labels.`, result: [] };
            }

            _applySetToNodes(nodes, setClause) {
                const assignments = setClause.split(',').map(s => s.trim());
                
                nodes.forEach(node => {
                    assignments.forEach(assignment => {
                        if (assignment.includes('=')) {
                            const [fullVar, valueStr] = assignment.split('=').map(s => s.trim());
                            const [variable, propName] = fullVar.split('.');
                            if (!propName) throw new Error(`Invalid property assignment: ${assignment}`);
                            node.properties[propName] = this._parseValue(valueStr);
                        } else if (assignment.includes(':')) {
                            const [variable, label] = assignment.split(':').map(s => s.trim());
                            if (!label) throw new Error(`Invalid label assignment: ${assignment}`);
                            node.labels.add(label);
                            if (!this.db.labelsToNodes.has(label)) this.db.labelsToNodes.set(label, new Set());
                            this.db.labelsToNodes.get(label).add(node.id);
                        } else {
                            throw new Error(`Invalid SET clause: ${assignment}`);
                        }
                    });
                });
            }

            _handleRemove(query) {
                const match = query.match(/MATCH\s+(.*?)\s+REMOVE\s+(.*)$/i);
                if (!match) throw new Error("Invalid REMOVE syntax.");
                const [, pattern, removeClause] = match;
                const nodePattern = this._parseNodePattern(pattern);
                const nodes = this.db.findNodes(nodePattern.label, nodePattern.properties);
                if (nodes.length === 0) return { type: 'update', message: "Removed 0 properties, node not found.", result: [] };

                let removedCount = 0;
                nodes.forEach(node => {
                    const removeAssignments = removeClause.split(',').map(s => s.trim());
                    removeAssignments.forEach(assignment => {
                         if (assignment.includes('.')) {
                            const [variable, propName] = assignment.split('.');
                            delete node.properties[propName];
                            removedCount++;
                        } else if (assignment.includes(':')) {
                            const [variable, label] = assignment.split(':');
                            node.labels.delete(label);
                            this.db.labelsToNodes.get(label)?.delete(node.id);
                            removedCount++;
                        }
                    });
                });
                return { type: 'update', message: `Removed ${removedCount} properties/labels.`, result: [] };
            }

            _handleMerge(query) {
                const mergeMatch = query.match(/MERGE\s+(\(.*\))/i);
                if (!mergeMatch) throw new Error("Only simple MERGE (node) is supported.");
                
                const nodePattern = this._parseNodePattern(mergeMatch[1]);
                const existingNodes = this.db.findNodes(nodePattern.label, nodePattern.properties);

                let wasCreated = false;
                let targetNode;

                if (existingNodes.length > 0) {
                    targetNode = existingNodes[0];
                } else {
                    const { label, properties } = nodePattern;
                    targetNode = this.db.createNode(label ? [label] : [], properties);
                    wasCreated = true;
                }

                const onCreateMatch = query.match(/ON CREATE SET\s+(.*?)(?=\s+ON MATCH|$)/i);
                const onMatchMatch = query.match(/ON MATCH SET\s+(.*)/i);

                if (wasCreated && onCreateMatch) {
                    this._applySetToNodes([targetNode], onCreateMatch[1]);
                } else if (!wasCreated && onMatchMatch) {
                    this._applySetToNodes([targetNode], onMatchMatch[1]);
                }

                const message = wasCreated ? "Created 1 node." : "Matched 1 node.";
                return { type: wasCreated ? 'create' : 'read', message, result: [this._formatNodeForOutput(targetNode)] };
            }

            _handleUnwind(query) {
                const unwindMatch = query.match(/UNWIND\s+(.*?)\s+AS\s+(\w+)/i);
                if (!unwindMatch) throw new Error("Invalid UNWIND syntax.");
                
                let [, listStr, variable] = unwindMatch;
                let list;
                try {
                    list = JSON.parse(listStr.replace(/'/g, '"'));
                } catch(e) {
                    throw new Error("UNWIND expects a literal list.");
                }

                const results = list.map(item => ({ [variable]: item }));
                
        const createMatch = query.match(/CREATE\s+(.*)/i);
                if (createMatch) {
                    let createdCount = 0;
                    results.forEach(row => {
                        let nodePatternStr = createMatch[1];
                        if(nodePatternStr.includes(variable)) {
                            const propValue = typeof row[variable] === 'string' ? `'${row[variable]}'` : row[variable];
                            nodePatternStr = nodePatternStr.replace(new RegExp(`{\\s*title:\\s*${variable}\\s*}`, 'g'), `{title: ${propValue}}`);
                        }
                        const nodePattern = this._parseNodePattern(nodePatternStr);
            const labels = (nodePattern.labels && nodePattern.labels.length > 0) ? nodePattern.labels : [];
            this.db.createNode(labels, nodePattern.properties);
                        createdCount++;
                    });
                    return { type: 'create', message: `Created ${createdCount} nodes.`, result: [] };
                }

                return { type: 'read', message: `Unwound ${results.length} items.`, result: results };
            }

            _handleCreateConstraint(query) {
                const nameMatch = query.match(/CREATE\s+CONSTRAINT\s+(\w+)\s+ON/i);
                const match = query.match(/CREATE\s+CONSTRAINT(?:\s+\w+)?\s+ON\s+\((\w+):(\w+)\)\s+ASSERT\s+(\w+\.\w+)\s+IS\s+UNIQUE/i);
                if (!match) throw new Error("Invalid CONSTRAINT syntax.");
                const [, variable, label, property] = match;
                const key = property.split('.')[1];
                const constraintKey = `${label}.${key}`;
                if (this.db.constraints.has(constraintKey)) {
                    throw new Error(`Constraint on :${label}(${key}) already exists.`);
                }
                this.db.constraints.set(constraintKey, new Set());
                if (nameMatch) this.db.constraintNames.set(nameMatch[1], constraintKey);
                return { type: 'db_manage', message: `Constraint created on :${label}(${key}).` };
            }

            _handleCreateIndex(query) {
                const match = query.match(/CREATE INDEX ON :(\w+)\((\w+)\)/i);
                if (!match) throw new Error("Invalid CREATE INDEX syntax. Use: CREATE INDEX ON :Label(property)");
                const [, label, property] = match;
                const indexKey = `${label}.${property}`;
                if (this.db.indexes.has(indexKey)) {
                    throw new Error(`Index on :${label}(${property}) already exists.`);
                }
                this.db.indexes.set(indexKey, new Map());
                return { type: 'db_manage', message: `Index created on :${label}(${property}).` };
            }

            _handleHelp(query) {
                const helpText = `
🔍 Cypher Query Console - Available Commands:

📊 READING DATA:
  MATCH (n) RETURN n                    - Get all nodes
  MATCH (n:Label) RETURN n              - Get nodes by label
  MATCH (n {property: 'value'}) RETURN n - Get nodes by property
  MATCH (a)-[r]->(b) RETURN a, r, b     - Get relationships
  MATCH p = (a)-[*1..3]-(b) RETURN p    - Variable length paths

✏️ CREATING DATA:
  CREATE (n:Person {name: 'Alice'})     - Create node with label and properties
  CREATE (a)-[:KNOWS]->(b)              - Create relationship
  MERGE (n:Person {name: 'Bob'})        - Find or create node

🔧 UPDATING DATA:
  SET n.age = 30                        - Set property
  SET n:NewLabel                        - Add label
  REMOVE n.property                     - Remove property
  REMOVE n:Label                        - Remove label

🗑️ DELETING DATA:
  DELETE n                              - Delete node (must not have relationships)
  DETACH DELETE n                       - Delete node and all its relationships
  DELETE r                              - Delete relationship

🔍 FILTERING & PROCESSING:
  WHERE n.age > 25                      - Filter results
  ORDER BY n.name ASC                   - Sort results
  LIMIT 10                              - Limit number of results
  WITH n.name AS name RETURN name       - Pipe results between clauses

📊 AGGREGATION:
  RETURN count(*)                       - Count results
  RETURN collect(n.name)                - Collect values into list
  UNWIND [1,2,3] AS x RETURN x         - Expand list into rows

🛠️ BUILT-IN FUNCTIONS:
  String: toUpper(), toLower(), split(), replace(), substring()
  Math: abs(), round(), sqrt(), rand()
  Collection: size(), head(), tail(), range()
    Path: shortestPath(), allShortestPaths()

🏗️ SCHEMA:
  CREATE CONSTRAINT ON (n:Label) ASSERT n.property IS UNIQUE
  CREATE INDEX ON :Label(property)
    DROP INDEX ON :Label(property)
    SHOW CONSTRAINTS
    SHOW STATS

💾 DATABASE:
  USE database_name                     - Switch database
  CALL db.labels()                      - List all labels
  CALL db.propertyKeys()                - List all properties

💡 TIPS:
  - Use () for nodes, [] for relationships
  - Relationships are always directed: -->
  - Use : for labels, {} for properties
  - Variables can be any name (n, node, person, etc.)
  - String values must be in single quotes: 'value'
`;
                return { type: 'help', message: helpText, result: [] };
            }

            _handleDropIndex(query) {
                const match = query.match(/DROP INDEX ON :(\w+)\((\w+)\)/i);
                if (!match) throw new Error("Invalid DROP INDEX syntax. Use: DROP INDEX ON :Label(property)");
                const [, label, property] = match;
                const indexKey = `${label}.${property}`;
                if (!this.db.indexes.has(indexKey)) {
                    throw new Error(`Index on :${label}(${property}) does not exist.`);
                }
                this.db.indexes.delete(indexKey);
                return { type: 'db_manage', message: `Index on :${label}(${property}) dropped.` };
            }

            _handleDropConstraint(query) {
                // Support both named and anonymous: DROP CONSTRAINT constraint_name OR by pattern
                // Here we support the simple pattern form: DROP CONSTRAINT ON (n:Label) ASSERT n.prop IS UNIQUE
                const byPattern = query.match(/DROP\s+CONSTRAINT\s+ON\s*\(\w+:(\w+)\)\s+ASSERT\s+\w+\.(\w+)\s+IS\s+UNIQUE/i);
                if (byPattern) {
                    const [, label, prop] = byPattern;
                    const key = `${label}.${prop}`;
                    if (!this.db.constraints.has(key)) throw new Error(`Constraint on :${label}(${prop}) does not exist.`);
                    this.db.constraints.delete(key);
                    return { type: 'db_manage', message: `Constraint on :${label}(${prop}) dropped.` };
                }
                // Named style (best-effort): DROP CONSTRAINT name
                const byName = query.match(/DROP\s+CONSTRAINT\s+(\w+)/i);
                if (byName) {
                    const name = byName[1];
                    const key = this.db.constraintNames.get(name);
                    if (key && this.db.constraints.has(key)) {
                        this.db.constraints.delete(key);
                        this.db.constraintNames.delete(name);
                        return { type: 'db_manage', message: `Constraint ${name} dropped.` };
                    }
                    throw new Error(`Constraint ${name} not found.`);
                }
                throw new Error('Invalid DROP CONSTRAINT syntax.');
            }

            _handleShow(query) {
                const upper = query.toUpperCase();
                if (upper.startsWith('SHOW CONSTRAINTS')) {
                    const rows = [];
                    this.db.constraints.forEach((_, key) => {
                        const [label, property] = key.split('.');
                        rows.push({ name: `${label}_${property}_unique`, type: 'UNIQUE', entityType: 'NODE', labelsOrTypes: [label], properties: [property] });
                    });
                    return { type: 'tabular', columns: ['name','type','entityType','labelsOrTypes','properties'], data: rows };
                }
                if (upper.startsWith('SHOW INDEXES')) {
                    const rows = [];
                    this.db.indexes.forEach((_, key) => {
                        const [label, property] = key.split('.');
                        rows.push({ entityType: 'NODE', labelsOrTypes: [label], properties: [property] });
                    });
                    return { type: 'tabular', columns: ['entityType','labelsOrTypes','properties'], data: rows };
                }
                if (upper.startsWith('SHOW STATS')) {
                    const labels = new Set();
                    this.db.nodes.forEach(n => n.labels.forEach(l => labels.add(l)));
                    const relTypes = new Set();
                    this.db.relationships.forEach(r => relTypes.add(r.type));
                    const nodeCount = this.db.nodes.size;
                    const relCount = this.db.relationships.size;
                    const avgDegree = nodeCount > 0 ? (relCount * 2) / nodeCount : 0;
                    const rows = [
                        { metric: 'nodes', value: nodeCount },
                        { metric: 'relationships', value: relCount },
                        { metric: 'labels', value: labels.size },
                        { metric: 'relationshipTypes', value: relTypes.size },
                        { metric: 'avgDegree', value: Number(avgDegree.toFixed(2)) },
                    ];
                    return { type: 'tabular', columns: ['metric','value'], data: rows };
                }
                if (upper.startsWith('SHOW DATABASES')) {
                    const rows = [];
                    this.dbManager.databases.forEach((_, name) => {
                        rows.push({ name, current: name === this.dbManager.currentDbName });
                    });
                    return { type: 'tabular', columns: ['name','current'], data: rows };
                }
                if (upper.startsWith('SHOW TRANSACTIONS')) {
                    // Minimal emulation: single-session transaction state
                    const rows = [];
                    if (this.inTransaction) {
                        rows.push({ id: 'tx-1', state: 'Active' });
                    }
                    return { type: 'tabular', columns: ['id','state'], data: rows };
                }
                throw new Error('Unsupported SHOW command. Supported: SHOW CONSTRAINTS, SHOW STATS');
            }

            _handleCall(query) {
                const procedureMatch = query.match(/CALL\s+(\w+(?:\.\w+)*)\((.*?)\)(?:\s+YIELD\s+(.*))?/i);
                if (!procedureMatch) throw new Error("Invalid CALL syntax.");
                
                const [, procedureName, argsStr, yieldFields] = procedureMatch;
                
                // Built-in procedures
                if (procedureName === 'db.labels') {
                    const labels = new Set();
                    this.db.nodes.forEach(node => node.labels.forEach(label => labels.add(label)));
                    return { type: 'tabular', columns: ['label'], data: Array.from(labels).map(label => ({ label })) };
                } else if (procedureName === 'db.relationshipTypes') {
                    const types = new Set();
                    this.db.relationships.forEach(rel => types.add(rel.type));
                    return { type: 'tabular', columns: ['relationshipType'], data: Array.from(types).map(type => ({ relationshipType: type })) };
                } else if (procedureName === 'db.propertyKeys') {
                    const keys = new Set();
                    this.db.nodes.forEach(node => Object.keys(node.properties).forEach(key => keys.add(key)));
                    this.db.relationships.forEach(rel => Object.keys(rel.properties).forEach(key => keys.add(key)));
                    return { type: 'tabular', columns: ['propertyKey'], data: Array.from(keys).map(key => ({ propertyKey: key })) };
                } else if (procedureName === 'db.schema') {
                    const schema = [];
                    this.db.constraints.forEach((value, key) => {
                        const [label, property] = key.split('.');
                        schema.push({ type: 'CONSTRAINT', description: `UNIQUE constraint on :${label}(${property})` });
                    });
                    this.db.indexes.forEach((value, key) => {
                        const [label, property] = key.split('.');
                        schema.push({ type: 'INDEX', description: `INDEX on :${label}(${property})` });
                    });
                    return { type: 'tabular', columns: ['type', 'description'], data: schema };
                } else if (procedureName === 'db.indexes') {
                    const rows = [];
                    this.db.indexes.forEach((value, key) => {
                        const [label, property] = key.split('.');
                        rows.push({ label, property });
                    });
                    return { type: 'tabular', columns: ['label','property'], data: rows };
                } else if (procedureName === 'db.constraints') {
                    const rows = [];
                    this.db.constraints.forEach((value, key) => {
                        const [label, property] = key.split('.');
                        rows.push({ type: 'UNIQUE', label, property });
                    });
                    return { type: 'tabular', columns: ['type','label','property'], data: rows };
                } else {
                    throw new Error(`Unknown procedure: ${procedureName}`);
                }
            }

            _handleForeach(query) {
                const match = query.match(/FOREACH\s*\(\s*(\w+)\s+IN\s+(.*?)\s*\|\s*(.*?)\s*\)/i);
                if (!match) throw new Error("Invalid FOREACH syntax.");
                
                const [, variable, collection, statement] = match;
                
                // Simple implementation - execute statement for each item in collection
                const results = [];
                
                // For demo purposes, assume collection is a simple list
                const listMatch = collection.match(/\[(.*?)\]/);
                if (listMatch) {
                    const items = listMatch[1].split(',').map(item => item.trim().replace(/['"]/g, ''));
                    items.forEach(item => {
                        const modifiedStatement = statement.replace(new RegExp(variable, 'g'), `'${item}'`);
                        try {
                            const result = this.executeQuery(modifiedStatement);
                            results.push(result);
                        } catch (e) {
                            // Continue with other items
                        }
                    });
                }
                
                return { type: 'db_manage', message: `FOREACH completed. Executed ${results.length} statements.` };
            }

            _handlePathFunctions(query) {
                // Enhanced shortestPath/allShortestPaths with type and hop bounds and directional arrows
                const isAll = /allShortestPaths\s*\(/i.test(query);
                const fnRe = isAll
                    ? /allShortestPaths\(\s*(\(.+?\)\s*<?-\s*\[.*?\]\s*-\>?\s*\(.+?\))\s*\)/i
                    : /shortestPath\(\s*(\(.+?\)\s*<?-\s*\[.*?\]\s*-\>?\s*\(.+?\))\s*\)/i;
                const m = query.match(fnRe);
                if (!m) throw new Error("Invalid path function syntax.");

                const pattern = m[1];
                // Split around the relationship pattern, honoring optional arrows
                const nodeParts = pattern.split(/<?-\s*\[.*?\]\s*-\>?/);
                if (nodeParts.length !== 2) throw new Error("Invalid pattern inside path function.");
                const startPattern = nodeParts[0].trim().replace(/^\(|\)$/g, '');
                const endPattern = nodeParts[1].trim().replace(/^\(|\)$/g, '');

                const relSpecMatch = pattern.match(/<?-\s*\[(\w*)?:?([^\]\s\*]*)?\s*(\*\d*(?:\.\.\d*)?)?\]\s*-\>?/i);
                const relTypes = relSpecMatch && relSpecMatch[2]
                    ? relSpecMatch[2].split('|').map(s => s.trim()).filter(Boolean)
                    : [];
                const lenSpec = relSpecMatch && relSpecMatch[3] ? relSpecMatch[3] : null;
                let minHops = 1, maxHops = Infinity;
                if (lenSpec) {
                    const cleaned = lenSpec.replace('*', '');
                    if (cleaned.includes('..')) {
                        const [a, b] = cleaned.split('..');
                        minHops = a ? parseInt(a) : 1;
                        maxHops = b ? parseInt(b) : Infinity;
                    } else {
                        minHops = cleaned ? parseInt(cleaned) : 1;
                        maxHops = minHops;
                    }
                }

                const dir = (pattern.includes('->') && !pattern.includes('<-')) ? 'out' : (pattern.includes('<-') && !pattern.includes('->')) ? 'in' : 'any';
                const startNodes = this._findNodesByPattern(startPattern);
                const endNodes = this._findNodesByPattern(endPattern);
                if (startNodes.length === 0 || endNodes.length === 0) {
                    return { type: 'tabular', columns: ['path'], data: [] };
                }
                const options = { relTypes, minHops, maxHops, dir };
                const rows = [];
                for (const s of startNodes) {
                    for (const e of endNodes) {
                        if (isAll) {
                            const paths = this._findAllShortestPaths(s.id, e.id, options);
                            for (const p of paths) rows.push({ path: this._formatPath(p) });
                        } else {
                            const p = this._findShortestPathFiltered(s.id, e.id, options);
                            if (p.length > 0) rows.push({ path: this._formatPath(p) });
                        }
                    }
                }
                return { type: 'tabular', columns: ['path'], data: rows };
            }

            _neighborsOf(nodeId, options) {
                const { relTypes = [], dir = 'any' } = options || {};
                const out = [];
                this.db.relationships.forEach(rel => {
                    if (rel.startNode === nodeId) {
                        if (relTypes.length > 0 && !relTypes.includes(rel.type)) return;
                        if (dir === 'in') return; // only incoming expected
                        out.push(rel.endNode);
                    } else if (rel.endNode === nodeId) {
                        if (relTypes.length > 0 && !relTypes.includes(rel.type)) return;
                        if (dir === 'out') return; // only outgoing expected
                        out.push(rel.startNode);
                    }
                });
                return out;
            }

            _findShortestPathFiltered(startId, endId, options) {
                if (startId === endId) return [startId];
                const { minHops = 1, maxHops = Infinity } = options || {};
                const visited = new Set([startId]);
                const queue = [[startId]];
                while (queue.length > 0) {
                    const path = queue.shift();
                    const currentId = path[path.length - 1];
                    if (path.length - 1 > maxHops) continue;
                    for (const nb of this._neighborsOf(currentId, options)) {
                        if (path.includes(nb)) continue;
                        const newPath = [...path, nb];
                        const hops = newPath.length - 1;
                        if (nb === endId && hops >= minHops && hops <= maxHops) {
                            return newPath;
                        }
                        if (!visited.has(nb)) {
                            visited.add(nb);
                            queue.push(newPath);
                        }
                    }
                }
                return [];
            }

            _findAllShortestPaths(startId, endId, options) {
                if (startId === endId) return [[startId]];
                const { minHops = 1, maxHops = Infinity } = options || {};
                const dist = new Map([[startId, 0]]);
                const q = [startId];
                while (q.length) {
                    const v = q.shift();
                    const d = dist.get(v);
                    if (d >= maxHops) continue;
                    for (const nb of this._neighborsOf(v, options)) {
                        if (!dist.has(nb)) {
                            dist.set(nb, d + 1);
                            q.push(nb);
                        }
                    }
                }
                const targetDist = dist.get(endId);
                if (targetDist === undefined || targetDist < minHops || targetDist > maxHops) return [];
                const results = [];
                const stack = [[startId, [startId]]];
                while (stack.length) {
                    const [v, path] = stack.pop();
                    if (v === endId && path.length - 1 === targetDist) {
                        results.push(path);
                        continue;
                    }
                    for (const nb of this._neighborsOf(v, options)) {
                        if (path.includes(nb)) continue;
                        if (dist.get(nb) === dist.get(v) + 1) {
                            stack.push([nb, [...path, nb]]);
                        }
                    }
                }
                return results;
            }

            _formatPath(nodeIds) {
                const segments = [];
                for (let i = 0; i < nodeIds.length - 1; i++) {
                    const start = this.db.nodes.get(nodeIds[i]);
                    const end = this.db.nodes.get(nodeIds[i + 1]);
                    const rel = this._findRelationshipBetween(nodeIds[i], nodeIds[i + 1]);
                    if (!rel) continue;
                    segments.push({
                        start: this._formatNodeForOutput(start),
                        relationship: this._formatRelForOutput(rel),
                        end: this._formatNodeForOutput(end)
                    });
                }
                const startNode = this.db.nodes.get(nodeIds[0]);
                const endNode = this.db.nodes.get(nodeIds[nodeIds.length - 1]);
                return { start: this._formatNodeForOutput(startNode), end: this._formatNodeForOutput(endNode), segments };
            }

            _findRelationshipBetween(startId, endId) {
                for (const rel of this.db.relationships.values()) {
                    if ((rel.startNode === startId && rel.endNode === endId) ||
                        (rel.startNode === endId && rel.endNode === startId)) {
                        return rel;
                    }
                }
                return null;
            }

            _findNodesByPattern(pattern) {
                // Simple pattern matching for shortestPath
                const labelMatch = pattern.match(/:(\w+)/);
                const propMatch = pattern.match(/\{([^}]+)\}/);
                
                const nodes = [];
                this.db.nodes.forEach(node => {
                    let matches = true;
                    
                    if (labelMatch && !node.labels.has(labelMatch[1])) {
                        matches = false;
                    }
                    
                    if (propMatch && matches) {
                        const propStr = propMatch[1];
                        const props = this._parseProperties(propStr);
                        for (const [key, value] of Object.entries(props)) {
                            if (node.properties[key] !== value) {
                                matches = false;
                                break;
                            }
                        }
                    }
                    
                    if (matches) nodes.push(node);
                });
                
                return nodes;
            }

            _formatNodeForOutput(node) { return { _id: node.id, _type: 'node', labels: Array.from(node.labels), properties: node.properties }; }
            _formatRelForOutput(rel) { return { _id: rel.id, _type: 'relationship', type: rel.type, startNode: rel.startNode, endNode: rel.endNode, properties: rel.properties }; }
        }

        // --- UI & APP LOGIC ---
    document.addEventListener('DOMContentLoaded', () => {
            const dbManager = new DatabaseManager();
            const executor = new CypherExecutor(dbManager);
            let simulation;
            let zoom;

            const paramEditor = document.getElementById('param-editor');
            const editor = CodeMirror.fromTextArea(document.getElementById('command-editor'), {
                mode: 'text/x-sql',
                theme: 'material-darker',
                lineNumbers: true,
                lineWrapping: true,
                autofocus: true
            });
            // Expose editor for tests to programmatically set content
            window.editor = editor;
            paramEditor.value = '{\n  "actorName": "Tom Hanks"\n}';
            const consolePrompt = document.getElementById('console-prompt');
            const infoPanelContent = document.getElementById('info-panel-content');
            const exampleCategoriesContainer = document.getElementById('example-categories');
            const recenterBtn = document.getElementById('recenter-btn');

            const infoContent = `
                <div class="my-6 p-4 rounded-lg bg-gray-800/50 border border-gray-700">
                    <h3 class="text-lg font-semibold text-gray-200 mb-4 text-center">The Property Graph Model 🌐</h3>
                    <p class="text-sm text-gray-400 mb-4">Graph databases store data in a structure of nodes and relationships, which is highly intuitive for modeling complex, connected data.</p>
                    <div class="flex flex-col md:flex-row items-center justify-around gap-2 text-center mb-2">
                        <div class="flex flex-col items-center p-2">
                             <svg class="w-10 h-10 mb-2 text-sky-400" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="10"/>
                             </svg>
                            <h4 class="font-semibold text-gray-200">Nodes</h4>
                            <p class="text-xs text-gray-400">Entities with labels and properties</p>
                            <code class="text-xs text-gray-500 mt-1 block">(:Person {name: 'Tom'})</code>
                        </div>
                        <div class="text-gray-500 text-xl font-light hidden md:block">→</div>
                        <div class="text-gray-500 text-xl font-light md:hidden">↓</div>
                        <div class="flex flex-col items-center p-2">
                            <svg class="w-10 h-10 mb-2 text-teal-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="6" cy="12" r="3" fill="currentColor"/>
                                <circle cx="18" cy="12" r="3" fill="currentColor"/>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m0 0l-3-3m3 3l-3 3"/>
                            </svg>
                            <h4 class="font-semibold text-gray-200">Relationships</h4>
                            <p class="text-xs text-gray-400">Directed connections with a type</p>
                             <code class="text-xs text-gray-500 mt-1 block">-[:ACTED_IN]-></code>
                        </div>
                    </div>
                </div>
                <div class="my-6 p-4 rounded-lg bg-gray-800/50 border border-gray-700">
                    <h3 class="text-lg font-semibold text-gray-200 mb-4 text-center">Cypher Syntax Primer</h3>
                    <ul class="text-sm space-y-2 text-gray-300 font-mono">
                        <li><span class="text-sky-400">(node)</span> - Represents a node.</li>
                        <li><span class="text-sky-400">(n:Person)</span> - A node with variable 'n' and label 'Person'.</li>
                        <li><span class="text-teal-400">-[:KNOWS]-></span> - A directed relationship of type KNOWS.</li>
                        <li><span class="text-teal-400">-[r]-</span> - An undirected relationship with variable 'r'.</li>
                        <li><span class="text-orange-400">{name: 'Alice'}</span> - Properties (key-value pairs).</li>
                    </ul>
                </div>
                <div class="my-6 p-4 rounded-lg bg-gray-800/50 border border-gray-700">
                    <h3 class="text-lg font-semibold text-gray-200 mb-4 text-center">When to Use a Graph Database? 💡</h3>
                    <p class="text-sm text-gray-400 mb-4">Graph databases excel at managing and querying highly connected data. They shine when the **relationships between data points are as important as the data itself.**</p>
                    <ul class="text-sm list-disc pl-5 space-y-2 text-gray-300">
                        <li><b>Social Networks:</b> Finding friends-of-friends, mutual connections, and group affiliations.</li>
                        <li><b>Recommendation Engines:</b> "Customers who bought this also liked..." by analyzing paths between users and products.</li>
                        <li><b>Fraud Detection:</b> Identifying complex, non-obvious links between accounts, devices, and transactions.</li>
                        <li><b>Network & IT Operations:</b> Visualizing dependencies between servers, applications, and services to find points of failure.</li>
                        <li><b>Supply Chain & Logistics:</b> Tracking paths and dependencies from raw materials to final delivery.</li>
                    </ul>
                </div>
            `;
            infoPanelContent.innerHTML = infoContent;

            // Neo4j Tutorial: Building a Knowledge Management System
            // Follow these examples in order to learn Cypher through a practical scenario
            const examples = {
                "🧠 Tutorial: Knowledge Management System": [
                    { title: "📚 Neo4j Cypher Syntax Guide & Tutorial Introduction", query: "// 🚀 Welcome to Neo4j Cypher Tutorial!\n// Learn Neo4j by building a knowledge management system for a tech company\n\n// 📖 CYPHER QUERY LANGUAGE SYNTAX:\n// Basic patterns: (node)-[relationship]->(node)\n// Examples:\n//   CREATE (p:Person {name: 'Alice', age: 30})\n//   MATCH (p:Person) WHERE p.age > 25 RETURN p\n//   MERGE (p:Person {name: 'Bob'})-[:WORKS_FOR]->(c:Company)\n//   DELETE p  or  DETACH DELETE p\n\n// 🎯 PATTERN MATCHING:\n// (n:Label {property: 'value'})     - Node with label and properties\n// [r:TYPE {property: 'value'}]      - Relationship with type and properties\n// (a)-[:KNOWS]->(b)                 - Directed relationship\n// (a)-[:KNOWS]-(b)                  - Undirected relationship\n// (a)-[:KNOWS*1..3]->(b)            - Variable length path\n\n// 🔄 CORE OPERATIONS:\n// CREATE: Create new nodes/relationships\n// MATCH:  Find existing patterns\n// MERGE:  Find or create (upsert)\n// SET:    Update properties\n// REMOVE: Remove properties/labels\n// DELETE: Remove nodes/relationships\n\n// 📊 AGGREGATION & PROCESSING:\n// WITH:     Pipe results between query parts\n// COLLECT:  Aggregate values into lists\n// UNWIND:   Expand lists into rows\n// ORDER BY: Sort results\n// LIMIT:    Restrict number of results\n\n// 🔧 BUILT-IN FUNCTIONS:\n// String: substring(), replace(), split(), toLower()\n// Math: abs(), round(), sqrt(), rand()\n// Collection: size(), head(), tail(), range()\n// Date/Time: date(), datetime(), duration()\n\n// 💡 BEST PRACTICES:\n// 1. Use labels to categorize nodes\n// 2. Create indexes for frequently queried properties\n// 3. Use MERGE for upsert operations\n// 4. Leverage relationship direction for performance\n// 5. Use WITH to break complex queries into steps\n\n// Let's start building our knowledge management system!" },
                ],

                "1️⃣ Company Structure - Creating Nodes": [
                    { title: "Create employees with their basic information", query: "CREATE (alice:Employee {name: 'Alice Johnson', department: 'Engineering', level: 'Senior', email: 'alice@company.com', hire_date: '2020-03-15'})\nCREATE (bob:Employee {name: 'Bob Smith', department: 'Engineering', level: 'Lead', email: 'bob@company.com', hire_date: '2018-07-20'})\nCREATE (charlie:Employee {name: 'Charlie Brown', department: 'Data Science', level: 'Senior', email: 'charlie@company.com', hire_date: '2019-11-10'})" },
                    { title: "Create more employees across different departments", query: "CREATE (diana:Employee {name: 'Diana Prince', department: 'Product', level: 'Manager', email: 'diana@company.com', hire_date: '2017-02-01'})\nCREATE (eve:Employee {name: 'Eve Wilson', department: 'Design', level: 'Senior', email: 'eve@company.com', hire_date: '2021-01-20'})\nCREATE (frank:Employee {name: 'Frank Miller', department: 'Engineering', level: 'Junior', email: 'frank@company.com', hire_date: '2023-06-15'})" },
                    { title: "Create technology and skill nodes", query: "CREATE (python:Technology {name: 'Python', category: 'Programming Language'})\nCREATE (react:Technology {name: 'React', category: 'Frontend Framework'})\nCREATE (postgres:Technology {name: 'PostgreSQL', category: 'Database'})\nCREATE (aws:Technology {name: 'AWS', category: 'Cloud Platform'})\nCREATE (ml:Skill {name: 'Machine Learning', category: 'Data Science'})\nCREATE (leadership:Skill {name: 'Leadership', category: 'Management'})" },
                    { title: "View all employees we created", query: "MATCH (e:Employee) \nRETURN e.name, e.department, e.level \nORDER BY e.hire_date" },
                ],

                "2️⃣ Creating Relationships - Company Hierarchy": [
                    { title: "Create reporting relationships (manager hierarchy)", query: "MATCH (bob:Employee {name: 'Bob Smith'}), (alice:Employee {name: 'Alice Johnson'})\nCREATE (alice)-[:REPORTS_TO]->(bob)\n\nMATCH (bob:Employee {name: 'Bob Smith'}), (frank:Employee {name: 'Frank Miller'})\nCREATE (frank)-[:REPORTS_TO]->(bob)\n\nMATCH (diana:Employee {name: 'Diana Prince'}), (eve:Employee {name: 'Eve Wilson'})\nCREATE (eve)-[:REPORTS_TO]->(diana)" },
                    { title: "Create skill relationships", query: "MATCH (alice:Employee {name: 'Alice Johnson'}), (python:Technology {name: 'Python'})\nCREATE (alice)-[:SKILLED_IN {level: 'Expert', years: 5}]->(python)\n\nMATCH (alice:Employee {name: 'Alice Johnson'}), (react:Technology {name: 'React'})\nCREATE (alice)-[:SKILLED_IN {level: 'Advanced', years: 3}]->(react)\n\nMATCH (charlie:Employee {name: 'Charlie Brown'}), (python:Technology {name: 'Python'})\nCREATE (charlie)-[:SKILLED_IN {level: 'Expert', years: 4}]->(python)\n\nMATCH (charlie:Employee {name: 'Charlie Brown'}), (ml:Skill {name: 'Machine Learning'})\nCREATE (charlie)-[:SKILLED_IN {level: 'Expert', years: 6}]->(ml)" },
                    { title: "Create collaboration relationships", query: "MATCH (alice:Employee {name: 'Alice Johnson'}), (charlie:Employee {name: 'Charlie Brown'})\nCREATE (alice)-[:COLLABORATES_WITH {project: 'ML Platform', since: '2023-01-15'}]->(charlie)\n\nMATCH (eve:Employee {name: 'Eve Wilson'}), (diana:Employee {name: 'Diana Prince'})\nCREATE (eve)-[:COLLABORATES_WITH {project: 'Product Redesign', since: '2023-03-01'}]->(diana)" },
                    { title: "View the company structure", query: "MATCH (e1:Employee)-[r:REPORTS_TO]->(e2:Employee)\nRETURN e1.name + ' reports to ' + e2.name AS hierarchy" },
                ],

                "3️⃣ Projects & Knowledge - Complex Data Modeling": [
                    { title: "Create project nodes with details", query: "CREATE (mlp:Project {name: 'ML Platform', status: 'In Progress', start_date: '2023-01-15', budget: 500000, description: 'AI/ML platform for company-wide use'})\nCREATE (redesign:Project {name: 'Product Redesign', status: 'Planning', start_date: '2023-03-01', budget: 300000, description: 'Complete UI/UX overhaul'})\nCREATE (migration:Project {name: 'Cloud Migration', status: 'Completed', start_date: '2022-06-01', end_date: '2023-01-30', budget: 800000, description: 'Migrate infrastructure to AWS'})" },
                    { title: "Connect employees to projects", query: "MATCH (alice:Employee {name: 'Alice Johnson'}), (mlp:Project {name: 'ML Platform'})\nCREATE (alice)-[:WORKS_ON {role: 'Technical Lead', allocation: 80}]->(mlp)\n\nMATCH (charlie:Employee {name: 'Charlie Brown'}), (mlp:Project {name: 'ML Platform'})\nCREATE (charlie)-[:WORKS_ON {role: 'Data Scientist', allocation: 100}]->(mlp)\n\nMATCH (eve:Employee {name: 'Eve Wilson'}), (redesign:Project {name: 'Product Redesign'})\nCREATE (eve)-[:WORKS_ON {role: 'Lead Designer', allocation: 90}]->(redesign)\n\nMATCH (diana:Employee {name: 'Diana Prince'}), (redesign:Project {name: 'Product Redesign'})\nCREATE (diana)-[:WORKS_ON {role: 'Product Manager', allocation: 60}]->(redesign)" },
                    { title: "Create knowledge documents", query: "CREATE (doc1:Document {title: 'Python Best Practices', type: 'Guide', created_date: '2023-02-15', author: 'Alice Johnson', tags: ['python', 'coding', 'standards']})\nCREATE (doc2:Document {title: 'ML Model Deployment Guide', type: 'Tutorial', created_date: '2023-04-10', author: 'Charlie Brown', tags: ['ml', 'deployment', 'aws']})\nCREATE (doc3:Document {title: 'Design System Documentation', type: 'Specification', created_date: '2023-03-20', author: 'Eve Wilson', tags: ['design', 'ui', 'components']})" },
                    { title: "Connect documents to authors and technologies", query: "MATCH (alice:Employee {name: 'Alice Johnson'}), (doc1:Document {title: 'Python Best Practices'})\nCREATE (alice)-[:AUTHORED]->(doc1)\n\nMATCH (doc1:Document {title: 'Python Best Practices'}), (python:Technology {name: 'Python'})\nCREATE (doc1)-[:ABOUT]->(python)\n\nMATCH (charlie:Employee {name: 'Charlie Brown'}), (doc2:Document {title: 'ML Model Deployment Guide'})\nCREATE (charlie)-[:AUTHORED]->(doc2)\n\nMATCH (doc2:Document {title: 'ML Model Deployment Guide'}), (ml:Skill {name: 'Machine Learning'}), (aws:Technology {name: 'AWS'})\nCREATE (doc2)-[:ABOUT]->(ml)\nCREATE (doc2)-[:ABOUT]->(aws)" },
                ],

                "4️⃣ Basic Querying - Finding Information": [
                    { title: "Find all employees in Engineering department", query: "MATCH (e:Employee {department: 'Engineering'}) \nRETURN e.name, e.level, e.hire_date \nORDER BY e.hire_date" },
                    { title: "Find employees who know Python", query: "MATCH (e:Employee)-[:SKILLED_IN]->(t:Technology {name: 'Python'}) \nRETURN e.name, e.department" },
                    { title: "Find all active projects", query: "MATCH (p:Project) \nWHERE p.status = 'In Progress' OR p.status = 'Planning' \nRETURN p.name, p.status, p.budget \nORDER BY p.budget DESC" },
                    { title: "Find documents created in 2023", query: "MATCH (d:Document) \nWHERE d.created_date >= '2023-01-01' \nRETURN d.title, d.author, d.created_date \nORDER BY d.created_date DESC" },
                ],

                "5️⃣ Advanced Patterns - Multi-hop Relationships": [
                    { title: "Find who reports to Bob (direct reports)", query: "MATCH (employee:Employee)-[:REPORTS_TO]->(bob:Employee {name: 'Bob Smith'}) \nRETURN employee.name + ' reports to ' + bob.name AS reporting_structure" },
                    { title: "Find all people in Bob's team (including indirect reports)", query: "MATCH (bob:Employee {name: 'Bob Smith'})<-[:REPORTS_TO*1..3]-(team_member:Employee) \nRETURN team_member.name, team_member.level \nORDER BY team_member.name" },
                    { title: "Find collaborators of collaborators (2nd degree connections)", query: "MATCH (alice:Employee {name: 'Alice Johnson'})-[:COLLABORATES_WITH*2]-(connection:Employee) \nRETURN DISTINCT connection.name, connection.department" },
                    { title: "Find technology experts through skill relationships", query: "MATCH (e:Employee)-[s:SKILLED_IN]->(t:Technology) \nWHERE s.level = 'Expert' \nRETURN t.name AS technology, COLLECT(e.name) AS experts" },
                ],

                "6️⃣ Aggregation & Analytics": [
                    { title: "Count employees by department", query: "MATCH (e:Employee) \nRETURN e.department, COUNT(e) AS employee_count \nORDER BY employee_count DESC" },
                    { title: "Calculate average project budget", query: "MATCH (p:Project) \nRETURN AVG(p.budget) AS avg_budget, \n       MIN(p.budget) AS min_budget, \n       MAX(p.budget) AS max_budget" },
                    { title: "Find most skilled employees (by number of skills)", query: "MATCH (e:Employee)-[:SKILLED_IN]->() \nRETURN e.name, e.department, COUNT(*) AS skill_count \nORDER BY skill_count DESC" },
                    { title: "Technology popularity analysis", query: "MATCH (t:Technology)<-[:SKILLED_IN]-(e:Employee) \nRETURN t.name, t.category, COUNT(e) AS expert_count \nORDER BY expert_count DESC" },
                ],

                "7️⃣ Using WITH for Complex Queries": [
                    { title: "Find the most experienced employee per department", query: "MATCH (e:Employee) \nWITH e.department AS dept, e \nORDER BY e.hire_date \nWITH dept, HEAD(COLLECT(e)) AS senior_employee \nRETURN dept, senior_employee.name, senior_employee.hire_date" },
                    { title: "Find employees working on high-budget projects", query: "MATCH (p:Project) \nWHERE p.budget > 400000 \nWITH p \nMATCH (e:Employee)-[:WORKS_ON]->(p) \nRETURN e.name, p.name, p.budget \nORDER BY p.budget DESC" },
                    { title: "Find knowledge authors and their expertise", query: "MATCH (e:Employee)-[:AUTHORED]->(d:Document) \nWITH e, COUNT(d) AS doc_count \nWHERE doc_count > 0 \nMATCH (e)-[:SKILLED_IN]->(tech) \nRETURN e.name, doc_count, COLLECT(tech.name) AS technologies" },
                ],

                "8️⃣ MERGE & Data Management": [
                    { title: "Add new employee using MERGE (creates if not exists)", query: "MERGE (grace:Employee {name: 'Grace Hopper', email: 'grace@company.com'}) \nON CREATE SET grace.department = 'Engineering', \n              grace.level = 'Principal', \n              grace.hire_date = '2024-01-15' \nON MATCH SET grace.last_updated = timestamp()" },
                    { title: "Ensure technology relationships exist", query: "MATCH (grace:Employee {name: 'Grace Hopper'}) \nMERGE (cobol:Technology {name: 'COBOL', category: 'Programming Language'}) \nMATCH (grace:Employee {name: 'Grace Hopper'}), (cobol:Technology {name: 'COBOL'}) \nCREATE (grace)-[:SKILLED_IN {level: 'Expert', years: 30}]->(cobol)" },
                    { title: "Add project dependency relationships", query: "MERGE (infra:Project {name: 'Infrastructure Upgrade', status: 'Planning'}) \nMATCH (mlp:Project {name: 'ML Platform'}), (infra:Project {name: 'Infrastructure Upgrade'}) \nMERGE (mlp)-[:DEPENDS_ON]->(infra)" },
                ],

                "9️⃣ UNWIND & List Processing": [
                    { title: "Create multiple technologies from a list", query: "UNWIND ['Docker', 'Kubernetes', 'Terraform', 'Git'] AS tech_name \nMERGE (t:Technology {name: tech_name}) \nON CREATE SET t.category = CASE tech_name \n  WHEN 'Docker' THEN 'Containerization'\n  WHEN 'Kubernetes' THEN 'Orchestration'\n  WHEN 'Terraform' THEN 'Infrastructure'\n  WHEN 'Git' THEN 'Version Control'\nEND" },
                    { title: "Add skills to employees from arrays", query: "MATCH (frank:Employee {name: 'Frank Miller'}) \nUNWIND ['Docker', 'Git'] AS skill_name \nMATCH (t:Technology {name: skill_name}) \nMERGE (frank)-[:SKILLED_IN {level: 'Intermediate', years: 1}]->(t)" },
                    { title: "Create team assignments", query: "MATCH (mlp:Project {name: 'ML Platform'}) \nUNWIND ['Alice Johnson', 'Charlie Brown', 'Frank Miller'] AS member_name \nMATCH (e:Employee {name: member_name}) \nCREATE (e)-[:WORKS_ON]->(mlp)" },
                ],

                "🔟 Advanced Functions & String Operations": [
                    { title: "Find employees with names containing specific patterns", query: "MATCH (e:Employee) \nWHERE e.name CONTAINS 'son' OR e.name ENDS WITH 'Brown' \nRETURN e.name, e.department" },
                    { title: "Extract and format hire year information", query: "MATCH (e:Employee) \nRETURN e.name, \n       e.hire_date, \n       TOINT(SUBSTRING(e.hire_date, 0, 4)) AS hire_year,\n       CASE \n         WHEN TOINT(SUBSTRING(e.hire_date, 0, 4)) < 2020 THEN 'Veteran'\n         ELSE 'Recent Hire'\n       END AS employee_type \nORDER BY hire_year" },
                    { title: "Calculate experience and group employees", query: "MATCH (e:Employee) \nWITH e, \n     TOINT(SUBSTRING(DATE(), 0, 4)) - TOINT(SUBSTRING(e.hire_date, 0, 4)) AS years_experience \nRETURN e.name, \n       years_experience,\n       CASE \n         WHEN years_experience >= 5 THEN 'Senior'\n         WHEN years_experience >= 2 THEN 'Mid-level'\n         ELSE 'Junior'\n       END AS experience_level \nORDER BY years_experience DESC" },
                ],

                "⚡ Path Finding & Graph Algorithms": [
                    { title: "Find a short path between employees", query: "MATCH p = (alice:Employee {name: 'Alice Johnson'})-[*1..5]-(eve:Employee {name: 'Eve Wilson'}) \nRETURN nodes(p) AS path_nodes, length(p) AS path_length \nLIMIT 1" },
                    { title: "Use shortestPath() between two employees", query: "// Ensure some path exists\nMATCH (a:Employee {name: 'Alice Johnson'}), (e:Employee {name: 'Eve Wilson'})\nRETURN shortestPath((a)-[*1..5]-(e)) AS path" },
                    { title: "Use allShortestPaths() for multiple paths", query: "MATCH (a:Employee {name: 'Alice Johnson'}), (c:Employee {name: 'Charlie Brown'})\nRETURN allShortestPaths((a)-[*1..5]-(c)) AS paths" },
                    { title: "Find paths between technologies (≤3 hops)", query: "MATCH p = (python:Technology {name: 'Python'})-[*1..3]-(aws:Technology {name: 'AWS'}) \nRETURN nodes(p) AS connection_path \nLIMIT 5" },
                    { title: "Find knowledge flow (who can teach what to whom)", query: "MATCH (teacher:Employee)-[:SKILLED_IN {level: 'Expert'}]->(tech:Technology)<-[:SKILLED_IN]-(student:Employee) \nWHERE teacher.name <> student.name \nRETURN teacher.name AS teacher, \n       tech.name AS technology, \n       COLLECT(student.name) AS potential_students" },
                ],

                "🧭 Administration & Schema Insights": [
                    { title: "Show databases and current", query: "SHOW DATABASES" },
                    { title: "Show constraints", query: "SHOW CONSTRAINTS" },
                    { title: "Show indexes", query: "SHOW INDEXES" },
                    { title: "Show basic stats", query: "SHOW STATS" },
                    { title: "Show transactions (after BEGIN)", query: "BEGIN\nSHOW TRANSACTIONS" },
                ],

                "📊 Complex Analytics Queries": [
                    { title: "Department collaboration analysis", query: "MATCH (e1:Employee)-[:COLLABORATES_WITH]-(e2:Employee) \nRETURN e1.department + ' <-> ' + e2.department AS collaboration, \n       COUNT(*) AS collaboration_count \nORDER BY collaboration_count DESC" },
                    { title: "Project resource allocation report", query: "MATCH (p:Project)<-[w:WORKS_ON]-(e:Employee) \nWITH p, \n     SUM(w.allocation) AS total_allocation, \n     COUNT(e) AS team_size, \n     COLLECT({name: e.name, role: w.role, allocation: w.allocation}) AS team_details \nRETURN p.name, \n       p.budget, \n       team_size, \n       total_allocation, \n       team_details \nORDER BY p.budget DESC" },
                    { title: "Knowledge gap analysis", query: "MATCH (p:Project)<-[:WORKS_ON]-(e:Employee) \nMATCH (p)-[:REQUIRES]->(required_tech:Technology) \nOPTIONAL MATCH (e)-[:SKILLED_IN]->(required_tech) \nWITH p, required_tech, \n     COUNT(e) AS total_team_members, \n     COUNT(CASE WHEN required_tech IS NOT NULL THEN 1 END) AS skilled_members \nRETURN p.name AS project, \n       required_tech.name AS technology, \n       skilled_members + '/' + total_team_members AS coverage" },
                ],

                "🔄 Data Updates & Modifications": [
                    { title: "Update employee information", query: "MATCH (frank:Employee {name: 'Frank Miller'}) \nSET frank.level = 'Mid-level', \n    frank.last_promotion = date() \nRETURN frank.name, frank.level, frank.last_promotion" },
                    { title: "Add properties to relationships", query: "MATCH (alice:Employee {name: 'Alice Johnson'})-[r:SKILLED_IN]->(python:Technology {name: 'Python'}) \nSET r.certification = 'Python Institute PCAP', \n    r.last_used = date() \nRETURN alice.name, python.name, r.certification" },
                    { title: "Mark project as completed", query: "MATCH (p:Project {name: 'Product Redesign'}) \nSET p.status = 'Completed', \n    p.end_date = '2024-01-15', \n    p.final_budget = 280000 \nRETURN p.name, p.status, p.final_budget" },
                ],

                "🗑️ Cleanup & Node Management": [
                    { title: "Remove unused relationships", query: "MATCH (e:Employee {name: 'Frank Miller'})-[r:WORKS_ON]->(p:Project {name: 'Cloud Migration'}) \nDELETE r" },
                    { title: "Remove properties from nodes", query: "MATCH (e:Employee) \nREMOVE e.last_updated \nRETURN COUNT(e) AS updated_employees" },
                    { title: "Delete nodes with their relationships", query: "CREATE (:TempNode {name: 'Temporary'}) \nMATCH (temp:TempNode {name: 'Temporary'}) \nDETACH DELETE temp" },
                ],

                "🔧 Schema & Constraints": [
                    { title: "Create uniqueness constraint", query: "CREATE CONSTRAINT employee_email_unique \nON (e:Employee) \nASSERT e.email IS UNIQUE" },
                    { title: "Create project name uniqueness constraint", query: "CREATE CONSTRAINT project_name_unique \nON (p:Project) \nASSERT p.name IS UNIQUE" },
                    { title: "Show schema (constraints/indexes)", query: "CALL db.schema()" },
                    { title: "Create index for performance", query: "CREATE INDEX ON :Employee(department)" },
                    { title: "SHOW CONSTRAINTS", query: "SHOW CONSTRAINTS" },
                    { title: "SHOW STATS (summary)", query: "SHOW STATS" },
                ],

                "❌ Common Error Examples": [
                    { title: "Missing MATCH before CREATE relationship", query: "CREATE (alice)-[:WORKS_WITH]->(bob)" },
                    { title: "Incorrect syntax for property update", query: "MATCH (e:Employee) SET e.name = 'Updated' WHERE e.name = 'Alice Johnson'" },
                    { title: "Invalid aggregation without grouping", query: "MATCH (e:Employee) RETURN e.name, COUNT(*)" },
                    { title: "Using undefined variable", query: "MATCH (e:Employee) RETURN e.name, p.name" },
                ],

                "🧩 Core Cypher Semantics (Mini)": [
                    { title: "Multiple relationship types alternation", query: "MATCH (a)-[:REPORTS_TO|:COLLABORATES_WITH]->(b) RETURN a,b LIMIT 5" },
                    { title: "Multi-label nodes creation and match", query: "CREATE (:Person:Employee {name: 'MultiLabelUser'})\nMATCH (n:Person:Employee {name: 'MultiLabelUser'}) RETURN n" },
                    { title: "Relationship property filter", query: "MATCH (e:Employee)-[r:SKILLED_IN {level: 'Expert'}]->(t:Technology) RETURN e.name, t.name, r.level LIMIT 5" },
                    { title: "Undirected vs Directed match", query: "// Directed: reports to\nMATCH (a:Employee)-[:REPORTS_TO]->(b:Employee) RETURN a.name AS emp, b.name AS manager LIMIT 3\n// Undirected: any connection\nMATCH (x:Employee)-[:COLLABORATES_WITH]-(y:Employee) RETURN x.name, y.name LIMIT 3" },
                ],

                "🔄 CREATE vs MERGE Behavior Examples": [
                    { title: "CREATE allows duplicates (creates multiple nodes with same properties)", query: "CREATE (person:Person {name: 'John', age: 30})\nCREATE (person:Person {name: 'John', age: 30})\nMATCH (p:Person {name: 'John'}) RETURN COUNT(p) AS john_count" },
                    { title: "MERGE creates only if doesn't exist (idempotent)", query: "MERGE (person:Person {name: 'Jane', age: 25})\nMERGE (person:Person {name: 'Jane', age: 25})\nMATCH (p:Person {name: 'Jane'}) RETURN COUNT(p) AS jane_count" },
                    { title: "CREATE with constraints will fail on duplicates", query: "CREATE CONSTRAINT person_email_unique ON (p:Person) ASSERT p.email IS UNIQUE\nCREATE (p1:Person {email: 'test@example.com'})\nCREATE (p2:Person {email: 'test@example.com'})" },
                    { title: "MERGE with ON CREATE and ON MATCH clauses", query: "MERGE (u:User {id: 'user123'})\nON CREATE SET u.created = timestamp(), u.login_count = 1\nON MATCH SET u.last_login = timestamp(), u.login_count = u.login_count + 1\nRETURN u" },
                ],
            };
            
            Object.entries(examples).forEach(([category, queries]) => {
                const categoryDiv = document.createElement('div');
                categoryDiv.innerHTML = `<h3 class="text-lg font-semibold mb-3 text-gray-200">${category}</h3>`;
                const list = document.createElement('div');
                list.className = 'space-y-3';
                queries.forEach(ex => {
                    const item = document.createElement('div');
                    item.className = 'w-full text-left bg-gray-800/50 hover:bg-gray-700/70 text-gray-300 rounded-md overflow-hidden p-3 transition-colors duration-200 cursor-pointer';
                    item.innerHTML = `
                        <p class="text-sm font-semibold text-gray-300">${ex.title}</p>
                        <pre class="text-gray-400 font-mono text-xs overflow-x-auto custom-scrollbar pt-1"><code>${ex.query}</code></pre>
                    `;
                    item.addEventListener('click', () => {
                        editor.setValue(ex.query);
                        editor.focus();
                        if (window.innerWidth < 768) {
                            document.querySelector('.mobile-nav-btn[data-view="right"]').click();
                        }
                    });
                    list.appendChild(item);
                });
                categoryDiv.appendChild(list);
                exampleCategoriesContainer.appendChild(categoryDiv);
            });
            hljs.highlightAll();

            // --- TEST HOOKS (non-intrusive) ---
            // Expose minimal API for automated smoke tests without relying on DOM parsing
            window.__graphTest = {
                reset: () => {
                    // Reset current database to a clean state
                    const current = dbManager.currentDbName;
                    dbManager.databases.set(current, { db: new GraphDB(), lastQueryResult: null });
                    executor.db = dbManager.getCurrentDb();
                    try { clearVisualization(); } catch (e) {}
                    try { clearConsole(); } catch (e) {}
                },
                run: async (query, params = {}) => {
                    try {
                        return { ok: true, ...executor.executeQuery(query, params) };
                    } catch (e) {
                        return { ok: false, error: String(e.message || e) };
                    }
                },
                runLines: async (text, params = {}) => {
                    const rawLines = String(text)
                        .split('\n')
                        .map(s => s.trim())
                        .filter(s => s && !s.startsWith('--') && !s.startsWith('//'));
                    const statements = [];
                    for (let i = 0; i < rawLines.length; i++) {
                        const line = rawLines[i];
                        const prev = statements.length > 0 ? statements[statements.length - 1] : null;
                        // Join MATCH ... CREATE on consecutive lines into single statement
                        if (prev && /^MATCH\b/i.test(prev) && /^CREATE\b/i.test(line)) {
                            statements[statements.length - 1] = prev + ' ' + line;
                        } else {
                            statements.push(line);
                        }
                    }
                    const out = [];
                    for (const q of statements) {
                        out.push(await window.__graphTest.run(q, params));
                    }
                    return out;
                },
                getDbSnapshot: () => {
                    const db = dbManager.getCurrentDb();
                    return {
                        name: dbManager.currentDbName,
                        nodes: Array.from(db.nodes.values()).map(n => ({ id: n.id, labels: Array.from(n.labels), properties: n.properties })),
                        relationships: Array.from(db.relationships.values()).map(r => ({ id: r.id, type: r.type, startNode: r.startNode, endNode: r.endNode, properties: r.properties })),
                        labelsToNodes: Array.from(db.labelsToNodes.entries()).reduce((a,[k,v]) => (a[k] = Array.from(v), a), {}),
                        constraints: Array.from(db.constraints.keys()),
                        indexes: Array.from(db.indexes.keys()),
                    };
                }
            };
            
            function executeQuery() {
                const fullQueryText = editor.getValue();
                if (!fullQueryText.trim()) return;

                let params = {};
                try {
                    params = JSON.parse(paramEditor.value || '{}');
                } catch (e) {
                    logToConsole(`<span class="error">[ERROR]</span> Invalid JSON in Query Parameters.`);
                    return;
                }

                const rawLines = fullQueryText.split('\n')
                    .map(q => q.trim())
                    .filter(q => q && !q.startsWith('--') && !q.startsWith('//'));
                const queries = [];
                for (let i = 0; i < rawLines.length; i++) {
                    const line = rawLines[i];
                    const prev = queries.length > 0 ? queries[queries.length - 1] : null;
                    // Join MATCH ... CREATE on consecutive lines into a single statement
                    if (prev && /^MATCH\b/i.test(prev) && /^CREATE\b/i.test(line)) {
                        queries[queries.length - 1] = prev + ' ' + line;
                    } else {
                        queries.push(line);
                    }
                }

                if (queries.length === 0) return;

                let lastQueryType = '';
                let lastResult = null;

                for (const query of queries) {
                    const startTime = performance.now();
                    try {
                        const { type, message, result } = executor.executeQuery(query, params);
                        const endTime = performance.now();
                        const duration = (endTime - startTime).toFixed(2);
                        
                        logToConsole(`<span class="ok">[OK]</span> ${message} (${duration}ms)`);
                        if (result && result.length > 0) {
                            logToConsole(JSON.stringify(result, null, 2));
                        }
                        lastQueryType = type;
                        lastResult = result;
                    } catch (error) {
                        logToConsole(`<span class="error">[ERROR]</span> ${error.message}`);
                        return;
                    }
                }

                consolePrompt.textContent = `${dbManager.currentDbName}>`;

                if (lastQueryType === 'db_manage') {
                    dbManager.setLastQueryResult([]);
                    clearVisualization();
                } else if (lastQueryType !== 'read') {
                    refreshFullGraphView();
                } else {
                    dbManager.setLastQueryResult(lastResult);
                    const hasGraphElements = lastResult.some(r => typeof r === 'object' && r !== null && Object.values(r).some(v => v && (v._type || v.segments)));
                    if(hasGraphElements) {
                        updateVisualization(lastResult);
                    }
                }
            }
            
            function refreshFullGraphView() {
                const db = dbManager.getCurrentDb();
                const allNodes = Array.from(db.nodes.values()).map(n => executor._formatNodeForOutput(n));
                const allRels = Array.from(db.relationships.values()).map(r => executor._formatRelForOutput(r));
                
                const combinedResult = [];
                const nodesInRels = new Set();

                allRels.forEach(rel => {
                    combinedResult.push({
                        start: executor._formatNodeForOutput(db.nodes.get(rel.startNode)),
                        rel: rel,
                        end: executor._formatNodeForOutput(db.nodes.get(rel.endNode))
                    });
                    nodesInRels.add(rel.startNode);
                    nodesInRels.add(rel.endNode);
                });

                allNodes.forEach(node => {
                    if (!nodesInRels.has(node._id)) {
                        combinedResult.push({ node: node });
                    }
                });
                
                dbManager.setLastQueryResult(combinedResult);
                updateVisualization(combinedResult);
            }

            function logToConsole(message) {
                const consoleOutput = document.getElementById('console-output-content');
                consoleOutput.innerHTML += `\n<span class="prompt">${dbManager.currentDbName}></span> ${message}`;
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }

            function clearConsole() {
                const consoleOutput = document.getElementById('console-output-content');
                consoleOutput.innerHTML = `<span class="prompt" id="console-prompt">${dbManager.currentDbName}></span> Console cleared.`;
            }

            function updateVisualization(data) {
                const svgElement = d3.select("#visual-output");
                clearVisualization();
                if (!data || !Array.isArray(data) || data.length === 0) return;

                const width = visualOutputContainer.clientWidth;
                const height = visualOutputContainer.clientHeight;
                if (width === 0 || height === 0) return;

                // Set proper SVG dimensions and viewBox
                svgElement
                    .attr("width", width)
                    .attr("height", height)
                    .attr("viewBox", `0 0 ${width} ${height}`)
                    .style("overflow", "visible");

                const graph = { nodes: [], links: [] };
                const nodeMap = new Map();

                function addNode(nodeData) {
                    if (nodeData && nodeData._type === 'node' && !nodeMap.has(nodeData._id)) {
                        nodeMap.set(nodeData._id, {
                            id: nodeData._id,
                            label: nodeData.labels[0] || 'Node',
                            title: nodeData.properties.name || nodeData.properties.title || `ID: ${nodeData._id}`,
                            properties: nodeData.properties
                        });
                    }
                }

                data.forEach(item => {
                    if (!item) return;
                    if (item._type === 'node') addNode(item);
                    else if (typeof item === 'object' && item !== null) {
                        Object.values(item).forEach(value => {
                            if (value && value.segments) { // It's a path
                                value.segments.forEach(segment => {
                                    addNode(segment.start);
                                    addNode(segment.end);
                                    graph.links.push({ source: segment.start._id, target: segment.end._id, type: segment.relationship.type });
                                });
                            }
                            else if (value?._type === 'node') addNode(value);
                            else if (value?._type === 'relationship') {
                                addNode(executor._formatNodeForOutput(dbManager.getCurrentDb().nodes.get(value.startNode)));
                                addNode(executor._formatNodeForOutput(dbManager.getCurrentDb().nodes.get(value.endNode)));
                                graph.links.push({ source: value.startNode, target: value.endNode, type: value.type });
                            }
                        });
                    }
                });
                graph.nodes = Array.from(nodeMap.values());
                if (graph.nodes.length === 0) return;
                
                // Define arrow markers per relationship type with consistent colors
                const defs = svgElement.append('defs');
                const relTypes = Array.from(new Set(graph.links.map(l => l.type || 'REL')));
                const typeColor = d3.scaleOrdinal(d3.schemeCategory10).domain(relTypes);
                relTypes.forEach(t => {
                    const id = `arrow-${t}`;
                    const color = typeColor(t);
                    const m = defs.append('marker')
                        .attr('id', id)
                        .attr('viewBox', '0 -5 10 10')
                        .attr('refX', 24)
                        .attr('refY', 0)
                        .attr('markerWidth', 6)
                        .attr('markerHeight', 6)
                        .attr('orient', 'auto');
                    m.append('path').attr('d', 'M0,-5L10,0L0,5').attr('fill', color);
                });

                const g = svgElement.append("g").attr("class", "content");
                zoom = d3.zoom().on("zoom", e => g.attr('transform', e.transform));
                svgElement.call(zoom);

                simulation = d3.forceSimulation(graph.nodes)
                    .force("link", d3.forceLink(graph.links).id(d => d.id).distance(150))
                    .force("charge", d3.forceManyBody().strength(-500))
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("collision", d3.forceCollide().radius(30));

                // Compute multi-link grouping for curved edges like Neo4j
                const pairKey = (a, b) => a < b ? `${a}|${b}` : `${b}|${a}`;
                const linksByPair = new Map();
                graph.links.forEach(l => {
                    const key = pairKey(l.source, l.target);
                    if (!linksByPair.has(key)) linksByPair.set(key, []);
                    linksByPair.get(key).push(l);
                });
                linksByPair.forEach(arr => arr.forEach((l, i) => { l._idx = i; l._count = arr.length; }));

                const node = g.append("g").selectAll("g").data(graph.nodes).join("g")
                    .attr("class", "node")
                    .call(drag(simulation))
                    .on('click', showNodeDetails)
                    .on('dblclick', unpinNode);

                const linkPath = g.append("g").selectAll("path").data(graph.links).join("path")
                    .attr("class", "link")
                    .attr("stroke", d => typeColor(d.type || 'REL'))
                    .attr("fill", "none")
                    .attr("marker-end", d => `url(#arrow-${d.type || 'REL'})`);

                const linkLabels = g.append("g").selectAll("text").data(graph.links).join("text")
                    .attr("class", "link-label")
                    .text(d => d.type);
                
                const color = d3.scaleOrdinal(d3.schemeCategory10);

                node.append("circle").attr("r", 25).attr("fill", d => color(d.label));
                node.append("text").text(d => d.title).attr("dy", "0.3em");
                node.append("title").text(d => JSON.stringify(d.properties, null, 2));

                function pathForLink(d) {
                    const sx = d.source.x, sy = d.source.y, tx = d.target.x, ty = d.target.y;
                    const dx = tx - sx, dy = ty - sy;
                    const dr = Math.sqrt(dx*dx + dy*dy) || 1;
                    // Curvature factor for multi-links (centered around 0)
                    const k = d._count > 1 ? (d._idx - (d._count - 1) / 2) * 0.6 : 0;
                    if (k === 0) return `M${sx},${sy} L${tx},${ty}`;
                    const mx = (sx + tx) / 2, my = (sy + ty) / 2;
                    const nx = -dy / dr, ny = dx / dr; // normal
                    const offset = 30 * k;
                    const cx = mx + nx * offset;
                    const cy = my + ny * offset;
                    return `M${sx},${sy} Q${cx},${cy} ${tx},${ty}`;
                }

                simulation.on("tick", () => {
                    linkPath.attr("d", pathForLink);
                    node.attr("transform", d => `translate(${d.x},${d.y})`);
                    // Position labels at the middle of the path
                    linkLabels.attr("transform", function(d, i) {
                        const pathEl = linkPath.nodes()[i];
                        if (!pathEl) return null;
                        const len = pathEl.getTotalLength();
                        const pt = pathEl.getPointAtLength(len / 2);
                        // Offset labels slightly to improve readability similar to Neo4j
                        const before = pathEl.getPointAtLength(Math.max(0, len / 2 - 1));
                        const after = pathEl.getPointAtLength(Math.min(len, len / 2 + 1));
                        const angle = Math.atan2(after.y - before.y, after.x - before.x);
                        const offset = 10; // px
                        const ox = -Math.sin(angle) * offset;
                        const oy = Math.cos(angle) * offset;
                        return `translate(${pt.x + ox},${pt.y + oy})`;
                    });
                });

                recenterVisualization(true);
            }
            
            function unpinNode(event, d) {
                event.stopPropagation();
                d.fx = null;
                d.fy = null;
                d3.select(this).classed("fixed", false);
                simulation.alpha(0.1).restart();
            }

            function drag(simulation) {
                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }
                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }
                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    d3.select(this).classed("fixed", true);
                }
                return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
            }

            function clearVisualization() {
                const svgElement = d3.select("#visual-output");
                if (simulation) simulation.stop();
                svgElement.html("");
            }
            
            function recenterVisualization(instant = false, isMobile = false) {
                const svgSelector = isMobile ? "#mobile-visual-output" : "#visual-output";
                const svgElement = d3.select(svgSelector);
                const contentClass = isMobile ? "mobile-content" : "content";
                const g = svgElement.select(`g.${contentClass}`);
                if (!g.node()) return;

                const bounds = g.node().getBBox();
                const parent = svgElement.node();
                const fullWidth = parent.clientWidth;
                const fullHeight = parent.clientHeight;
                const width = bounds.width;
                const height = bounds.height;
                const midX = bounds.x + width / 2;
                const midY = bounds.y + height / 2;

                if (width === 0 || height === 0) return;

                let scale = (isMobile ? 0.8 : 0.85) / Math.max(width / fullWidth, height / fullHeight);
                // Cap scale to avoid excessive zoom for tiny graphs or overly large zooms
                const MIN_SCALE = isMobile ? 0.3 : 0.25;
                const MAX_SCALE = isMobile ? 1.5 : 2.0;
                if (!isFinite(scale) || scale <= 0) scale = 1;
                scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale));
                const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];

                const transform = d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale);
                
                const zoomBehavior = isMobile ? d3.zoom() : zoom;
                const view = instant ? svgElement : svgElement.transition().duration(750);
                view.call(zoomBehavior.transform, transform);
            }
            
            // Mobile visualization function
            function updateMobileVisualization(data) {
                const svgElement = d3.select("#mobile-visual-output");
                clearMobileVisualization();
                if (!data || !Array.isArray(data) || data.length === 0) return;

                const container = document.getElementById('mobile-graph-view');
                const width = container.clientWidth;
                const height = container.clientHeight - 80; // Account for header
                if (width === 0 || height === 0) return;

                // Set proper SVG dimensions and viewBox for mobile
                svgElement
                    .attr("width", width)
                    .attr("height", height)
                    .attr("viewBox", `0 0 ${width} ${height}`)
                    .style("overflow", "visible");

                const graph = { nodes: [], links: [] };
                const nodeMap = new Map();

                function addNode(nodeData) {
                    if (nodeData && nodeData._type === 'node' && !nodeMap.has(nodeData._id)) {
                        nodeMap.set(nodeData._id, {
                            id: nodeData._id,
                            label: nodeData.labels[0] || 'Node',
                            title: nodeData.properties.name || nodeData.properties.title || `ID: ${nodeData._id}`,
                            properties: nodeData.properties
                        });
                    }
                }

                // Same data processing as desktop version
                data.forEach(item => {
                    if (!item) return;
                    if (item._type === 'node') addNode(item);
                    else if (typeof item === 'object' && item !== null) {
                        Object.values(item).forEach(value => {
                            if (value && value.segments) {
                                value.segments.forEach(segment => {
                                    addNode(segment.start);
                                    addNode(segment.end);
                                    graph.links.push({ source: segment.start._id, target: segment.end._id, type: segment.relationship.type });
                                });
                            }
                            else if (value?._type === 'node') addNode(value);
                            else if (value?._type === 'relationship') {
                                addNode(executor._formatNodeForOutput(dbManager.getCurrentDb().nodes.get(value.startNode)));
                                addNode(executor._formatNodeForOutput(dbManager.getCurrentDb().nodes.get(value.endNode)));
                                graph.links.push({ source: value.startNode, target: value.endNode, type: value.type });
                            }
                        });
                    }
                });
                graph.nodes = Array.from(nodeMap.values());
                if (graph.nodes.length === 0) return;

                // Define arrow markers per relationship type with consistent colors for mobile
                const defs = svgElement.append('defs');
                const relTypes = Array.from(new Set(graph.links.map(l => l.type || 'REL')));
                const typeColor = d3.scaleOrdinal(d3.schemeCategory10).domain(relTypes);
                relTypes.forEach(t => {
                    const id = `mobile-arrow-${t}`;
                    const color = typeColor(t);
                    const m = defs.append('marker')
                        .attr('id', id)
                        .attr('viewBox', '0 -5 10 10')
                        .attr('refX', 20)
                        .attr('refY', 0)
                        .attr('markerWidth', 6)
                        .attr('markerHeight', 6)
                        .attr('orient', 'auto');
                    m.append('path').attr('d', 'M0,-5L10,0L0,5').attr('fill', color);
                });

                const g = svgElement.append("g").attr("class", "mobile-content");
                const mobileZoom = d3.zoom().on("zoom", e => g.attr('transform', e.transform));
                svgElement.call(mobileZoom);

                const mobileSimulation = d3.forceSimulation(graph.nodes)
                    .force("link", d3.forceLink(graph.links).id(d => d.id).distance(100))
                    .force("charge", d3.forceManyBody().strength(-300))
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("collision", d3.forceCollide().radius(25));

                // Compute multi-link grouping for curved edges like Neo4j
                const pairKey = (a, b) => a < b ? `${a}|${b}` : `${b}|${a}`;
                const linksByPair = new Map();
                graph.links.forEach(l => {
                    const key = pairKey(l.source, l.target);
                    if (!linksByPair.has(key)) linksByPair.set(key, []);
                    linksByPair.get(key).push(l);
                });
                linksByPair.forEach(arr => arr.forEach((l, i) => { l._idx = i; l._count = arr.length; }));

                const node = g.append("g").selectAll("g").data(graph.nodes).join("g")
                    .attr("class", "node")
                    .call(drag(mobileSimulation))
                    .on('click', showNodeDetails)
                    .on('dblclick', (event, d) => {
                        event.stopPropagation();
                        d.fx = null;
                        d.fy = null;
                        d3.select(event.currentTarget).classed("fixed", false);
                        mobileSimulation.alpha(0.1).restart();
                    });

                const linkPath = g.append("g").selectAll("path").data(graph.links).join("path")
                    .attr("class", "link")
                    .attr("stroke", d => typeColor(d.type || 'REL'))
                    .attr("fill", "none")
                    .attr("marker-end", d => `url(#mobile-arrow-${d.type || 'REL'})`);

                const linkLabels = g.append("g").selectAll("text").data(graph.links).join("text")
                    .attr("class", "link-label")
                    .text(d => d.type);
                
                const color = d3.scaleOrdinal(d3.schemeCategory10);

                node.append("circle").attr("r", 20).attr("fill", d => color(d.label)); // Smaller nodes for mobile
                node.append("text").text(d => d.title.length > 10 ? d.title.substring(0, 10) + '...' : d.title).attr("dy", "0.3em").style("font-size", "10px");
                node.append("title").text(d => JSON.stringify(d.properties, null, 2));

                function pathForLink(d) {
                    const sx = d.source.x, sy = d.source.y, tx = d.target.x, ty = d.target.y;
                    const dx = tx - sx, dy = ty - sy;
                    const dr = Math.sqrt(dx*dx + dy*dy) || 1;
                    const k = d._count > 1 ? (d._idx - (d._count - 1) / 2) * 0.5 : 0;
                    if (k === 0) return `M${sx},${sy} L${tx},${ty}`;
                    const mx = (sx + tx) / 2, my = (sy + ty) / 2;
                    const nx = -dy / dr, ny = dx / dr;
                    const offset = 24 * k;
                    const cx = mx + nx * offset;
                    const cy = my + ny * offset;
                    return `M${sx},${sy} Q${cx},${cy} ${tx},${ty}`;
                }

                mobileSimulation.on("tick", () => {
                    linkPath.attr("d", pathForLink);
                    node.attr("transform", d => `translate(${d.x},${d.y})`);
                    linkLabels.attr("transform", function(d, i) {
                        const pathEl = linkPath.nodes()[i];
                        if (!pathEl) return null;
                        const len = pathEl.getTotalLength();
                        const pt = pathEl.getPointAtLength(len / 2);
                        const before = pathEl.getPointAtLength(Math.max(0, len / 2 - 1));
                        const after = pathEl.getPointAtLength(Math.min(len, len / 2 + 1));
                        const angle = Math.atan2(after.y - before.y, after.x - before.x);
                        const offset = 8;
                        const ox = -Math.sin(angle) * offset;
                        const oy = Math.cos(angle) * offset;
                        return `translate(${pt.x + ox},${pt.y + oy})`;
                    });
                });

                // Auto-center after a short delay
                setTimeout(() => {
                    const bounds = g.node().getBBox();
                    const fullWidth = width;
                    const fullHeight = height;
                    const nodeWidth = bounds.width;
                    const nodeHeight = bounds.height;
                    const midX = bounds.x + nodeWidth / 2;
                    const midY = bounds.y + nodeHeight / 2;

                    if (nodeWidth === 0 || nodeHeight === 0) return;

                    let scale = 0.8 / Math.max(nodeWidth / fullWidth, nodeHeight / fullHeight);
                    scale = Math.max(0.3, Math.min(1.5, scale));
                    const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];

                    const transform = d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale);
                    svgElement.transition().duration(500).call(mobileZoom.transform, transform);
                }, 1000);
            }
            
            function clearMobileVisualization() {
                const svgElement = d3.select("#mobile-visual-output");
                svgElement.html("");
            }

            // --- UI Event Handlers ---
            const runBtn = document.getElementById('run-command-btn');
            const clearConsoleBtn = document.getElementById('clear-console-btn');
            const mobileNavBtns = document.querySelectorAll('.mobile-nav-btn');
            const resultsTabBtns = document.querySelectorAll('.results-tab-btn');
            const resizer = document.getElementById('resizer');
            const editorContainer = document.getElementById('editor-container');
            const resultsContainer = document.getElementById('results-container');
            const visualOutputContainer = document.getElementById('visual-output-content');
            const modalOverlay = document.getElementById('details-modal-overlay');
            const modalCloseBtn = document.getElementById('modal-close-btn');

            function showNodeDetails(event, d) {
                event.stopPropagation();
                document.getElementById('modal-node-id').textContent = d.id;
                document.getElementById('modal-node-labels').textContent = `:${d.label}`;
                document.getElementById('modal-node-properties').textContent = JSON.stringify(d.properties, null, 2);
                modalOverlay.classList.remove('hidden');
            }

            function hideNodeDetails() {
                modalOverlay.classList.add('hidden');
            }

            modalOverlay.addEventListener('click', hideNodeDetails);
            modalCloseBtn.addEventListener('click', hideNodeDetails);
            recenterBtn.addEventListener('click', () => recenterVisualization(false));


            runBtn.addEventListener('click', executeQuery);
            editor.setOption("extraKeys", { "Ctrl-Enter": executeQuery, "Cmd-Enter": executeQuery });
            clearConsoleBtn.addEventListener('click', clearConsole);

            let isResizing = false;
            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', () => {
                    isResizing = false;
                    document.removeEventListener('mousemove', handleMouseMove);
                });
            });
            function handleMouseMove(e) {
                const rightPanel = document.getElementById('right-panel');
                if (!isResizing || !rightPanel) return;
                const totalHeight = rightPanel.offsetHeight;
                const newEditorHeight = e.clientY - rightPanel.offsetTop;
                const newResultsHeight = totalHeight - newEditorHeight - resizer.offsetHeight;
                if (newEditorHeight > 100 && newResultsHeight > 50) {
                    const editorPercent = (newEditorHeight / totalHeight) * 100;
                    editorContainer.style.height = `${editorPercent}%`;
                    resultsContainer.style.height = `${100 - editorPercent}%`;
                }
            }

            mobileNavBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    mobileNavBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const view = btn.dataset.view;

                    if (view === 'graph') {
                        // Show full-screen mobile graph view
                        document.getElementById('mobile-graph-view').classList.remove('hidden');
                        updateMobileVisualization(dbManager.getLastQueryResult());
                        return;
                    }

                    // Hide all main panels and remove any mobile display helpers we may have added.
                    document.querySelectorAll('.main-panel').forEach(p => {
                        p.classList.add('hidden');
                        p.classList.remove('flex');
                        p.classList.remove('block');
                    });

                    const targetPanel = document.getElementById(`${view}-panel`);
                    // Restore a sensible display for the target panel on mobile.
                    targetPanel.classList.remove('hidden');
                    if (targetPanel.classList.contains('md:flex') || targetPanel.classList.contains('flex-1')) {
                        // This panel expects to be a flex container on wider screens; use flex for mobile too.
                        targetPanel.classList.add('flex');
                    } else {
                        // Keep it block to avoid layout stretching issues (prevents info panel widening).
                        targetPanel.classList.add('block');
                    }

                    if(view === 'right') editor.refresh();
                });
            });
            
            // Mobile graph view controls
            document.getElementById('close-mobile-graph').addEventListener('click', () => {
                document.getElementById('mobile-graph-view').classList.add('hidden');
                // Return to info view
                document.querySelector('.mobile-nav-btn[data-view="info"]').click();
            });
            
            document.getElementById('mobile-recenter-btn').addEventListener('click', () => {
                recenterVisualization(true); // true for mobile
            });

            resultsTabBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    resultsTabBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    document.querySelectorAll('.results-tab-content').forEach(content => content.classList.add('hidden'));
                    const targetContent = document.getElementById(`${btn.dataset.tab}-output-content`);
                    targetContent.classList.remove('hidden');
                    // If user opened the Graph View tab, (re)render the latest graph
                    if (btn.dataset.tab === 'visual') {
                        try {
                            updateVisualization(dbManager.getLastQueryResult());
                            // Ensure view is centered at default zoom whenever visual tab opens
                            recenterVisualization(false);
                        } catch (e) { /* ignore rendering errors */ }
                    }
                });
            });
        });
    </script>
</body>
</html>
