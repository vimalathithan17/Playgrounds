<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Key-Value Store (Final Version)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- CodeMirror for the editor -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/material-darker.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/shell/shell.min.js"></script>

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #1a1a1a; color: #e0e0e0; overflow: hidden; }
        .CodeMirror { font-family: 'Fira Code', monospace; font-size: 14px; line-height: 21px; height: 100%; background-color: #1e1e1e; }
        .CodeMirror-gutters { background-color: #252526 !important; border-right: 1px solid #3a3a3a; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #2d2d2d; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background-color: #555; border-radius: 3px; }
        .resizer { background-color: #3a3a3a; cursor: row-resize; width: 100%; height: 5px; z-index: 10; }
        .console-output { font-family: 'Fira Code', monospace; white-space: pre-wrap; word-wrap: break-word; }
        .console-output .ok { color: #6ee7b7; }
        .console-output .error { color: #f472b6; }
        .console-output .prompt { color: #6b7280; }
        .mobile-nav-btn.active { color: #6ee7b7; border-color: #6ee7b7; }
        .results-tab-btn.active { border-color: #6ee7b7; background-color: #2d2d2d; }
    </style>
</head>
<body class="flex flex-col h-screen">

    <main class="flex flex-grow overflow-hidden md:flex-row flex-col">
        <!-- Left Panel for Info and Examples -->
        <div id="left-panel" class="w-full md:w-2/5 h-full bg-[#1e1e1e] p-6 custom-scrollbar overflow-y-auto border-r border-gray-700 hidden md:block">
            <div class="prose prose-invert max-w-none">
                <h2 class="text-2xl font-bold text-gray-100">Key-Value Store (Redis-like)</h2>
                <p class="text-sm text-gray-400">
                    A feature-complete emulator including all major data structures, Pub/Sub, and Geospatial commands.
                </p>

                <!-- Data Model -->
                <div class="my-6 p-4 rounded-lg bg-gray-800/50 border border-gray-700">
                    <h3 class="text-lg font-semibold text-gray-200 mb-4 text-center">Data Model Hierarchy üèõÔ∏è</h3>
                    <div class="flex flex-col items-center justify-around gap-2 text-center">
                        <div class="flex flex-col items-center p-2">
                            <svg class="w-12 h-12 mb-2 text-teal-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14M5 12a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v4a2 2 0 01-2 2M5 12a2 2 0 00-2 2v4a2 2 0 002 2h14a2 2 0 002-2v-4a2 2 0 00-2-2"/>
                                <circle cx="8" cy="9" r="1" fill="currentColor"/>
                                <circle cx="8" cy="15" r="1" fill="currentColor"/>
                            </svg>
                            <h4 class="font-semibold text-gray-200">Database</h4>
                            <p class="text-xs text-gray-400">Numbered DBs (e.g., 0, 1, 2...)</p>
                        </div>
                        <div class="text-gray-500 text-2xl font-light">‚Üì</div>
                        <div class="flex flex-col items-center p-2">
                            <svg class="w-12 h-12 mb-2 text-sky-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H4a1 1 0 01-1-1v-2.586a1 1 0 01.293-.707l5.964-5.964A6 6 0 1121 9z"/>
                                <circle cx="15" cy="9" r="1" fill="currentColor"/>
                            </svg>
                            <h4 class="font-semibold text-gray-200">Key</h4>
                            <p class="text-xs text-gray-400">A unique string identifier</p>
                        </div>
                        <div class="text-gray-500 text-2xl font-light">‚Üì</div>
                        <div class="flex flex-col items-center p-2">
                           <svg class="w-12 h-12 mb-2 text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"/>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h1m0 0h1m-1 0v1m0-1V6m4 3h2M9 13h6M9 17h6"/>
                            </svg>
                            <h4 class="font-semibold text-gray-200">Value</h4>
                            <p class="text-xs text-gray-400">String, List, Hash, Set, etc.</p>
                        </div>
                    </div>
                </div>

                <!-- Stream Simulator -->
                <div class="bg-[#2d2d2d] rounded-md p-4 my-6">
                    <h3 class="text-lg font-semibold mb-3 text-gray-200">Event Producer Simulator</h3>
                    <div class="space-y-3">
                        <div>
                            <label for="stream-key-input" class="text-xs font-medium text-gray-400">Stream Key / Pub/Sub Channel</label>
                            <input type="text" id="stream-key-input" value="sensor:log" class="w-full bg-[#1e1e1e] border border-gray-600 rounded-md px-2 py-1 text-sm mt-1">
                        </div>
                        <div>
                            <label for="stream-config-input" class="text-xs font-medium text-gray-400">Data Schema (JSON)</label>
                            <textarea id="stream-config-input" rows="5" class="w-full bg-[#1e1e1e] border border-gray-600 rounded-md px-2 py-1 text-xs font-mono mt-1 custom-scrollbar"></textarea>
                        </div>
                        <div class="flex gap-2">
                            <button id="start-stream-btn" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold px-3 py-1.5 rounded-md text-sm">Start</button>
                            <button id="stop-stream-btn" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-semibold px-3 py-1.5 rounded-md text-sm" disabled>Stop</button>
                        </div>
                        <div id="stream-status" class="text-xs text-center text-gray-500 h-4"></div>
                    </div>
                </div>

                <div id="example-categories" class="space-y-4 mt-6">
                    <!-- Example categories will be populated by JS -->
                </div>
            </div>
        </div>

        <!-- Right Panel for Editor and Results -->
        <div id="right-panel" class="flex flex-col w-full md:w-3/5 h-full bg-[#252526]">
            <!-- Title Bar for Editor -->
            <div class="flex-shrink-0 bg-[#282828] p-3 border-b border-gray-700">
                <h3 class="text-lg font-semibold text-gray-200">Redis Command Shell</h3>
                <p class="text-sm text-gray-400">Enter Redis commands below. Multiple commands supported (one per line).</p>
            </div>
            <div id="editor-container" class="flex-grow flex flex-col overflow-hidden" style="height: 60%;">
                <div id="editor-wrapper" class="flex-grow relative">
                    <textarea id="command-editor"></textarea>
                </div>
                <div id="action-bar" class="flex-shrink-0 bg-[#282828] p-2 flex justify-end items-center gap-3 border-t border-gray-700">
                    <button id="run-command-btn" class="bg-green-600 hover:bg-green-700 text-white font-semibold px-4 py-1.5 rounded-md text-sm">Run Commands (Ctrl+Enter)</button>
                </div>
            </div>

            <div id="resizer" class="resizer hidden md:block"></div>

            <div id="results-container" class="flex-grow flex flex-col overflow-hidden" style="height: 40%;">
                <div class="flex-shrink-0 bg-[#282828] border-b border-gray-700">
                    <div class="flex items-center justify-between p-2">
                        <div class="flex">
                             <button class="results-tab-btn active px-3 py-1 text-sm font-medium border-b-2 border-transparent" data-tab="console">Console</button>
                             <button class="results-tab-btn px-3 py-1 text-sm font-medium border-b-2 border-transparent" data-tab="subscriptions">Subscriptions</button>
                             <button class="results-tab-btn px-3 py-1 text-sm font-medium border-b-2 border-transparent" data-tab="visualization">Visualization</button>
                        </div>
                        <button id="clear-console-btn" class="text-xs text-gray-400 hover:text-white">Clear</button>
                    </div>
                </div>
                <div id="console-output-content" class="results-tab-content flex-grow bg-[#1e1e1e] overflow-auto custom-scrollbar p-3 console-output">
                    <span class="prompt">></span> Welcome! Check the new Visualization tab to see your data.
                </div>
                 <div id="subscriptions-content" class="results-tab-content hidden flex-grow bg-[#1e1e1e] overflow-auto custom-scrollbar p-3 console-output">
                    <span class="prompt">></span> No subscriptions active. Use SUBSCRIBE command.
                </div>
                <div id="visualization-content" class="results-tab-content hidden flex-grow bg-[#1e1e1e] overflow-auto custom-scrollbar p-3">
                    <!-- DB Visualization will be rendered here -->
                </div>
            </div>
        </div>
    </main>
    
    <!-- Mobile Navigation -->
    <nav class="md:hidden bg-[#282828] border-t border-gray-700 w-full flex-shrink-0">
        <button class="mobile-nav-btn active flex-1 p-3 text-sm text-center font-medium border-t-2" data-view="info">Info</button>
        <button class="mobile-nav-btn flex-1 p-3 text-sm text-center font-medium border-t-2 border-transparent" data-view="editor">Editor</button>
    </nav>


    <script>
        // --- DEDICATED KEY-VALUE STORE CLASS (Complete) ---
        class KeyValueStore {
            constructor() { this.databases = [new Map()]; this.expirations = [new Map()]; this.activeDbIndex = 0; this.transactionQueue = null; this.subscriptions = new Map(); this.pubSubCallback = null; this.config = new Map([['timeout', '0'], ['tcp-keepalive', '0'], ['maxmemory', '0'], ['maxmemory-policy', 'noeviction'], ['save', ''], ['appendonly', 'no'], ['databases', '16']]); }
            setPubSubCallback(callback) { this.pubSubCallback = callback; }
            
            // Enhanced command tokenizer supporting nested structures and comments
            _tokenizeCommand(commandString) {
                const tokens = [];
                let current = '';
                let inQuotes = false;
                let quoteChar = '';
                let inBrackets = 0;
                let inBraces = 0;
                
                for (let i = 0; i < commandString.length; i++) {
                    const char = commandString[i];
                    const nextChar = commandString[i + 1];
                    
                    if (!inQuotes && (char === '"' || char === "'")) {
                        inQuotes = true;
                        quoteChar = char;
                        current += char;
                    } else if (inQuotes && char === quoteChar) {
                        inQuotes = false;
                        current += char;
                        quoteChar = '';
                    } else if (!inQuotes && char === '[') {
                        inBrackets++;
                        current += char;
                    } else if (!inQuotes && char === ']') {
                        inBrackets--;
                        current += char;
                    } else if (!inQuotes && char === '{') {
                        inBraces++;
                        current += char;
                    } else if (!inQuotes && char === '}') {
                        inBraces--;
                        current += char;
                    } else if (!inQuotes && inBrackets === 0 && inBraces === 0 && /\s/.test(char)) {
                        if (current.trim()) {
                            tokens.push(current.trim().replace(/^['"]|['"]$/g, ''));
                            current = '';
                        }
                    } else {
                        current += char;
                    }
                }
                
                if (current.trim()) {
                    tokens.push(current.trim().replace(/^['"]|['"]$/g, ''));
                }
                
                return tokens;
            }
            
            // Support for Redis pipelining
            _parseMultipleCommands(commandString) {
                const lines = commandString.split('\n')
                    .map(line => line.trim())
                    .filter(line => line && !line.startsWith('#') && !line.startsWith('//'));
                return lines;
            }
            
            _executePipeline(commands) {
                const results = [];
                for (const command of commands) {
                    try {
                        const result = this.execute(command, false);
                        results.push(result.data);
                    } catch (e) {
                        results.push(`ERR ${e.message}`);
                    }
                }
                return { status: 'ok', data: results };
            }
            
            execute(commandString, isFromTransaction = false) { 
                try { 
                    if (!commandString || commandString.trim() === '') throw new Error("Command cannot be empty."); 
                    
                    // Support for Redis pipelining - multiple commands separated by newlines
                    const commands = this._parseMultipleCommands(commandString);
                    if (commands.length > 1 && !isFromTransaction) {
                        return this._executePipeline(commands);
                    }
                    
                    // Enhanced parsing with comment support
                    const lines = commandString.split('\n');
                    const cleanLines = lines
                        .map(line => {
                            // Remove comments (# or //)
                            const commentIndex = Math.min(
                                line.indexOf('#') === -1 ? Infinity : line.indexOf('#'),
                                line.indexOf('//') === -1 ? Infinity : line.indexOf('//')
                            );
                            return commentIndex === Infinity ? line : line.substring(0, commentIndex);
                        })
                        .map(line => line.trim())
                        .filter(line => line)
                        .join(' ');
                    
                    if (!cleanLines) throw new Error("No valid commands found.");
                    
                    // Use enhanced tokenizer
                    const parts = this._tokenizeCommand(cleanLines);
                    const command = parts[0].toUpperCase(); 
                    const args = parts.slice(1); 
                    
                    if (this.transactionQueue !== null && !['EXEC', 'DISCARD'].includes(command) && !isFromTransaction) { 
                        this.transactionQueue.push(commandString); 
                        return { status: 'ok', data: 'QUEUED' }; 
                    } switch (command) { case 'HELP': return this.help(args); case 'SET': return this.set(args); case 'GET': return this.get(args); case 'INCR': return this.incrby(args, 1); case 'DECR': return this.incrby(args, -1); case 'INCRBY': return this.incrby(args, parseInt(args[1])); case 'DECRBY': return this.incrby(args, -parseInt(args[1])); case 'DEL': return this.del(args); case 'SELECT': return this.select(args); case 'EXPIRE': return this.expire(args); case 'TTL': return this.ttl(args); case 'EXISTS': return this.exists(args); case 'KEYS': return this.keys(args); case 'FLUSHDB': return this.flushdb(); case 'LPUSH': return this.lpush(args); case 'RPUSH': return this.rpush(args); case 'LPOP': return this.lpop(args); case 'RPOP': return this.rpop(args); case 'LRANGE': return this.lrange(args); case 'HSET': return this.hset(args); case 'HGET': return this.hget(args); case 'HGETALL': return this.hgetall(args); case 'HDEL': return this.hdel(args); case 'SADD': return this.sadd(args); case 'SMEMBERS': return this.smembers(args); case 'SREM': return this.srem(args); case 'SISMEMBER': return this.sismember(args); case 'SCARD': return this.scard(args); case 'ZADD': return this.zadd(args); case 'ZRANGE': return this.zrange(args); case 'ZREM': return this.zrem(args); case 'ZCARD': return this.zcard(args); case 'MULTI': return this.multi(); case 'EXEC': return this.exec(); case 'DISCARD': return this.discard(); case 'XADD': return this.xadd(args); case 'XRANGE': return this.xrange(args); case 'XREAD': return this.xread(args); case 'XGROUP': return this.xgroup(args); case 'XREADGROUP': return this.xreadgroup(args); case 'XACK': return this.xack(args); case 'SUBSCRIBE': return this.subscribe(args); case 'UNSUBSCRIBE': return this.unsubscribe(args); case 'PUBLISH': return this.publish(args); case 'GEOADD': return this.geoadd(args); case 'GEORADIUS': return this.georadius(args); case 'PFADD': return this.pfadd(args); case 'PFCOUNT': return this.pfcount(args); case 'PFMERGE': return this.pfmerge(args); case 'SETBIT': return this.setbit(args); case 'GETBIT': return this.getbit(args); case 'BITCOUNT': return this.bitcount(args); case 'BITOP': return this.bitop(args); case 'MGET': return this.mget(args); case 'MSET': return this.mset(args); case 'STRLEN': return this.strlen(args); case 'APPEND': return this.append(args); case 'GETRANGE': return this.getrange(args); case 'SETRANGE': return this.setrange(args); case 'GETSET': return this.getset(args); case 'SETNX': return this.setnx(args); case 'SETEX': return this.setex(args); case 'LLEN': return this.llen(args); case 'LINDEX': return this.lindex(args); case 'LSET': return this.lset(args); case 'LTRIM': return this.ltrim(args); case 'HEXISTS': return this.hexists(args); case 'HINCRBY': return this.hincrby(args); case 'HKEYS': return this.hkeys(args); case 'HVALS': return this.hvals(args); case 'HLEN': return this.hlen(args); case 'HMSET': return this.hmset(args); case 'HMGET': return this.hmget(args); case 'SPOP': return this.spop(args); case 'SRANDMEMBER': return this.srandmember(args); case 'SUNION': return this.sunion(args); case 'SINTER': return this.sinter(args); case 'SDIFF': return this.sdiff(args); case 'ZRANK': return this.zrank(args); case 'ZSCORE': return this.zscore(args); case 'ZINCRBY': return this.zincrby(args); case 'ZCOUNT': return this.zcount(args); case 'ZRANGEBYSCORE': return this.zrangebyscore(args); case 'ZREVRANGE': return this.zrevrange(args); case 'PING': return this.ping(args); case 'ECHO': return this.echo(args); case 'TIME': return this.time(args); case 'INFO': return this.info(args); case 'TYPE': return this.type(args); case 'PERSIST': return this.persist(args); case 'EXPIREAT': return this.expireat(args); case 'PEXPIRE': return this.pexpire(args); case 'PTTL': return this.pttl(args); case 'RENAME': return this.rename(args); case 'RENAMENX': return this.renamenx(args); case 'RANDOMKEY': return this.randomkey(args); case 'DBSIZE': return this.dbsize(args); case 'FLUSHALL': return this.flushall(args); case 'CONFIG': return this.config(args); case 'CLIENT': return this.client(args); case 'MEMORY': return this.memory(args); case 'LASTSAVE': return this.lastsave(args); case 'SAVE': return this.save(args); case 'BGSAVE': return this.bgsave(args); case 'SHUTDOWN': return this.shutdown(args); default: throw new Error(`Unknown command: '${command}'`); } } catch (e) { if (isFromTransaction) throw e; return { status: 'error', message: e.message }; } }
            _isExpired(key) { const dbExpirations = this.expirations[this.activeDbIndex]; if (dbExpirations.has(key) && dbExpirations.get(key) < Date.now()) { this.databases[this.activeDbIndex].delete(key); dbExpirations.delete(key); return true; } return false; }
            _getKey(key, expectedType) { if (this._isExpired(key)) return undefined; const db = this.databases[this.activeDbIndex]; const value = db.get(key); if (value === undefined) return undefined; const typeError = "WRONGTYPE Operation against a key holding the wrong kind of value"; if (expectedType === 'string' && !(typeof value === 'string')) throw new Error(typeError); if (expectedType === 'list' && !Array.isArray(value)) throw new Error(typeError); if (expectedType === 'hash' && !(value instanceof Map)) throw new Error(typeError); if (expectedType === 'set' && !(value instanceof Set)) throw new Error(typeError); if (expectedType === 'zset' && (!Array.isArray(value) || (value.length > 0 && !value[0].hasOwnProperty('score')))) throw new Error(typeError); if (expectedType === 'stream' && (!value.hasOwnProperty('entries') || !value.hasOwnProperty('groups'))) throw new Error(typeError); if (expectedType === 'geo' && (!Array.isArray(value) || (value.length > 0 && !value[0].hasOwnProperty('lon')))) throw new Error(typeError); return value; }
            set(args) { if (args.length !== 2) throw new Error("SET requires a key and a value."); const [key, value] = args; this.databases[this.activeDbIndex].set(key, value); this.expirations[this.activeDbIndex].delete(key); return { status: 'ok', data: 'OK' }; }
            get(args) { if (args.length !== 1) throw new Error("GET requires a key."); const value = this._getKey(args[0], 'string'); return { status: 'ok', data: value !== undefined ? `"${value}"` : '(nil)' }; }
            incrby(args, increment) { const key = args[0]; if (!key) throw new Error("Command requires a key."); if (isNaN(increment)) throw new Error("Increment must be an integer."); let value = this._getKey(key, 'string'); let num = parseInt(value); if (value === undefined) { num = 0; } if (isNaN(num)) throw new Error("ERR value is not an integer or out of range"); const newValue = num + increment; this.databases[this.activeDbIndex].set(key, newValue.toString()); return { status: 'ok', data: `(integer) ${newValue}` }; }
            decrby(args, increment) { return this.incrby(args, -increment); }
            del(args) { if (args.length < 1) throw new Error("DEL requires at least one key."); let deletedCount = 0; const db = this.databases[this.activeDbIndex]; const dbExpirations = this.expirations[this.activeDbIndex]; args.forEach(key => { if (db.delete(key)) { dbExpirations.delete(key); deletedCount++; } }); return { status: 'ok', data: `(integer) ${deletedCount}` }; }
            select(args) { if (args.length !== 1) throw new Error("SELECT requires a database index."); const index = parseInt(args[0]); if (isNaN(index) || index < 0) throw new Error("Database index must be a non-negative integer."); this.activeDbIndex = index; while (this.databases.length <= index) { this.databases.push(new Map()); this.expirations.push(new Map()); } return { status: 'ok', data: 'OK' }; }
            expire(args) { if (args.length !== 2) throw new Error("EXPIRE requires a key and seconds."); const [key, secondsStr] = args; const seconds = parseInt(secondsStr); if (isNaN(seconds)) throw new Error("Seconds must be an integer."); if (!this._getKey(key)) { return { status: 'ok', data: '(integer) 0' }; } this.expirations[this.activeDbIndex].set(key, Date.now() + (seconds * 1000)); return { status: 'ok', data: '(integer) 1' }; }
            ttl(args) { if (args.length !== 1) throw new Error("TTL requires a key."); const key = args[0]; if (!this._getKey(key)) return { status: 'ok', data: '(integer) -2' }; if (!this.expirations[this.activeDbIndex].has(key)) return { status: 'ok', data: '(integer) -1' }; const remainingMs = this.expirations[this.activeDbIndex].get(key) - Date.now(); return { status: 'ok', data: `(integer) ${Math.ceil(remainingMs / 1000)}` }; }
            exists(args) { if (args.length < 1) throw new Error("EXISTS requires at least one key."); let count = 0; args.forEach(key => { if (this._getKey(key) !== undefined) count++; }); return { status: 'ok', data: `(integer) ${count}` }; }
            keys(args) { if (args.length !== 1 || args[0] !== '*') throw new Error("Only 'KEYS *' is supported."); const allKeys = Array.from(this.databases[this.activeDbIndex].keys()); const validKeys = allKeys.filter(key => !this._isExpired(key)); return { status: 'ok', data: validKeys }; }
            flushdb() { this.databases[this.activeDbIndex].clear(); this.expirations[this.activeDbIndex].clear(); return { status: 'ok', data: 'OK' }; }
            lpush(args) { if (args.length < 2) throw new Error("LPUSH requires a key and at least one value."); const [key, ...values] = args; const db = this.databases[this.activeDbIndex]; let list = this._getKey(key, 'list'); if (list === undefined) { list = []; db.set(key, list); } list.unshift(...values); return { status: 'ok', data: `(integer) ${list.length}` }; }
            rpush(args) { if (args.length < 2) throw new Error("RPUSH requires a key and at least one value."); const [key, ...values] = args; const db = this.databases[this.activeDbIndex]; let list = this._getKey(key, 'list'); if (list === undefined) { list = []; db.set(key, list); } list.push(...values); return { status: 'ok', data: `(integer) ${list.length}` }; }
            lpop(args) { if (args.length !== 1) throw new Error("LPOP requires a key."); const list = this._getKey(args[0], 'list'); if (!list || list.length === 0) return { status: 'ok', data: '(nil)' }; return { status: 'ok', data: `"${list.shift()}"` }; }
            rpop(args) { if (args.length !== 1) throw new Error("RPOP requires a key."); const list = this._getKey(args[0], 'list'); if (!list || list.length === 0) return { status: 'ok', data: '(nil)' }; return { status: 'ok', data: `"${list.pop()}"` }; }
            lrange(args) { if (args.length !== 3) throw new Error("LRANGE requires a key, start, and stop index."); const [key, startStr, stopStr] = args; const list = this._getKey(key, 'list') || []; const start = parseInt(startStr); const stop = parseInt(stopStr); const end = stop >= 0 ? stop + 1 : list.length + stop + 1; return { status: 'ok', data: list.slice(start, end) }; }
            hset(args) { if (args.length !== 3) throw new Error("HSET requires a key, field, and value."); const [key, field, value] = args; const db = this.databases[this.activeDbIndex]; let hash = this._getKey(key, 'hash'); let isNewField = 1; if (hash === undefined) { hash = new Map(); db.set(key, hash); } else if (hash.has(field)) { isNewField = 0; } hash.set(field, value); return { status: 'ok', data: `(integer) ${isNewField}` }; }
            hget(args) { if (args.length !== 2) throw new Error("HGET requires a key and a field."); const [key, field] = args; const hash = this._getKey(key, 'hash'); if (!hash) return { status: 'ok', data: '(nil)' }; const value = hash.get(field); return { status: 'ok', data: value !== undefined ? `"${value}"` : '(nil)' }; }
            hgetall(args) { if (args.length !== 1) throw new Error("HGETALL requires a key."); const hash = this._getKey(args[0], 'hash'); if (!hash) return { status: 'ok', data: '(empty list or set)' }; const result = []; hash.forEach((value, key) => result.push(key, value)); return { status: 'ok', data: result }; }
            hdel(args) { if (args.length < 2) throw new Error("HDEL requires a key and at least one field."); const [key, ...fields] = args; const hash = this._getKey(key, 'hash'); if (!hash) return { status: 'ok', data: '(integer) 0' }; let deletedCount = 0; fields.forEach(field => { if (hash.delete(field)) deletedCount++; }); return { status: 'ok', data: `(integer) ${deletedCount}` }; }
            sadd(args) { if (args.length < 2) throw new Error("SADD requires a key and at least one member."); const [key, ...members] = args; const db = this.databases[this.activeDbIndex]; let set = this._getKey(key, 'set'); if (set === undefined) { set = new Set(); db.set(key, set); } let addedCount = 0; members.forEach(member => { if (!set.has(member)) { set.add(member); addedCount++; } }); return { status: 'ok', data: `(integer) ${addedCount}` }; }
            smembers(args) { if (args.length !== 1) throw new Error("SMEMBERS requires a key."); const set = this._getKey(args[0], 'set') || new Set(); return { status: 'ok', data: Array.from(set) }; }
            srem(args) { if (args.length < 2) throw new Error("SREM requires a key and at least one member."); const [key, ...members] = args; const set = this._getKey(key, 'set'); if (!set) return { status: 'ok', data: '(integer) 0' }; let removedCount = 0; members.forEach(member => { if (set.delete(member)) removedCount++; }); return { status: 'ok', data: `(integer) ${removedCount}` }; }
            sismember(args) { if (args.length !== 2) throw new Error("SISMEMBER requires a key and a member."); const [key, member] = args; const set = this._getKey(key, 'set'); return { status: 'ok', data: `(integer) ${set && set.has(member) ? 1 : 0}` }; }
            scard(args) { if (args.length !== 1) throw new Error("SCARD requires a key."); const set = this._getKey(args[0], 'set') || new Set(); return { status: 'ok', data: `(integer) ${set.size}` }; }
            zadd(args) { if (args.length < 3 || args.length % 2 !== 1) throw new Error("ZADD requires a key and one or more score-member pairs."); const key = args[0]; const db = this.databases[this.activeDbIndex]; let zset = this._getKey(key, 'zset'); if (zset === undefined) { zset = []; db.set(key, zset); } let addedCount = 0; for (let i = 1; i < args.length; i += 2) { const score = parseFloat(args[i]); const member = args[i + 1]; if (isNaN(score)) throw new Error("Score must be a number."); const existing = zset.find(item => item.member === member); if (existing) { existing.score = score; } else { zset.push({ score, member }); addedCount++; } } zset.sort((a, b) => a.score - b.score); return { status: 'ok', data: `(integer) ${addedCount}` }; }
            zrange(args) { if (args.length < 3) throw new Error("ZRANGE requires a key, start, and stop."); const [key, startStr, stopStr, withscores] = args; const zset = this._getKey(key, 'zset') || []; const start = parseInt(startStr); const stop = parseInt(stopStr); const end = stop >= 0 ? stop + 1 : zset.length + stop + 1; const results = zset.slice(start, end); if (withscores && withscores.toUpperCase() === 'WITHSCORES') { return { status: 'ok', data: results.flatMap(item => [item.member, item.score.toString()]) }; } return { status: 'ok', data: results.map(item => item.member) }; }
            zrem(args) { if (args.length < 2) throw new Error("ZREM requires a key and at least one member."); const [key, ...members] = args; let zset = this._getKey(key, 'zset'); if (!zset) return { status: 'ok', data: '(integer) 0' }; let removedCount = 0; const initialSize = zset.length; zset = zset.filter(item => !members.includes(item.member)); removedCount = initialSize - zset.length; this.databases[this.activeDbIndex].set(key, zset); return { status: 'ok', data: `(integer) ${removedCount}` }; }
            zcard(args) { if (args.length !== 1) throw new Error("ZCARD requires a key."); const zset = this._getKey(args[0], 'zset') || []; return { status: 'ok', data: `(integer) ${zset.length}` }; }
            multi() { if (this.transactionQueue !== null) throw new Error("MULTI calls can't be nested."); this.transactionQueue = []; return { status: 'ok', data: 'OK' }; }
            exec() { if (this.transactionQueue === null) throw new Error("EXEC without MULTI."); const results = []; for (const command of this.transactionQueue) { try { const result = this.execute(command, true); results.push(result.data); } catch (e) { this.transactionQueue = null; throw new Error(`Transaction aborted: ${e.message}`); } } this.transactionQueue = null; return { status: 'ok', data: results }; }
            discard() { if (this.transactionQueue === null) throw new Error("DISCARD without MULTI."); this.transactionQueue = null; return { status: 'ok', data: 'OK' }; }
            _generateStreamId(stream, providedId) { const lastId = stream.entries.length > 0 ? stream.entries[stream.entries.length - 1].id : '0-0'; const [lastMs, lastSeq] = lastId.split('-').map(Number); if (providedId === '*') { let newMs = Date.now(); if (newMs > lastMs) { return `${newMs}-0`; } else { return `${lastMs}-${lastSeq + 1}`; } } const [ms, seq] = providedId.split('-').map(Number); if (isNaN(ms) || isNaN(seq) || ms < lastMs || (ms === lastMs && seq <= lastSeq)) { throw new Error("The ID specified in XADD is equal or smaller than the target stream's last-generated ID"); } return providedId; }
            xadd(args) { if (args.length < 4 || args.length % 2 !== 0) throw new Error("XADD requires key, ID, and at least one field-value pair."); const [key, id, ...fieldValues] = args; const db = this.databases[this.activeDbIndex]; let stream = this._getKey(key, 'stream'); if (stream === undefined) { stream = { entries: [], groups: new Map() }; db.set(key, stream); } const newId = this._generateStreamId(stream, id); stream.entries.push({ id: newId, data: fieldValues }); return { status: 'ok', data: `"${newId}"` }; }
            xrange(args) { if (args.length !== 3) throw new Error("XRANGE requires key, start, and end."); const [key, start, end] = args; const stream = this._getKey(key, 'stream'); if (!stream) return { status: 'ok', data: '(empty list or set)' }; const startId = start === '-' ? '0-0' : start; const endId = end === '+' ? '9999999999999-999999' : end; const results = stream.entries.filter(entry => entry.id >= startId && entry.id <= endId); return { status: 'ok', data: results.map(e => [e.id, e.data]) }; }
            xread(args) { const streamsIdx = args.findIndex(arg => arg.toUpperCase() === 'STREAMS'); if (streamsIdx === -1) throw new Error("XREAD requires a STREAMS argument."); const streamKeysAndIds = args.slice(streamsIdx + 1); const numStreams = streamKeysAndIds.length / 2; const keys = streamKeysAndIds.slice(0, numStreams); const startIds = streamKeysAndIds.slice(numStreams); const results = []; for (let i = 0; i < keys.length; i++) { const key = keys[i]; const startId = startIds[i]; const stream = this._getKey(key, 'stream'); if (!stream) continue; const streamResults = stream.entries.filter(entry => entry.id > startId); if (streamResults.length > 0) { results.push([key, streamResults.map(e => [e.id, e.data])]); } } return { status: 'ok', data: results.length > 0 ? results : '(nil)' }; }
            xgroup(args) { const [subcommand, key, groupname, id] = args; if (subcommand.toUpperCase() !== 'CREATE') throw new Error("Only XGROUP CREATE is supported."); const stream = this._getKey(key, 'stream'); if (!stream) throw new Error("The stream does not exist."); if (stream.groups.has(groupname)) throw new Error(`Consumer group '${groupname}' already exists.`); stream.groups.set(groupname, { lastDeliveredId: id, pending: new Map() }); return { status: 'ok', data: 'OK' }; }
            xreadgroup(args) { const [groupLiteral, groupname, consumer, streamsLiteral, key, id] = args; if (groupLiteral.toUpperCase() !== 'GROUP' || streamsLiteral.toUpperCase() !== 'STREAMS' || id !== '>') throw new Error("Invalid XREADGROUP syntax."); const stream = this._getKey(key, 'stream'); if (!stream) return { status: 'ok', data: '(nil)' }; const group = stream.groups.get(groupname); if (!group) throw new Error(`Consumer group '${groupname}' does not exist.`); const newEntries = stream.entries.filter(entry => entry.id > group.lastDeliveredId); if (newEntries.length === 0) return { status: 'ok', data: '(nil)' }; const entry = newEntries[0]; group.lastDeliveredId = entry.id; group.pending.set(entry.id, { consumer, deliveredAt: Date.now() }); return { status: 'ok', data: [[key, [[entry.id, entry.data]]]] }; }
            xack(args) { if (args.length !== 3) throw new Error("XACK requires key, group, and ID."); const [key, groupname, id] = args; const stream = this._getKey(key, 'stream'); if (!stream) return { status: 'ok', data: '(integer) 0' }; const group = stream.groups.get(groupname); if (!group) return { status: 'ok', data: '(integer) 0' }; return { status: 'ok', data: `(integer) ${group.pending.delete(id) ? 1 : 0}` }; }
            subscribe(args) { if (args.length < 1) throw new Error("SUBSCRIBE requires at least one channel."); args.forEach(channel => { if (!this.subscriptions.has(channel)) { this.subscriptions.set(channel, new Set()); } this.subscriptions.get(channel).add(this.pubSubCallback); }); return { status: 'ok', data: `Subscribed to ${args.length} channel(s).` }; }
            unsubscribe(args) { if (args.length < 1) throw new Error("UNSUBSCRIBE requires at least one channel."); args.forEach(channel => { if (this.subscriptions.has(channel)) { this.subscriptions.get(channel).delete(this.pubSubCallback); } }); return { status: 'ok', data: `Unsubscribed from ${args.length} channel(s).` }; }
            publish(args) { if (args.length !== 2) throw new Error("PUBLISH requires a channel and a message."); const [channel, message] = args; const listeners = this.subscriptions.get(channel); let count = 0; if (listeners) { listeners.forEach(cb => { cb(channel, message); count++; }); } return { status: 'ok', data: `(integer) ${count}` }; }
            geoadd(args) { if (args.length < 4 || args.length % 3 !== 1) throw new Error("GEOADD requires key and one or more lon-lat-member triplets."); const key = args[0]; const db = this.databases[this.activeDbIndex]; let geoSet = this._getKey(key, 'geo'); if (geoSet === undefined) { geoSet = []; db.set(key, geoSet); } let addedCount = 0; for (let i = 1; i < args.length; i += 3) { const [lon, lat, member] = [parseFloat(args[i]), parseFloat(args[i+1]), args[i+2]]; if (isNaN(lon) || isNaN(lat)) throw new Error("Longitude and latitude must be numbers."); if (!geoSet.some(item => item.member === member)) { geoSet.push({ lon, lat, member }); addedCount++; } } return { status: 'ok', data: `(integer) ${addedCount}` }; }
            georadius(args) { if (args.length < 5) throw new Error("GEORADIUS requires key, lon, lat, radius, and unit."); const [key, lon, lat, radius, unit] = args.map((a, i) => i > 0 && i < 4 ? parseFloat(a) : a); const geoSet = this._getKey(key, 'geo') || []; const results = []; geoSet.forEach(item => { const dist = this._haversineDistance([lat, lon], [item.lat, item.lon], unit.toLowerCase()); if (dist <= radius) { results.push(item.member); } }); return { status: 'ok', data: results }; }
            _haversineDistance([lat1, lon1], [lat2, lon2], unit) { const R = unit === 'km' ? 6371 : unit === 'mi' ? 3959 : unit === 'ft' ? 20902231 : 6371000; const dLat = (lat2 - lat1) * Math.PI / 180; const dLon = (lon2 - lon1) * Math.PI / 180; const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2); const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return R * c; }
            
            // HyperLogLog approximation (simplified implementation)
            pfadd(args) { if (args.length < 2) throw new Error("PFADD requires a key and at least one element."); const [key, ...elements] = args; const db = this.databases[this.activeDbIndex]; let hll = this._getKey(key, 'hll'); if (hll === undefined) { hll = new Set(); db.set(key, hll); } let addedCount = 0; elements.forEach(elem => { const hash = this._simpleHash(elem); if (!hll.has(hash)) { hll.add(hash); addedCount++; } }); return { status: 'ok', data: `(integer) ${addedCount}` }; }
            pfcount(args) { if (args.length < 1) throw new Error("PFCOUNT requires at least one key."); let totalCount = 0; args.forEach(key => { const hll = this._getKey(key, 'hll'); if (hll) totalCount += hll.size; }); return { status: 'ok', data: `(integer) ${Math.round(totalCount * 0.7213 / (1 + 1.079 / totalCount))}` }; }
            pfmerge(args) { if (args.length < 2) throw new Error("PFMERGE requires a destination key and at least one source key."); const [destKey, ...sourceKeys] = args; const db = this.databases[this.activeDbIndex]; let merged = new Set(); sourceKeys.forEach(key => { const hll = this._getKey(key, 'hll'); if (hll) hll.forEach(hash => merged.add(hash)); }); db.set(destKey, merged); return { status: 'ok', data: 'OK' }; }
            
            // Bitmap operations  
            setbit(args) { if (args.length !== 3) throw new Error("SETBIT requires key, offset, and value."); const [key, offsetStr, valueStr] = args; const offset = parseInt(offsetStr); const value = parseInt(valueStr); if (isNaN(offset) || offset < 0) throw new Error("Offset must be a non-negative integer."); if (value !== 0 && value !== 1) throw new Error("Value must be 0 or 1."); const db = this.databases[this.activeDbIndex]; let bitmap = this._getKey(key, 'bitmap'); if (bitmap === undefined) { bitmap = new Uint8Array(Math.ceil((offset + 1) / 8)); db.set(key, bitmap); } else if (bitmap.length * 8 <= offset) { const newBitmap = new Uint8Array(Math.ceil((offset + 1) / 8)); newBitmap.set(bitmap); bitmap = newBitmap; db.set(key, bitmap); } const byteIndex = Math.floor(offset / 8); const bitIndex = offset % 8; const oldValue = (bitmap[byteIndex] >> (7 - bitIndex)) & 1; if (value === 1) { bitmap[byteIndex] |= (1 << (7 - bitIndex)); } else { bitmap[byteIndex] &= ~(1 << (7 - bitIndex)); } return { status: 'ok', data: `(integer) ${oldValue}` }; }
            getbit(args) { if (args.length !== 2) throw new Error("GETBIT requires key and offset."); const [key, offsetStr] = args; const offset = parseInt(offsetStr); if (isNaN(offset) || offset < 0) throw new Error("Offset must be a non-negative integer."); const bitmap = this._getKey(key, 'bitmap'); if (!bitmap || bitmap.length * 8 <= offset) return { status: 'ok', data: '(integer) 0' }; const byteIndex = Math.floor(offset / 8); const bitIndex = offset % 8; const value = (bitmap[byteIndex] >> (7 - bitIndex)) & 1; return { status: 'ok', data: `(integer) ${value}` }; }
            
            // Help command
            help(args) {
                const helpText = `
Redis Command Shell - Available Commands:

üìù STRING OPERATIONS:
  SET key value              - Set string value
  GET key                    - Get string value
  INCR/DECR key             - Increment/decrement integer
  MGET key1 key2...         - Get multiple values
  MSET key1 val1 key2 val2  - Set multiple values

üìã LIST OPERATIONS:
  LPUSH/RPUSH key value     - Add to list start/end
  LPOP/RPOP key            - Remove from list start/end
  LRANGE key start stop    - Get list range

üóÇÔ∏è HASH OPERATIONS:
  HSET key field value     - Set hash field
  HGET key field          - Get hash field
  HGETALL key             - Get all hash fields

üéØ SET OPERATIONS:
  SADD key member         - Add to set
  SMEMBERS key           - Get all set members
  SISMEMBER key member   - Check set membership

‚öñÔ∏è SORTED SET OPERATIONS:
  ZADD key score member  - Add to sorted set
  ZRANGE key start stop  - Get sorted set range

üåä STREAM OPERATIONS:
  XADD key * field value - Add to stream
  XRANGE key start end   - Read stream range
  XGROUP CREATE key group id - Create consumer group

üåç GEO OPERATIONS:
  GEOADD key lon lat member - Add geo location
  GEORADIUS key lon lat radius unit - Find nearby locations

üî¢ HYPERLOGLOG:
  PFADD key element      - Add to HyperLogLog
  PFCOUNT key           - Count unique elements

‚ö° BITMAP:
  SETBIT key offset value - Set bit
  GETBIT key offset      - Get bit

üîß UTILITY:
  KEYS *                 - List all keys
  DEL key               - Delete key
  EXISTS key            - Check if key exists
  TTL key              - Get time to live
  EXPIRE key seconds   - Set expiration
  SELECT database      - Switch database
  FLUSHDB             - Clear current database
  HELP                - Show this help

üíæ TRANSACTIONS:
  MULTI               - Start transaction
  EXEC               - Execute transaction
  DISCARD            - Cancel transaction
`;
                return { status: 'ok', data: helpText };
            }
            bitcount(args) { if (args.length < 1) throw new Error("BITCOUNT requires a key."); const [key] = args; const bitmap = this._getKey(key, 'bitmap'); if (!bitmap) return { status: 'ok', data: '(integer) 0' }; let count = 0; for (let i = 0; i < bitmap.length; i++) { let byte = bitmap[i]; while (byte) { count += byte & 1; byte >>= 1; } } return { status: 'ok', data: `(integer) ${count}` }; }
            bitop(args) { if (args.length < 3) throw new Error("BITOP requires operation, destination key, and at least one source key."); const [operation, destKey, ...sourceKeys] = args; const op = operation.toUpperCase(); if (!['AND', 'OR', 'XOR', 'NOT'].includes(op)) throw new Error("Operation must be AND, OR, XOR, or NOT."); const db = this.databases[this.activeDbIndex]; const bitmaps = sourceKeys.map(key => this._getKey(key, 'bitmap') || new Uint8Array(0)); const maxLength = Math.max(...bitmaps.map(b => b.length), 1); const result = new Uint8Array(maxLength); for (let i = 0; i < maxLength; i++) { let value = op === 'NOT' ? 255 : (op === 'AND' ? 255 : 0); bitmaps.forEach(bitmap => { const byte = i < bitmap.length ? bitmap[i] : 0; if (op === 'AND') value &= byte; else if (op === 'OR') value |= byte; else if (op === 'XOR') value ^= byte; else if (op === 'NOT') value = ~bitmaps[0][i] & 255; }); result[i] = value; } db.set(destKey, result); return { status: 'ok', data: `(integer) ${maxLength}` }; }
            
            _simpleHash(str) { let hash = 0; for (let i = 0; i < str.length; i++) { const char = str.charCodeAt(i); hash = ((hash << 5) - hash) + char; hash = hash & hash; } return Math.abs(hash); }
            
            // Additional Redis Commands
            mget(args) { if (args.length < 1) throw new Error("MGET requires at least one key."); const results = args.map(key => { const value = this._getKey(key, 'string'); return value !== undefined ? `"${value}"` : '(nil)'; }); return { status: 'ok', data: results }; }
            mset(args) { if (args.length < 2 || args.length % 2 !== 0) throw new Error("MSET requires pairs of key-value arguments."); const db = this.databases[this.activeDbIndex]; for (let i = 0; i < args.length; i += 2) { db.set(args[i], args[i + 1]); this.expirations[this.activeDbIndex].delete(args[i]); } return { status: 'ok', data: 'OK' }; }
            strlen(args) { if (args.length !== 1) throw new Error("STRLEN requires a key."); const value = this._getKey(args[0], 'string'); return { status: 'ok', data: `(integer) ${value ? value.length : 0}` }; }
            append(args) { if (args.length !== 2) throw new Error("APPEND requires a key and value."); const [key, appendValue] = args; let current = this._getKey(key, 'string') || ''; current += appendValue; this.databases[this.activeDbIndex].set(key, current); return { status: 'ok', data: `(integer) ${current.length}` }; }
            getrange(args) { if (args.length !== 3) throw new Error("GETRANGE requires key, start and end."); const [key, startStr, endStr] = args; const value = this._getKey(key, 'string') || ''; const start = parseInt(startStr); const end = parseInt(endStr); const result = value.slice(start, end + 1); return { status: 'ok', data: `"${result}"` }; }
            setrange(args) { if (args.length !== 3) throw new Error("SETRANGE requires key, offset and value."); const [key, offsetStr, value] = args; const offset = parseInt(offsetStr); let current = this._getKey(key, 'string') || ''; current = current.padEnd(offset, '\0') + value; this.databases[this.activeDbIndex].set(key, current); return { status: 'ok', data: `(integer) ${current.length}` }; }
            getset(args) { if (args.length !== 2) throw new Error("GETSET requires key and value."); const [key, value] = args; const old = this._getKey(key, 'string'); this.databases[this.activeDbIndex].set(key, value); return { status: 'ok', data: old !== undefined ? `"${old}"` : '(nil)' }; }
            setnx(args) { if (args.length !== 2) throw new Error("SETNX requires key and value."); const [key, value] = args; if (this._getKey(key) !== undefined) return { status: 'ok', data: '(integer) 0' }; this.databases[this.activeDbIndex].set(key, value); return { status: 'ok', data: '(integer) 1' }; }
            setex(args) { if (args.length !== 3) throw new Error("SETEX requires key, seconds and value."); const [key, secondsStr, value] = args; const seconds = parseInt(secondsStr); this.databases[this.activeDbIndex].set(key, value); this.expirations[this.activeDbIndex].set(key, Date.now() + (seconds * 1000)); return { status: 'ok', data: 'OK' }; }
            
            // List commands
            llen(args) { if (args.length !== 1) throw new Error("LLEN requires a key."); const list = this._getKey(args[0], 'list'); return { status: 'ok', data: `(integer) ${list ? list.length : 0}` }; }
            lindex(args) { if (args.length !== 2) throw new Error("LINDEX requires key and index."); const [key, indexStr] = args; const list = this._getKey(key, 'list'); if (!list) return { status: 'ok', data: '(nil)' }; const index = parseInt(indexStr); const item = index >= 0 ? list[index] : list[list.length + index]; return { status: 'ok', data: item !== undefined ? `"${item}"` : '(nil)' }; }
            lset(args) { if (args.length !== 3) throw new Error("LSET requires key, index and value."); const [key, indexStr, value] = args; const list = this._getKey(key, 'list'); if (!list) throw new Error("ERR no such key"); const index = parseInt(indexStr); if (index < 0 || index >= list.length) throw new Error("ERR index out of range"); list[index] = value; return { status: 'ok', data: 'OK' }; }
            ltrim(args) { if (args.length !== 3) throw new Error("LTRIM requires key, start and stop."); const [key, startStr, stopStr] = args; const list = this._getKey(key, 'list'); if (!list) return { status: 'ok', data: 'OK' }; const start = parseInt(startStr); const stop = parseInt(stopStr); const trimmed = list.slice(start, stop + 1); this.databases[this.activeDbIndex].set(key, trimmed); return { status: 'ok', data: 'OK' }; }
            
            // Hash commands
            hexists(args) { if (args.length !== 2) throw new Error("HEXISTS requires key and field."); const [key, field] = args; const hash = this._getKey(key, 'hash'); return { status: 'ok', data: `(integer) ${hash && hash.has(field) ? 1 : 0}` }; }
            hincrby(args) { if (args.length !== 3) throw new Error("HINCRBY requires key, field and increment."); const [key, field, incrStr] = args; const incr = parseInt(incrStr); let hash = this._getKey(key, 'hash'); if (!hash) { hash = new Map(); this.databases[this.activeDbIndex].set(key, hash); } const current = parseInt(hash.get(field) || '0'); const newValue = current + incr; hash.set(field, newValue.toString()); return { status: 'ok', data: `(integer) ${newValue}` }; }
            hkeys(args) { if (args.length !== 1) throw new Error("HKEYS requires a key."); const hash = this._getKey(args[0], 'hash'); return { status: 'ok', data: hash ? Array.from(hash.keys()) : [] }; }
            hvals(args) { if (args.length !== 1) throw new Error("HVALS requires a key."); const hash = this._getKey(args[0], 'hash'); return { status: 'ok', data: hash ? Array.from(hash.values()) : [] }; }
            hlen(args) { if (args.length !== 1) throw new Error("HLEN requires a key."); const hash = this._getKey(args[0], 'hash'); return { status: 'ok', data: `(integer) ${hash ? hash.size : 0}` }; }
            hmset(args) { if (args.length < 3 || args.length % 2 === 0) throw new Error("HMSET requires key and pairs of field-value."); const key = args[0]; let hash = this._getKey(key, 'hash'); if (!hash) { hash = new Map(); this.databases[this.activeDbIndex].set(key, hash); } for (let i = 1; i < args.length; i += 2) { hash.set(args[i], args[i + 1]); } return { status: 'ok', data: 'OK' }; }
            hmget(args) { if (args.length < 2) throw new Error("HMGET requires key and at least one field."); const [key, ...fields] = args; const hash = this._getKey(key, 'hash'); const results = fields.map(field => hash && hash.has(field) ? `"${hash.get(field)}"` : '(nil)'); return { status: 'ok', data: results }; }
            
            // Set commands
            spop(args) { if (args.length < 1) throw new Error("SPOP requires a key."); const [key, countStr] = args; const set = this._getKey(key, 'set'); if (!set || set.size === 0) return { status: 'ok', data: '(nil)' }; const count = countStr ? parseInt(countStr) : 1; const items = Array.from(set); const popped = []; for (let i = 0; i < Math.min(count, items.length); i++) { const randomIndex = Math.floor(Math.random() * items.length); const item = items.splice(randomIndex, 1)[0]; set.delete(item); popped.push(`"${item}"`); } return { status: 'ok', data: count === 1 ? popped[0] : popped }; }
            srandmember(args) { if (args.length < 1) throw new Error("SRANDMEMBER requires a key."); const [key, countStr] = args; const set = this._getKey(key, 'set'); if (!set || set.size === 0) return { status: 'ok', data: '(nil)' }; const items = Array.from(set); const count = countStr ? parseInt(countStr) : 1; if (count === 1) { const randomItem = items[Math.floor(Math.random() * items.length)]; return { status: 'ok', data: `"${randomItem}"` }; } const result = []; for (let i = 0; i < Math.min(Math.abs(count), items.length); i++) { const randomItem = items[Math.floor(Math.random() * items.length)]; result.push(`"${randomItem}"`); } return { status: 'ok', data: result }; }
            sunion(args) { if (args.length < 1) throw new Error("SUNION requires at least one key."); const result = new Set(); args.forEach(key => { const set = this._getKey(key, 'set'); if (set) set.forEach(item => result.add(item)); }); return { status: 'ok', data: Array.from(result) }; }
            sinter(args) { if (args.length < 1) throw new Error("SINTER requires at least one key."); const firstSet = this._getKey(args[0], 'set'); if (!firstSet) return { status: 'ok', data: [] }; let result = new Set(firstSet); for (let i = 1; i < args.length; i++) { const set = this._getKey(args[i], 'set'); if (!set) return { status: 'ok', data: [] }; result = new Set([...result].filter(x => set.has(x))); } return { status: 'ok', data: Array.from(result) }; }
            sdiff(args) { if (args.length < 1) throw new Error("SDIFF requires at least one key."); const firstSet = this._getKey(args[0], 'set'); if (!firstSet) return { status: 'ok', data: [] }; let result = new Set(firstSet); for (let i = 1; i < args.length; i++) { const set = this._getKey(args[i], 'set'); if (set) set.forEach(item => result.delete(item)); } return { status: 'ok', data: Array.from(result) }; }
            
            // Sorted set commands  
            zrank(args) { if (args.length !== 2) throw new Error("ZRANK requires key and member."); const [key, member] = args; const zset = this._getKey(key, 'zset'); if (!zset) return { status: 'ok', data: '(nil)' }; const sorted = zset.sort((a, b) => a.score - b.score); const index = sorted.findIndex(item => item.member === member); return { status: 'ok', data: index >= 0 ? `(integer) ${index}` : '(nil)' }; }
            zscore(args) { if (args.length !== 2) throw new Error("ZSCORE requires key and member."); const [key, member] = args; const zset = this._getKey(key, 'zset'); if (!zset) return { status: 'ok', data: '(nil)' }; const item = zset.find(item => item.member === member); return { status: 'ok', data: item ? item.score.toString() : '(nil)' }; }
            zincrby(args) { if (args.length !== 3) throw new Error("ZINCRBY requires key, increment and member."); const [key, incrStr, member] = args; const incr = parseFloat(incrStr); let zset = this._getKey(key, 'zset'); if (!zset) { zset = []; this.databases[this.activeDbIndex].set(key, zset); } const existingIndex = zset.findIndex(item => item.member === member); if (existingIndex >= 0) { zset[existingIndex].score += incr; } else { zset.push({ member, score: incr }); } return { status: 'ok', data: zset.find(item => item.member === member).score.toString() }; }
            zcount(args) { if (args.length !== 3) throw new Error("ZCOUNT requires key, min and max."); const [key, minStr, maxStr] = args; const zset = this._getKey(key, 'zset'); if (!zset) return { status: 'ok', data: '(integer) 0' }; const min = parseFloat(minStr); const max = parseFloat(maxStr); const count = zset.filter(item => item.score >= min && item.score <= max).length; return { status: 'ok', data: `(integer) ${count}` }; }
            zrangebyscore(args) { if (args.length < 3) throw new Error("ZRANGEBYSCORE requires key, min and max."); const [key, minStr, maxStr] = args; const zset = this._getKey(key, 'zset'); if (!zset) return { status: 'ok', data: [] }; const min = parseFloat(minStr); const max = parseFloat(maxStr); const filtered = zset.filter(item => item.score >= min && item.score <= max).sort((a, b) => a.score - b.score); return { status: 'ok', data: filtered.map(item => item.member) }; }
            zrevrange(args) { if (args.length < 3) throw new Error("ZREVRANGE requires key, start and stop."); const [key, startStr, stopStr] = args; const zset = this._getKey(key, 'zset'); if (!zset) return { status: 'ok', data: [] }; const start = parseInt(startStr); const stop = parseInt(stopStr); const sorted = zset.sort((a, b) => b.score - a.score); const sliced = sorted.slice(start, stop + 1); return { status: 'ok', data: sliced.map(item => item.member) }; }
            
            // Utility commands
            ping(args) { return { status: 'ok', data: args.length > 0 ? args[0] : 'PONG' }; }
            echo(args) { if (args.length !== 1) throw new Error("ECHO requires a message."); return { status: 'ok', data: `"${args[0]}"` }; }
            time(args) { const now = Date.now(); const seconds = Math.floor(now / 1000); const microseconds = (now % 1000) * 1000; return { status: 'ok', data: [seconds.toString(), microseconds.toString()] }; }
            info(args) { const section = args[0] || 'default'; const info = { server: 'Redis Compatible emulator', version: '1.0.0', mode: 'standalone', databases: this.databases.length }; return { status: 'ok', data: Object.entries(info).map(([k, v]) => `${k}:${v}`).join('\r\n') }; }
            type(args) { if (args.length !== 1) throw new Error("TYPE requires a key."); const key = args[0]; const value = this._getKey(key); if (value === undefined) return { status: 'ok', data: 'none' }; if (typeof value === 'string') return { status: 'ok', data: 'string' }; if (Array.isArray(value)) { if (value.length > 0 && value[0].hasOwnProperty('score')) return { status: 'ok', data: 'zset' }; return { status: 'ok', data: 'list' }; } if (value instanceof Set) return { status: 'ok', data: 'set' }; if (value instanceof Map) return { status: 'ok', data: 'hash' }; return { status: 'ok', data: 'string' }; }
            persist(args) { if (args.length !== 1) throw new Error("PERSIST requires a key."); const key = args[0]; if (!this._getKey(key)) return { status: 'ok', data: '(integer) 0' }; const removed = this.expirations[this.activeDbIndex].delete(key); return { status: 'ok', data: `(integer) ${removed ? 1 : 0}` }; }
            expireat(args) { if (args.length !== 2) throw new Error("EXPIREAT requires key and timestamp."); const [key, timestampStr] = args; const timestamp = parseInt(timestampStr); if (!this._getKey(key)) return { status: 'ok', data: '(integer) 0' }; this.expirations[this.activeDbIndex].set(key, timestamp * 1000); return { status: 'ok', data: '(integer) 1' }; }
            pexpire(args) { if (args.length !== 2) throw new Error("PEXPIRE requires key and milliseconds."); const [key, msStr] = args; const ms = parseInt(msStr); if (!this._getKey(key)) return { status: 'ok', data: '(integer) 0' }; this.expirations[this.activeDbIndex].set(key, Date.now() + ms); return { status: 'ok', data: '(integer) 1' }; }
            pttl(args) { if (args.length !== 1) throw new Error("PTTL requires a key."); const key = args[0]; if (!this._getKey(key)) return { status: 'ok', data: '(integer) -2' }; if (!this.expirations[this.activeDbIndex].has(key)) return { status: 'ok', data: '(integer) -1' }; const remainingMs = this.expirations[this.activeDbIndex].get(key) - Date.now(); return { status: 'ok', data: `(integer) ${Math.max(0, remainingMs)}` }; }
            rename(args) { if (args.length !== 2) throw new Error("RENAME requires old and new key."); const [oldKey, newKey] = args; const value = this._getKey(oldKey); if (value === undefined) throw new Error("ERR no such key"); const db = this.databases[this.activeDbIndex]; db.set(newKey, value); db.delete(oldKey); const expiration = this.expirations[this.activeDbIndex].get(oldKey); if (expiration) { this.expirations[this.activeDbIndex].set(newKey, expiration); this.expirations[this.activeDbIndex].delete(oldKey); } return { status: 'ok', data: 'OK' }; }
            renamenx(args) { if (args.length !== 2) throw new Error("RENAMENX requires old and new key."); const [oldKey, newKey] = args; if (this._getKey(newKey) !== undefined) return { status: 'ok', data: '(integer) 0' }; const value = this._getKey(oldKey); if (value === undefined) throw new Error("ERR no such key"); this.rename(args); return { status: 'ok', data: '(integer) 1' }; }
            randomkey(args) { const db = this.databases[this.activeDbIndex]; const keys = Array.from(db.keys()).filter(key => !this._isExpired(key)); return { status: 'ok', data: keys.length > 0 ? `"${keys[Math.floor(Math.random() * keys.length)]}"` : '(nil)' }; }
            dbsize(args) { const db = this.databases[this.activeDbIndex]; const validKeys = Array.from(db.keys()).filter(key => !this._isExpired(key)); return { status: 'ok', data: `(integer) ${validKeys.length}` }; }
            flushall(args) { this.databases.forEach((db, index) => { db.clear(); this.expirations[index].clear(); }); return { status: 'ok', data: 'OK' }; }
            
            // Configuration and admin commands
            config(args) {
                if (args.length < 1) throw new Error("CONFIG requires a subcommand");
                const subcommand = args[0].toUpperCase();
                
                if (subcommand === 'GET') {
                    if (args.length !== 2) throw new Error("CONFIG GET requires a parameter name");
                    const param = args[1].toLowerCase();
                    if (param === '*') {
                        return { status: 'ok', data: Array.from(this.config.entries()).flat() };
                    }
                    const value = this.config.get(param);
                    return { status: 'ok', data: value !== undefined ? [param, value] : [] };
                } else if (subcommand === 'SET') {
                    if (args.length !== 3) throw new Error("CONFIG SET requires parameter name and value");
                    const [, param, value] = args;
                    this.config.set(param.toLowerCase(), value);
                    return { status: 'ok', data: 'OK' };
                } else if (subcommand === 'RESETSTAT') {
                    return { status: 'ok', data: 'OK' };
                } else if (subcommand === 'REWRITE') {
                    return { status: 'ok', data: 'OK' };
                } else {
                    throw new Error(`Unknown CONFIG subcommand: ${subcommand}`);
                }
            }
            
            client(args) {
                if (args.length < 1) throw new Error("CLIENT requires a subcommand");
                const subcommand = args[0].toUpperCase();
                
                if (subcommand === 'LIST') {
                    return { status: 'ok', data: 'id=1 addr=127.0.0.1:6379 fd=1 name= age=1 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client' };
                } else if (subcommand === 'GETNAME') {
                    return { status: 'ok', data: '(nil)' };
                } else if (subcommand === 'SETNAME') {
                    return { status: 'ok', data: 'OK' };
                } else if (subcommand === 'KILL') {
                    return { status: 'ok', data: 'OK' };
                } else {
                    throw new Error(`Unknown CLIENT subcommand: ${subcommand}`);
                }
            }
            
            memory(args) {
                const subcommand = args[0]?.toUpperCase() || 'USAGE';
                
                if (subcommand === 'USAGE') {
                    return { status: 'ok', data: `(integer) 1024` };
                } else if (subcommand === 'STATS') {
                    return { status: 'ok', data: { 'peak.allocated': 1024, 'total.allocated': 512, 'startup.allocated': 256 } };
                } else {
                    throw new Error(`Unknown MEMORY subcommand: ${subcommand}`);
                }
            }
            
            lastsave(args) {
                return { status: 'ok', data: `(integer) ${Math.floor(Date.now() / 1000)}` };
            }
            
            save(args) {
                return { status: 'ok', data: 'OK' };
            }
            
            bgsave(args) {
                return { status: 'ok', data: 'Background saving started' };
            }
            
            shutdown(args) {
                return { status: 'ok', data: 'OK' };
            }
            
            _getKey(key, expectedType) { if (this._isExpired(key)) return undefined; const db = this.databases[this.activeDbIndex]; const value = db.get(key); if (value === undefined) return undefined; const typeError = "WRONGTYPE Operation against a key holding the wrong kind of value"; if (expectedType === 'string' && !(typeof value === 'string')) throw new Error(typeError); if (expectedType === 'list' && !Array.isArray(value)) throw new Error(typeError); if (expectedType === 'hash' && !(value instanceof Map)) throw new Error(typeError); if (expectedType === 'set' && !(value instanceof Set)) throw new Error(typeError); if (expectedType === 'zset' && (!Array.isArray(value) || (value.length > 0 && !value[0].hasOwnProperty('score')))) throw new Error(typeError); if (expectedType === 'stream' && (!value.hasOwnProperty('entries') || !value.hasOwnProperty('groups'))) throw new Error(typeError); if (expectedType === 'geo' && (!Array.isArray(value) || (value.length > 0 && !value[0].hasOwnProperty('lon')))) throw new Error(typeError); if (expectedType === 'hll' && !(value instanceof Set)) throw new Error(typeError); if (expectedType === 'bitmap' && !(value instanceof Uint8Array)) throw new Error(typeError); return value; }
        }

        // --- UI LOGIC
        document.addEventListener('DOMContentLoaded', () => {
            const db = new KeyValueStore();
            let streamInterval = null;
            
            // This array will now hold the history of console output.
            let consoleHistory = [];

            const editor = CodeMirror.fromTextArea(document.getElementById('command-editor'), { mode: 'shell', theme: 'material-darker', lineNumbers: true, autofocus: true });
            const editorWrapper = document.getElementById('editor-wrapper');
            const observer = new ResizeObserver(() => editor.refresh());
            observer.observe(editorWrapper);

            const runCommandBtn = document.getElementById('run-command-btn');
            const consoleOutput = document.getElementById('console-output-content');
            const subscriptionsOutput = document.getElementById('subscriptions-content');
            const visualizationOutput = document.getElementById('visualization-content');
            const clearConsoleBtn = document.getElementById('clear-console-btn');
            const exampleCategoriesContainer = document.getElementById('example-categories');
            
            const streamKeyInput = document.getElementById('stream-key-input');
            const streamConfigInput = document.getElementById('stream-config-input');
            const startStreamBtn = document.getElementById('start-stream-btn');
            const stopStreamBtn = document.getElementById('stop-stream-btn');
            const streamStatus = document.getElementById('stream-status');

            const defaultStreamConfig = {
                "temp": { "type": "float", "range": [18.0, 25.0] },
                "humidity": { "type": "integer", "range": [40, 65] },
                "status": { "type": "string", "values": ["ok", "warning", "critical"] }
            };
            streamConfigInput.value = JSON.stringify(defaultStreamConfig, null, 2);

            // Redis Tutorial: Building an E-commerce Analytics System
            // Follow these examples in order to learn Redis through a practical scenario
            const exampleCategories = {
                "üè™ Tutorial: E-commerce Analytics System": [
                    { desc: "üìö Redis Command Syntax Guide & Tutorial Introduction", cmd: '# üöÄ Welcome to Redis Tutorial!\n# Learn Redis by building an e-commerce analytics system step by step\n\n# üìñ REDIS COMMAND SYNTAX:\n# Basic format: COMMAND key [value] [options]\n# Examples:\n#   SET key "value"           - Set a string value\n#   GET key                   - Get a string value\n#   LPUSH list item1 item2    - Add items to list (left)\n#   HSET hash field value     - Set hash field\n#   SADD set member1 member2  - Add to set\n#   ZADD zset score member    - Add to sorted set\n#   EXPIRE key seconds        - Set expiration\n\n# üîó PIPELINE COMMANDS:\n# Multiple commands can be sent together for efficiency\n# Just put each command on a new line\n\n# üí° BEST PRACTICES:\n# 1. Use meaningful key names (e.g., user:123:profile)\n# 2. Set TTL for temporary data\n# 3. Use appropriate data structures for your use case\n# 4. Use transactions for atomic operations\n\n# Let\'s start building our e-commerce system!' },
                ],
                
                "1Ô∏è‚É£ Strings & Counters - Site Metrics": [
                    { desc: "Set basic site information using SET command", cmd: 'SET site:name "TechStore"\nSET site:version "1.2.0"\nSET site:owner "Alice"' },
                    { desc: "Retrieve site information using GET command", cmd: 'GET site:name\nGET site:version\nGET site:owner' },
                    { desc: "Initialize page view counter with SET, then increment with INCR", cmd: 'SET page:views 0\nINCR page:views\nINCR page:views\nINCR page:views' },
                    { desc: "Increment by larger amounts using INCRBY (simulating traffic spikes)", cmd: 'INCRBY page:views 25\nINCRBY page:views 50\nGET page:views' },
                    { desc: "Track daily sales total and increment with each sale", cmd: 'SET sales:today 0\nINCRBY sales:today 299\nINCRBY sales:today 199\nINCRBY sales:today 99\nGET sales:today' },
                    { desc: "Use MSET to set multiple values at once for efficiency", cmd: 'MSET users:online 150 products:count 2500 orders:pending 23' },
                    { desc: "Use MGET to retrieve multiple values efficiently", cmd: 'MGET users:online products:count orders:pending page:views' },
                ],

                "2Ô∏è‚É£ Key Management & Expiration": [
                    { desc: "Set temporary session data with TTL using SETEX (expires in 30 seconds)", cmd: 'SETEX session:user123 30 "logged_in"\nGET session:user123' },
                    { desc: "Check time remaining with TTL command", cmd: 'TTL session:user123' },
                    { desc: "Set flash sale data and make it expire in 10 seconds", cmd: 'SET flash:sale "50% off laptops"\nEXPIRE flash:sale 10\nTTL flash:sale' },
                    { desc: "Check if keys exist before operations using EXISTS", cmd: 'EXISTS session:user123 flash:sale site:name nonexistent:key' },
                    { desc: "Delete specific keys using DEL command", cmd: 'DEL flash:sale\nEXISTS flash:sale' },
                    { desc: "Use multiple databases - switch to DB 1 for test data", cmd: 'SELECT 1\nSET test:data "development_mode"\nGET test:data' },
                    { desc: "Switch back to main database (DB 0)", cmd: 'SELECT 0\nGET site:name' },
                ],

                "3Ô∏è‚É£ Lists - Task Queues & Activity Logs": [
                    { desc: "Create a task queue using LPUSH (adds to left/front)", cmd: 'LPUSH order:queue "process_order_001"\nLPUSH order:queue "process_order_002"\nLPUSH order:queue "process_order_003"' },
                    { desc: "View the entire queue using LRANGE (0 to -1 means all items)", cmd: 'LRANGE order:queue 0 -1' },
                    { desc: "Process tasks from queue using RPOP (removes from right/back - FIFO)", cmd: 'RPOP order:queue\nRPOP order:queue\nLRANGE order:queue 0 -1' },
                    { desc: "Add new priority task to front of queue", cmd: 'LPUSH order:queue "urgent_order_004"\nLRANGE order:queue 0 -1' },
                    { desc: "Create activity log by pushing to right (chronological order)", cmd: 'RPUSH user:123:activity "login"\nRPUSH user:123:activity "view_product_laptop"\nRPUSH user:123:activity "add_to_cart"' },
                    { desc: "View recent activity (last 5 items)", cmd: 'LRANGE user:123:activity -5 -1' },
                    { desc: "Get specific item by index using LINDEX", cmd: 'LINDEX user:123:activity 0\nLINDEX user:123:activity -1' },
                    { desc: "Get queue length using LLEN", cmd: 'LLEN order:queue\nLLEN user:123:activity' },
                ],

                "4Ô∏è‚É£ Hashes - User Profiles & Product Data": [
                    { desc: "Create user profile using HSET (field-value pairs)", cmd: 'HSET user:123 name "John Doe"\nHSET user:123 email "john@example.com"\nHSET user:123 age 28' },
                    { desc: "Set multiple fields at once using HMSET", cmd: 'HMSET user:123 city "New York" country "USA" premium true points 1500' },
                    { desc: "Get single field using HGET", cmd: 'HGET user:123 name\nHGET user:123 email' },
                    { desc: "Get multiple fields using HMGET", cmd: 'HMGET user:123 name email city points' },
                    { desc: "Get all fields and values using HGETALL", cmd: 'HGETALL user:123' },
                    { desc: "Increment numeric field using HINCRBY", cmd: 'HINCRBY user:123 points 250\nHGET user:123 points' },
                    { desc: "Create product with multiple attributes", cmd: 'HMSET product:laptop001 name "Gaming Laptop" price 1299 stock 15 category "electronics" rating 4.5' },
                    { desc: "Update stock when item is sold", cmd: 'HINCRBY product:laptop001 stock -1\nHGET product:laptop001 stock' },
                    { desc: "Check if field exists using HEXISTS", cmd: 'HEXISTS user:123 email\nHEXISTS user:123 phone' },
                    { desc: "Remove field using HDEL", cmd: 'HDEL user:123 age\nHGETALL user:123' },
                ],

                "5Ô∏è‚É£ Sets - Tags & Categories": [
                    { desc: "Create product tags using SADD (unique members only)", cmd: 'SADD product:laptop001:tags "gaming" "portable" "high-performance" "rgb"\nSADD product:laptop001:tags "gaming"' },
                    { desc: "View all tags using SMEMBERS", cmd: 'SMEMBERS product:laptop001:tags' },
                    { desc: "Check if tag exists using SISMEMBER", cmd: 'SISMEMBER product:laptop001:tags "gaming"\nSISMEMBER product:laptop001:tags "budget"' },
                    { desc: "Create tags for another product", cmd: 'SADD product:mouse001:tags "gaming" "wireless" "rgb" "ergonomic"' },
                    { desc: "Find common tags between products using SINTER", cmd: 'SINTER product:laptop001:tags product:mouse001:tags' },
                    { desc: "Find all unique tags using SUNION", cmd: 'SUNION product:laptop001:tags product:mouse001:tags' },
                    { desc: "Create user\'s favorite categories", cmd: 'SADD user:123:interests "electronics" "gaming" "books" "music"' },
                    { desc: "Find products matching user interests", cmd: 'SISMEMBER user:123:interests "electronics"\nSISMEMBER user:123:interests "sports"' },
                    { desc: "Remove tag using SREM", cmd: 'SREM product:laptop001:tags "rgb"\nSMEMBERS product:laptop001:tags' },
                    { desc: "Get number of members using SCARD", cmd: 'SCARD product:laptop001:tags\nSCARD user:123:interests' },
                ],

                "6Ô∏è‚É£ Sorted Sets - Leaderboards & Rankings": [
                    { desc: "Create sales leaderboard using ZADD (score member)", cmd: 'ZADD sales:monthly 1299 "laptop001"\nZADD sales:monthly 299 "mouse001"\nZADD sales:monthly 599 "keyboard001"' },
                    { desc: "Add more sales data", cmd: 'ZADD sales:monthly 2499 "monitor001" 199 "headset001" 99 "mousepad001"' },
                    { desc: "Get top 3 products by sales using ZREVRANGE (highest first)", cmd: 'ZREVRANGE sales:monthly 0 2 WITHSCORES' },
                    { desc: "Get bottom 2 products using ZRANGE", cmd: 'ZRANGE sales:monthly 0 1 WITHSCORES' },
                    { desc: "Get total number of products using ZCARD", cmd: 'ZCARD sales:monthly' },
                    { desc: "Find rank of specific product using ZREVRANK", cmd: 'ZREVRANK sales:monthly "laptop001"\nZREVRANK sales:monthly "mousepad001"' },
                    { desc: "Get score of specific product using ZSCORE", cmd: 'ZSCORE sales:monthly "monitor001"' },
                    { desc: "Update sales for a product using ZINCRBY", cmd: 'ZINCRBY sales:monthly 300 "headset001"\nZSCORE sales:monthly "headset001"' },
                    { desc: "Find products in price range using ZRANGEBYSCORE", cmd: 'ZRANGEBYSCORE sales:monthly 200 600 WITHSCORES' },
                    { desc: "Remove product from leaderboard using ZREM", cmd: 'ZREM sales:monthly "mousepad001"\nZCARD sales:monthly' },
                ],

                "7Ô∏è‚É£ Geospatial - Store Locations": [
                    { desc: "Add store locations using GEOADD (longitude latitude member)", cmd: 'GEOADD stores 13.36 38.11 "store_palermo"\nGEOADD stores 15.08 37.50 "store_catania"' },
                    { desc: "Add more store locations", cmd: 'GEOADD stores 8.54 47.37 "store_zurich" 2.35 48.85 "store_paris" -0.12 51.50 "store_london"' },
                    { desc: "Find distance between stores using GEODIST", cmd: 'GEODIST stores "store_paris" "store_london" km' },
                    { desc: "Find stores within 500km of Paris using GEORADIUS", cmd: 'GEORADIUS stores 2.35 48.85 500 km WITHDIST' },
                    { desc: "Find nearby stores to a specific store using GEORADIUSBYMEMBER", cmd: 'GEORADIUSBYMEMBER stores "store_zurich" 800 km WITHDIST' },
                    { desc: "Get coordinates of a store using GEOPOS", cmd: 'GEOPOS stores "store_paris" "store_london"' },
                ],

                "8Ô∏è‚É£ Transactions - Atomic Operations": [
                    { desc: "Start transaction with MULTI, then queue commands", cmd: 'MULTI\nHINCRBY user:123 points -500\nHSET user:123 last_purchase "laptop001"\nINCR purchases:total' },
                    { desc: "Execute all commands atomically with EXEC", cmd: 'EXEC' },
                    { desc: "Verify the transaction worked", cmd: 'HGET user:123 points\nHGET user:123 last_purchase\nGET purchases:total' },
                    { desc: "Demo transaction rollback - start transaction then discard", cmd: 'MULTI\nSET temp:data "this will be discarded"\nINCR some:counter\nDISCARD' },
                    { desc: "Verify nothing was executed", cmd: 'GET temp:data' },
                ],

                "9Ô∏è‚É£ Pipeline Commands - Batch Operations": [
                    { desc: "Use pipeline for bulk operations (multiple commands sent together)", cmd: 'SET bulk:1 "value1"\nSET bulk:2 "value2"\nSET bulk:3 "value3"\nINCR bulk:counter\nINCR bulk:counter' },
                    { desc: "Verify bulk operations completed", cmd: 'MGET bulk:1 bulk:2 bulk:3\nGET bulk:counter' },
                ],

                "üîü Advanced Features - HyperLogLog & Streams": [
                    { desc: "Track unique visitors using HyperLogLog (memory efficient)", cmd: 'PFADD unique:visitors "user1" "user2" "user3" "user1"\nPFCOUNT unique:visitors' },
                    { desc: "Add more visitors and count", cmd: 'PFADD unique:visitors "user4" "user5" "user2"\nPFCOUNT unique:visitors' },
                    { desc: "Create activity stream using XADD", cmd: 'XADD activity:stream * user "john" action "login" timestamp "2025-01-01T10:00:00Z"' },
                    { desc: "Add more activities to stream", cmd: 'XADD activity:stream * user "alice" action "purchase" product "laptop001"\nXADD activity:stream * user "bob" action "view" product "mouse001"' },
                    { desc: "Read from stream using XREAD", cmd: 'XREAD STREAMS activity:stream 0-0' },
                    { desc: "Get stream length using XLEN", cmd: 'XLEN activity:stream' },
                ],

                "üìä Pub/Sub - Real-time Notifications": [
                    { desc: "Subscribe to notifications (opens Subscriptions tab)", cmd: 'SUBSCRIBE orders alerts promotions' },
                    { desc: "Publish order notification", cmd: 'PUBLISH orders "New order #1001 received from user123"' },
                    { desc: "Publish alert", cmd: 'PUBLISH alerts "Low stock warning: laptop001 has only 2 items left"' },
                    { desc: "Publish promotion", cmd: 'PUBLISH promotions "Flash sale: 20% off all gaming accessories!"' },
                    { desc: "Unsubscribe from specific channel", cmd: 'UNSUBSCRIBE promotions' },
                ],

                "üîß Database Administration": [
                    { desc: "Get information about the database", cmd: 'INFO memory\nINFO keyspace' },
                    { desc: "View all keys matching pattern", cmd: 'KEYS *user*\nKEYS product:*' },
                    { desc: "Get database size", cmd: 'DBSIZE' },
                    { desc: "Test connection", cmd: 'PING' },
                    { desc: "Get configuration values", cmd: 'CONFIG GET maxmemory\nCONFIG GET *' },
                    { desc: "Set configuration values", cmd: 'CONFIG SET timeout 300\nCONFIG SET maxmemory 100mb' },
                    { desc: "View client connections", cmd: 'CLIENT LIST' },
                    { desc: "Get memory usage information", cmd: 'MEMORY USAGE user:123\nMEMORY STATS' },
                    { desc: "Database persistence commands", cmd: 'LASTSAVE\nSAVE\nBGSAVE' },
                    { desc: "Clear current database (BE CAREFUL!)", cmd: 'FLUSHDB' },
                    { desc: "Verify database is empty", cmd: 'DBSIZE' },
                ],

                "‚ùå Common Error Examples": [
                    { desc: "Wrong number of arguments", cmd: 'SET\nGET' },
                    { desc: "Wrong data type operation", cmd: 'SET mystring "hello"\nLPUSH mystring "item"' },
                    { desc: "Operation on non-existent key", cmd: 'LPOP nonexistent:list' },
                ],

                "üîß Edge Cases & Error Handling": [
                    { desc: "SET overwrites any existing value (Redis behavior)", cmd: 'SET key1 "string_value"\nSET key1 123\nGET key1' },
                    { desc: "INCR on non-existent key starts from 0", cmd: 'DEL counter\nINCR counter\nGET counter' },
                    { desc: "INCR on non-integer value throws error", cmd: 'SET not_number "hello"\nINCR not_number' },
                    { desc: "WRONGTYPE error when using wrong command on wrong data type", cmd: 'LPUSH mylist "item1"\nGET mylist' },
                    { desc: "SETNX (set if not exists) vs SET behavior", cmd: 'SET existing_key "value1"\nSETNX existing_key "value2"\nGET existing_key' },
                    { desc: "Multiple database isolation test", cmd: 'SELECT 0\nSET shared_key "db0_value"\nSELECT 1\nSET shared_key "db1_value"\nSELECT 0\nGET shared_key' },
                    { desc: "TTL and expiration edge cases", cmd: 'SET temp_key "will_expire"\nEXPIRE temp_key 1\nGET temp_key\n# Wait 2 seconds then check again:\nGET temp_key' },
                    { desc: "Atomic operations demonstration", cmd: 'SET counter 0\nINCR counter\nINCRBY counter 5\nDECR counter\nGET counter' },
                ],
            };

            function populateExamples() {
                let html = '';
                for (const category in exampleCategories) {
                    html += `<h3 class="text-lg font-semibold text-gray-200">${category}</h3><div class="space-y-2">`;
                    exampleCategories[category].forEach(({ desc, cmd }) => {
                        html += `<button data-command="${cmd.replace(/"/g, '&quot;')}" class="w-full text-left bg-gray-800/50 hover:bg-gray-700/70 text-gray-300 rounded-md overflow-hidden p-3">
                                    <p class="text-xs font-semibold text-gray-300">${desc}</p>
                                    <pre class="text-gray-400 font-mono text-xs overflow-x-auto custom-scrollbar pt-1"><code>${cmd}</code></pre>
                                </button>`;
                    });
                    html += `</div>`;
                }
                exampleCategoriesContainer.innerHTML = html;

                exampleCategoriesContainer.querySelectorAll('button').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const commandText = btn.dataset.command;
                        editor.setValue(commandText);
                        editor.focus();
                        if (window.innerWidth <= 768) {
                            showMobileView('editor');
                        }
                    });
                });
            }
            
            // This function now stores output in an array and re-renders the DOM.
            function logToConsole(output, isError = false, command = null) {
                // Store the command and output in the history array
                consoleHistory.push({ command: command, output: output, isError: isError });
                
                // Then, re-render the entire console from the history
                renderConsole();
            }

            // This new function handles rendering the history to the DOM
            function renderConsole() {
                // Clear the console DOM first
                consoleOutput.innerHTML = '';
                
                // Add an initial welcome message if there is no history
                if (consoleHistory.length === 0) {
                    const welcomeEntry = document.createElement('div');
                    welcomeEntry.innerHTML = `<span class="prompt">></span> Welcome! Check the new Visualization tab to see your data.`;
                    welcomeEntry.classList.add('py-1', 'border-b', 'border-gray-700/50');
                    consoleOutput.appendChild(welcomeEntry);
                }

                // Iterate over the history and append each entry
                consoleHistory.forEach(entry => {
                    const entryDiv = document.createElement('div');
                    const prompt = entry.command ? `<div class="prompt text-gray-500 text-xs truncate">${entry.command}</div>` : '';
                    let formattedOutput;
                    if (entry.isError) {
                        formattedOutput = `<span class="error">(error) ${entry.output}</span>`;
                    } else {
                        const dataStr = typeof entry.output === 'object' ? JSON.stringify(entry.output, null, 2) : entry.output;
                        formattedOutput = `<span class="ok">${dataStr}</span>`;
                    }
                    entryDiv.innerHTML = prompt + formattedOutput;
                    entryDiv.classList.add('py-1', 'border-b', 'border-gray-700/50');
                    consoleOutput.appendChild(entryDiv);
                });
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }


            function logToSubscription(channel, message) { const entry = document.createElement('div'); entry.innerHTML = `<span class="prompt">[${channel}] </span><span class="ok">"${message}"</span>`; entry.classList.add('py-1', 'border-b', 'border-gray-700/50'); subscriptionsOutput.appendChild(entry); subscriptionsOutput.scrollTop = subscriptionsOutput.scrollHeight; }
            
            db.setPubSubCallback(logToSubscription);

            function execute(commandBlock) { 
                const commands = commandBlock.split('\n').filter(cmd => cmd.trim() !== '' && !cmd.trim().startsWith('#')); 
                if (commands.length === 0) return; 
                commands.forEach(command => { 
                    const result = db.execute(command); 
                    if (result.status === 'ok') { 
                        logToConsole(result.data, false, command); 
                    } else { 
                        logToConsole(result.message, true, command); 
                    } 
                });
                renderVisualization();
            }

            runCommandBtn.addEventListener('click', () => { execute(editor.getValue()); });
            editor.setOption("extraKeys", { "Ctrl-Enter": () => { execute(editor.getValue()); }});
            
            // The clear button now clears the history array and re-renders
            clearConsoleBtn.addEventListener('click', () => { 
                consoleHistory = [];
                renderConsole();
                subscriptionsOutput.innerHTML = '<span class="prompt">></span> Subscriptions cleared.';
                db.databases.forEach(dbMap => dbMap.clear());
                renderVisualization();
            });

            function generateRandomData(schema) { const payload = []; for (const field in schema) { const conf = schema[field]; payload.push(field); if (conf.type === 'integer' && conf.range) { payload.push(Math.floor(Math.random() * (conf.range[1] - conf.range[0] + 1) + conf.range[0])); } else if (conf.type === 'float' && conf.range) { payload.push((Math.random() * (conf.range[1] - conf.range[0]) + conf.range[0]).toFixed(2)); } else if (conf.type === 'string' && conf.values) { payload.push(conf.values[Math.floor(Math.random() * conf.values.length)]); } else { payload.push('null'); } } return payload.join(' '); }

            startStreamBtn.addEventListener('click', () => {
                const streamKey = streamKeyInput.value.trim();
                if (!streamKey || streamInterval) return;
                let schema;
                try {
                    schema = JSON.parse(streamConfigInput.value);
                } catch (e) {
                    streamStatus.textContent = 'Invalid JSON in schema!';
                    return;
                }

                startStreamBtn.disabled = true;
                stopStreamBtn.disabled = false;
                streamStatus.textContent = 'Event producer running...';

                streamInterval = setInterval(() => {
                    const payload = generateRandomData(schema);
                    const xaddCommand = `XADD ${streamKey} * ${payload}`;
                    const publishCommand = `PUBLISH ${streamKey} "${payload}"`;
                    execute(xaddCommand);
                    execute(publishCommand);
                }, 1500);
            });

            stopStreamBtn.addEventListener('click', () => { if (!streamInterval) return; clearInterval(streamInterval); streamInterval = null; startStreamBtn.disabled = false; stopStreamBtn.disabled = true; streamStatus.textContent = 'Producer stopped.'; });

            const resizer = document.getElementById('resizer');
            const editorContainer = document.getElementById('editor-container');
            const resultsContainer = document.getElementById('results-container');
            const leftPanel = document.getElementById('left-panel');
            const rightPanel = document.getElementById('right-panel');
            const mobileNavButtons = document.querySelectorAll('.mobile-nav-btn');
            resizer.addEventListener('mousedown', () => { document.addEventListener('mousemove', handleMouseMove); document.addEventListener('mouseup', () => { document.removeEventListener('mousemove', handleMouseMove); }); });
            function handleMouseMove(e) { const rightPanelHeight = rightPanel.offsetHeight; const newEditorHeight = e.clientY - editorContainer.getBoundingClientRect().top; if (newEditorHeight > 100 && newEditorHeight < rightPanelHeight - 80) { editorContainer.style.height = `${(newEditorHeight / rightPanelHeight) * 100}%`; resultsContainer.style.height = `${100 - ((newEditorHeight / rightPanelHeight) * 100)}%`; editor.refresh(); } }
            
            function showMobileView(view) {
                mobileNavButtons.forEach(btn => btn.classList.remove('active'));
                
                if (view === 'info') {
                    leftPanel.classList.remove('hidden');
                    rightPanel.classList.add('hidden');
                    document.querySelector('.mobile-nav-btn[data-view="info"]').classList.add('active');
                } else if (view === 'editor') {
                    rightPanel.classList.remove('hidden');
                    leftPanel.classList.add('hidden');
                    document.querySelector('.mobile-nav-btn[data-view="editor"]').classList.add('active');
                }
            }

            mobileNavButtons.forEach(btn => { 
                btn.addEventListener('click', () => {
                    showMobileView(btn.dataset.view);
                });
            });

            function handleResize() {
                if (window.innerWidth > 768) {
                    leftPanel.classList.remove('hidden');
                    rightPanel.classList.remove('hidden');
                } else {
                    showMobileView('info');
                }
            }

            const resultsTabs = document.querySelectorAll('.results-tab-btn');
            const resultsTabContents = document.querySelectorAll('.results-tab-content');

            resultsTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    resultsTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    // Map tab name to the actual content element id. The console tab
                    // uses 'console-output-content' while others follow '<name>-content'.
                    const targetId = tab.dataset.tab === 'console' ? 'console-output-content' : `${tab.dataset.tab}-content`;

                    resultsTabContents.forEach(content => {
                        if (content.id === targetId) {
                            content.classList.remove('hidden');
                        } else {
                            content.classList.add('hidden');
                        }
                    });

                    if (tab.dataset.tab === 'visualization') {
                        renderVisualization();
                    } else if (tab.dataset.tab === 'console') {
                        // Re-render the console history when the tab is clicked.
                        renderConsole();
                    }
                });
            });
            
            function renderVisualization() {
                visualizationOutput.innerHTML = '';
                const allDbs = db.databases;
                const activeDb = db.activeDbIndex;

                allDbs.forEach((dbMap, index) => {
                    if (dbMap.size === 0) return;

                    const details = document.createElement('details');
                    details.open = index === activeDb;

                    const summary = document.createElement('summary');
                    summary.className = 'text-lg font-semibold text-gray-200 cursor-pointer';
                    summary.textContent = `Database ${index}`;
                    details.appendChild(summary);
                    
                    const table = document.createElement('table');
                    table.className = 'w-full text-sm text-left text-gray-400 mt-2';
                    table.innerHTML = `<thead class="text-xs text-gray-300 uppercase bg-gray-700/50"><tr>
                        <th class="px-4 py-2">Key</th><th class="px-4 py-2">Type</th><th class="px-4 py-2">Value</th>
                    </tr></thead><tbody></tbody>`;
                    const tbody = table.querySelector('tbody');

                    dbMap.forEach((value, key) => {
                        const row = tbody.insertRow();
                        row.className = 'border-b border-gray-700';
                        const keyCell = row.insertCell();
                        const typeCell = row.insertCell();
                        const valueCell = row.insertCell();
                        
                        keyCell.className = 'px-4 py-2 font-mono text-sky-400';
                        keyCell.textContent = key;
                        typeCell.className = 'px-4 py-2 font-mono text-xs text-yellow-400';
                        valueCell.className = 'px-4 py-2 font-mono text-xs';
                        
                        let type = 'string';
                        let displayValue = JSON.stringify(value);

                        if (Array.isArray(value)) {
                            if (value.length > 0 && value[0].hasOwnProperty('score')) type = 'zset';
                            else if (value.length > 0 && value[0].hasOwnProperty('lon')) type = 'geo';
                            else type = 'list';
                        } else if (value instanceof Map) {
                            type = 'hash';
                            displayValue = JSON.stringify(Object.fromEntries(value));
                        } else if (value instanceof Set) {
                            type = 'set';
                            displayValue = JSON.stringify(Array.from(value));
                        } else if (value.hasOwnProperty('entries')) {
                            type = 'stream';
                            displayValue = `[${value.entries.length} entries, ${value.groups.size} groups]`;
                        }
                        
                        typeCell.textContent = type;
                        valueCell.textContent = displayValue;
                    });
                    
                    details.appendChild(table);
                    visualizationOutput.appendChild(details);
                });
                 if (visualizationOutput.innerHTML === '') {
                    visualizationOutput.innerHTML = '<span class="prompt">></span> No data to visualize.';
                }
            }

            window.addEventListener('resize', handleResize);
            populateExamples();
            handleResize();
            renderVisualization();
            renderConsole(); // Initial render of the console
        });
    </script>
</body>
</html>
